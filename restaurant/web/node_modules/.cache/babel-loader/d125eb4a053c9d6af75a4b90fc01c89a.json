{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst sodium = require(\"sodium-native\");\n\nexports.box = (messageInBytes, nonceInBytes, convertedPublicKey, convertedPrivateKey) => {\n  const cipherBytes = Buffer.alloc(messageInBytes.length + sodium.crypto_box_MACBYTES);\n  sodium.crypto_box_easy(cipherBytes, messageInBytes, nonceInBytes, convertedPublicKey, convertedPrivateKey);\n  return cipherBytes;\n};\n\nexports.openBox = (cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey) => {\n  const plainText = Buffer.alloc(cipherBytes.length - sodium.crypto_box_MACBYTES);\n\n  if (!sodium.crypto_box_open_easy(plainText, cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey)) {\n    throw new Error('Failed to decrypt message');\n  }\n\n  return plainText;\n};\n\nexports.signDetached = (messageBytes, privateKeyBytes) => {\n  const signatureBytes = Buffer.alloc(sodium.crypto_sign_BYTES);\n  sodium.crypto_sign_detached(signatureBytes, messageBytes, privateKeyBytes);\n  return signatureBytes;\n};\n\nexports.verifyDetached = (messageBytes, signatureBytes, publicKeyBytes) => sodium.crypto_sign_verify_detached(signatureBytes, messageBytes, publicKeyBytes);\n\nexports.getRandomBytes = length => {\n  const nonce = Buffer.alloc(length);\n  sodium.randombytes_buf(nonce);\n  return nonce;\n};\n\nexports.getKeyPair = hashedSeed => {\n  const publicKeyBytes = Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES);\n  const privateKeyBytes = Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES);\n  sodium.crypto_sign_seed_keypair(publicKeyBytes, privateKeyBytes, hashedSeed);\n  return {\n    publicKeyBytes,\n    privateKeyBytes\n  };\n};\n\nexports.getPublicKey = privateKey => {\n  const publicKeyBytes = Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES);\n  const privateKeyBytes = Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES);\n  sodium.crypto_sign_seed_keypair(publicKeyBytes, privateKeyBytes, privateKey);\n  return publicKeyBytes;\n};","map":{"version":3,"sources":["../../src/nacl/fast.ts"],"names":[],"mappings":";;;;;;AAeA,MAAA,MAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAGa,OAAA,CAAA,GAAA,GAA4B,CACxC,cADwC,EAExC,YAFwC,EAGxC,kBAHwC,EAIxC,mBAJwC,KAKrC;AACH,QAAM,WAAW,GAAG,MAAM,CAAC,KAAP,CACnB,cAAc,CAAC,MAAf,GAAwB,MAAM,CAAC,mBADZ,CAApB;AAGA,EAAA,MAAM,CAAC,eAAP,CACC,WADD,EAEC,cAFD,EAGC,YAHD,EAIC,kBAJD,EAKC,mBALD;AAQA,SAAO,WAAP;AACA,CAlBY;;AAoBA,OAAA,CAAA,OAAA,GAAoC,CAChD,WADgD,EAEhD,UAFgD,EAGhD,kBAHgD,EAIhD,mBAJgD,KAK7C;AACH,QAAM,SAAS,GAAG,MAAM,CAAC,KAAP,CACjB,WAAW,CAAC,MAAZ,GAAqB,MAAM,CAAC,mBADX,CAAlB;;AAIA,MACC,CAAC,MAAM,CAAC,oBAAP,CACA,SADA,EAEA,WAFA,EAGA,UAHA,EAIA,kBAJA,EAKA,mBALA,CADF,EAQE;AACD,UAAM,IAAI,KAAJ,CAAU,2BAAV,CAAN;AACA;;AAED,SAAO,SAAP;AACA,CAvBY;;AAyBA,OAAA,CAAA,YAAA,GAA8C,CAC1D,YAD0D,EAE1D,eAF0D,KAGvD;AACH,QAAM,cAAc,GAAG,MAAM,CAAC,KAAP,CAAa,MAAM,CAAC,iBAApB,CAAvB;AACA,EAAA,MAAM,CAAC,oBAAP,CAA4B,cAA5B,EAA4C,YAA5C,EAA0D,eAA1D;AAEA,SAAO,cAAP;AACA,CARY;;AAUA,OAAA,CAAA,cAAA,GAAkD,CAC9D,YAD8D,EAE9D,cAF8D,EAG9D,cAH8D,KAK9D,MAAM,CAAC,2BAAP,CACC,cADD,EAEC,YAFD,EAGC,cAHD,CALY;;AAWA,OAAA,CAAA,cAAA,GAAkD,MAAM,IAAG;AACvE,QAAM,KAAK,GAAG,MAAM,CAAC,KAAP,CAAa,MAAb,CAAd;AACA,EAAA,MAAM,CAAC,eAAP,CAAuB,KAAvB;AAEA,SAAO,KAAP;AACA,CALY;;AAOA,OAAA,CAAA,UAAA,GAA0C,UAAU,IAAG;AACnE,QAAM,cAAc,GAAG,MAAM,CAAC,KAAP,CAAa,MAAM,CAAC,0BAApB,CAAvB;AACA,QAAM,eAAe,GAAG,MAAM,CAAC,KAAP,CAAa,MAAM,CAAC,0BAApB,CAAxB;AAEA,EAAA,MAAM,CAAC,wBAAP,CAAgC,cAAhC,EAAgD,eAAhD,EAAiE,UAAjE;AAEA,SAAO;AACN,IAAA,cADM;AAEN,IAAA;AAFM,GAAP;AAIA,CAVY;;AAYA,OAAA,CAAA,YAAA,GAA8C,UAAU,IAAG;AACvE,QAAM,cAAc,GAAG,MAAM,CAAC,KAAP,CAAa,MAAM,CAAC,0BAApB,CAAvB;AACA,QAAM,eAAe,GAAG,MAAM,CAAC,KAAP,CAAa,MAAM,CAAC,0BAApB,CAAxB;AAEA,EAAA,MAAM,CAAC,wBAAP,CAAgC,cAAhC,EAAgD,eAAhD,EAAiE,UAAjE;AAEA,SAAO,cAAP;AACA,CAPY","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sodium = require(\"sodium-native\");\r\nexports.box = (messageInBytes, nonceInBytes, convertedPublicKey, convertedPrivateKey) => {\r\n    const cipherBytes = Buffer.alloc(messageInBytes.length + sodium.crypto_box_MACBYTES);\r\n    sodium.crypto_box_easy(cipherBytes, messageInBytes, nonceInBytes, convertedPublicKey, convertedPrivateKey);\r\n    return cipherBytes;\r\n};\r\nexports.openBox = (cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey) => {\r\n    const plainText = Buffer.alloc(cipherBytes.length - sodium.crypto_box_MACBYTES);\r\n    if (!sodium.crypto_box_open_easy(plainText, cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey)) {\r\n        throw new Error('Failed to decrypt message');\r\n    }\r\n    return plainText;\r\n};\r\nexports.signDetached = (messageBytes, privateKeyBytes) => {\r\n    const signatureBytes = Buffer.alloc(sodium.crypto_sign_BYTES);\r\n    sodium.crypto_sign_detached(signatureBytes, messageBytes, privateKeyBytes);\r\n    return signatureBytes;\r\n};\r\nexports.verifyDetached = (messageBytes, signatureBytes, publicKeyBytes) => sodium.crypto_sign_verify_detached(signatureBytes, messageBytes, publicKeyBytes);\r\nexports.getRandomBytes = length => {\r\n    const nonce = Buffer.alloc(length);\r\n    sodium.randombytes_buf(nonce);\r\n    return nonce;\r\n};\r\nexports.getKeyPair = hashedSeed => {\r\n    const publicKeyBytes = Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES);\r\n    const privateKeyBytes = Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES);\r\n    sodium.crypto_sign_seed_keypair(publicKeyBytes, privateKeyBytes, hashedSeed);\r\n    return {\r\n        publicKeyBytes,\r\n        privateKeyBytes,\r\n    };\r\n};\r\nexports.getPublicKey = privateKey => {\r\n    const publicKeyBytes = Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES);\r\n    const privateKeyBytes = Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES);\r\n    sodium.crypto_sign_seed_keypair(publicKeyBytes, privateKeyBytes, privateKey);\r\n    return publicKeyBytes;\r\n};\r\n//# sourceMappingURL=fast.js.map"]},"metadata":{},"sourceType":"script"}