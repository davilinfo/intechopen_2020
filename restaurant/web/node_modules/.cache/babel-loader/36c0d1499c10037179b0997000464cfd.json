{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\davin.DESKTOP-83VQBDE\\\\Documents\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\davin.DESKTOP-83VQBDE\\\\Documents\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\davin.DESKTOP-83VQBDE\\\\Documents\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\davin.DESKTOP-83VQBDE\\\\Documents\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\davin.DESKTOP-83VQBDE\\\\Documents\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:\\\\Users\\\\davin.DESKTOP-83VQBDE\\\\Documents\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\davin.DESKTOP-83VQBDE\\\\Documents\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BigNum = require(\"@liskhq/bignum\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar base_transaction_1 = require(\"./base_transaction\");\n\nvar constants_1 = require(\"./constants\");\n\nvar errors_1 = require(\"./errors\");\n\nvar response_1 = require(\"./response\");\n\nvar utils_1 = require(\"./utils\");\n\nexports.multisignatureAssetFormatSchema = {\n  type: 'object',\n  required: ['multisignature'],\n  properties: {\n    multisignature: {\n      type: 'object',\n      required: ['min', 'lifetime', 'keysgroup'],\n      properties: {\n        min: {\n          type: 'integer',\n          minimum: 1,\n          maximum: 15\n        },\n        lifetime: {\n          type: 'integer',\n          minimum: 1,\n          maximum: 72\n        },\n        keysgroup: {\n          type: 'array',\n          uniqueItems: true,\n          minItems: 1,\n          maxItems: 15,\n          items: {\n            type: 'string',\n            format: 'additionPublicKey'\n          }\n        }\n      }\n    }\n  }\n};\n\nvar setMemberAccounts = function setMemberAccounts(store, membersPublicKeys) {\n  membersPublicKeys.forEach(function (memberPublicKey) {\n    var address = lisk_cryptography_1.getAddressFromPublicKey(memberPublicKey);\n    var memberAccount = store.account.getOrDefault(address);\n    var memberAccountWithPublicKey = Object.assign({}, memberAccount, {\n      publicKey: memberAccount.publicKey || memberPublicKey\n    });\n    store.account.set(memberAccount.address, memberAccountWithPublicKey);\n  });\n};\n\nvar extractPublicKeysFromAsset = function extractPublicKeysFromAsset(assetPublicKeys) {\n  return assetPublicKeys.map(function (key) {\n    return key.substring(1);\n  });\n};\n\nvar MultisignatureTransaction = /*#__PURE__*/function (_base_transaction_1$B) {\n  _inherits(MultisignatureTransaction, _base_transaction_1$B);\n\n  var _super = _createSuper(MultisignatureTransaction);\n\n  function MultisignatureTransaction(rawTransaction) {\n    var _this;\n\n    _classCallCheck(this, MultisignatureTransaction);\n\n    _this = _super.call(this, rawTransaction);\n    _this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;\n    var tx = typeof rawTransaction === 'object' && rawTransaction !== null ? rawTransaction : {};\n    _this.asset = tx.asset || {\n      multisignature: {}\n    };\n    return _this;\n  }\n\n  _createClass(MultisignatureTransaction, [{\n    key: \"assetToBytes\",\n    value: function assetToBytes() {\n      var _this$asset$multisign = this.asset.multisignature,\n          min = _this$asset$multisign.min,\n          lifetime = _this$asset$multisign.lifetime,\n          keysgroup = _this$asset$multisign.keysgroup;\n      var minBuffer = Buffer.alloc(1, min);\n      var lifetimeBuffer = Buffer.alloc(1, lifetime);\n      var keysgroupBuffer = Buffer.from(keysgroup.join(''), 'utf8');\n      return Buffer.concat([minBuffer, lifetimeBuffer, keysgroupBuffer]);\n    }\n  }, {\n    key: \"prepare\",\n    value: function () {\n      var _prepare = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(store) {\n        var membersAddresses;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                membersAddresses = extractPublicKeysFromAsset(this.asset.multisignature.keysgroup).map(function (publicKey) {\n                  return {\n                    address: lisk_cryptography_1.getAddressFromPublicKey(publicKey)\n                  };\n                });\n                _context.next = 3;\n                return store.account.cache([{\n                  address: this.senderId\n                }].concat(_toConsumableArray(membersAddresses)));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function prepare(_x) {\n        return _prepare.apply(this, arguments);\n      }\n\n      return prepare;\n    }()\n  }, {\n    key: \"verifyAgainstTransactions\",\n    value: function verifyAgainstTransactions(transactions) {\n      var _this2 = this;\n\n      var errors = transactions.filter(function (tx) {\n        return tx.type === _this2.type && tx.senderPublicKey === _this2.senderPublicKey;\n      }).map(function (tx) {\n        return new errors_1.TransactionError('Register multisignature only allowed once per account.', tx.id, '.asset.multisignature');\n      });\n      return errors;\n    }\n  }, {\n    key: \"validateAsset\",\n    value: function validateAsset() {\n      utils_1.validator.validate(exports.multisignatureAssetFormatSchema, this.asset);\n      var errors = errors_1.convertToAssetError(this.id, utils_1.validator.errors);\n\n      if (!this.amount.eq(0)) {\n        errors.push(new errors_1.TransactionError('Amount must be zero for multisignature registration transaction', this.id, '.amount', this.amount.toString(), '0'));\n      }\n\n      if (errors.length > 0) {\n        return errors;\n      }\n\n      if (this.asset.multisignature.min > this.asset.multisignature.keysgroup.length) {\n        errors.push(new errors_1.TransactionError('Invalid multisignature min. Must be less than or equal to keysgroup size', this.id, '.asset.multisignature.min', this.asset.multisignature.min));\n      }\n\n      if (this.recipientId) {\n        errors.push(new errors_1.TransactionError('RecipientId is expected to be undefined', this.id, '.recipientId', this.recipientId));\n      }\n\n      if (this.recipientPublicKey) {\n        errors.push(new errors_1.TransactionError('RecipientPublicKey is expected to be undefined', this.id, '.recipientPublicKey', this.recipientPublicKey));\n      }\n\n      return errors;\n    }\n  }, {\n    key: \"validateFee\",\n    value: function validateFee() {\n      var expectedFee = new BigNum(MultisignatureTransaction.FEE).mul(this.asset.multisignature.keysgroup.length + 1);\n      return !this.fee.eq(expectedFee) ? new errors_1.TransactionError(\"Fee must be equal to \".concat(expectedFee.toString()), this.id, '.fee', this.fee.toString(), expectedFee.toString()) : undefined;\n    }\n  }, {\n    key: \"processMultisignatures\",\n    value: function processMultisignatures(_) {\n      var transactionBytes = this.getBasicBytes();\n\n      var _utils_1$validateMult = utils_1.validateMultisignatures(this.asset.multisignature.keysgroup.map(function (signedPublicKey) {\n        return signedPublicKey.substring(1);\n      }), this.signatures, this.asset.multisignature.keysgroup.length, transactionBytes, this.id),\n          valid = _utils_1$validateMult.valid,\n          errors = _utils_1$validateMult.errors;\n\n      if (valid) {\n        this._multisignatureStatus = base_transaction_1.MultisignatureStatus.READY;\n        return response_1.createResponse(this.id, errors);\n      }\n\n      if (errors && errors.length === 1 && errors[0] instanceof errors_1.TransactionPendingError) {\n        this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;\n        return {\n          id: this.id,\n          status: response_1.Status.PENDING,\n          errors: errors\n        };\n      }\n\n      this._multisignatureStatus = base_transaction_1.MultisignatureStatus.FAIL;\n      return response_1.createResponse(this.id, errors);\n    }\n  }, {\n    key: \"applyAsset\",\n    value: function applyAsset(store) {\n      var errors = [];\n      var sender = store.account.get(this.senderId);\n\n      if (sender.membersPublicKeys && sender.membersPublicKeys.length > 0) {\n        errors.push(new errors_1.TransactionError('Register multisignature only allowed once per account.', this.id, '.signatures'));\n      }\n\n      if (this.asset.multisignature.keysgroup.includes(\"+\".concat(sender.publicKey))) {\n        errors.push(new errors_1.TransactionError('Invalid multisignature keysgroup. Can not contain sender', this.id, '.signatures'));\n      }\n\n      var updatedSender = Object.assign({}, sender, {\n        membersPublicKeys: extractPublicKeysFromAsset(this.asset.multisignature.keysgroup),\n        multiMin: this.asset.multisignature.min,\n        multiLifetime: this.asset.multisignature.lifetime\n      });\n      store.account.set(updatedSender.address, updatedSender);\n      setMemberAccounts(store, updatedSender.membersPublicKeys);\n      return errors;\n    }\n  }, {\n    key: \"undoAsset\",\n    value: function undoAsset(store) {\n      var sender = store.account.get(this.senderId);\n      var resetSender = Object.assign({}, sender, {\n        membersPublicKeys: [],\n        multiMin: 0,\n        multiLifetime: 0\n      });\n      store.account.set(resetSender.address, resetSender);\n      return [];\n    }\n  }, {\n    key: \"addMultisignature\",\n    value: function addMultisignature(store, signatureObject) {\n      var keysgroup = this.asset.multisignature.keysgroup.map(function (aKey) {\n        return aKey.slice(1);\n      });\n\n      if (!keysgroup.includes(signatureObject.publicKey)) {\n        return response_1.createResponse(this.id, [new errors_1.TransactionError(\"Public Key '\".concat(signatureObject.publicKey, \"' is not a member.\"), this.id)]);\n      }\n\n      if (this.signatures.includes(signatureObject.signature)) {\n        return response_1.createResponse(this.id, [new errors_1.TransactionError('Encountered duplicate signature in transaction', this.id)]);\n      }\n\n      var _utils_1$validateSign = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, this.getBasicBytes(), this.id),\n          valid = _utils_1$validateSign.valid;\n\n      if (valid) {\n        this.signatures.push(signatureObject.signature);\n        return this.processMultisignatures(store);\n      }\n\n      var errors = valid ? [] : [new errors_1.TransactionError(\"Failed to add signature \".concat(signatureObject.signature, \".\"), this.id, '.signatures')];\n      return response_1.createResponse(this.id, errors);\n    }\n  }, {\n    key: \"assetFromSync\",\n    value: function assetFromSync(raw) {\n      if (!raw.m_keysgroup) {\n        return undefined;\n      }\n\n      var multisignature = {\n        min: raw.m_min,\n        lifetime: raw.m_lifetime,\n        keysgroup: typeof raw.m_keysgroup === 'string' ? raw.m_keysgroup.split(',') : raw.m_keysgroup\n      };\n      return {\n        multisignature: multisignature\n      };\n    }\n  }]);\n\n  return MultisignatureTransaction;\n}(base_transaction_1.BaseTransaction);\n\nMultisignatureTransaction.TYPE = 4;\nMultisignatureTransaction.FEE = constants_1.MULTISIGNATURE_FEE.toString();\nexports.MultisignatureTransaction = MultisignatureTransaction;","map":{"version":3,"sources":["../src/4_multisignature_transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BigNum = require(\"@liskhq/bignum\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst base_transaction_1 = require(\"./base_transaction\");\nconst constants_1 = require(\"./constants\");\nconst errors_1 = require(\"./errors\");\nconst response_1 = require(\"./response\");\nconst utils_1 = require(\"./utils\");\nexports.multisignatureAssetFormatSchema = {\n    type: 'object',\n    required: ['multisignature'],\n    properties: {\n        multisignature: {\n            type: 'object',\n            required: ['min', 'lifetime', 'keysgroup'],\n            properties: {\n                min: {\n                    type: 'integer',\n                    minimum: 1,\n                    maximum: 15,\n                },\n                lifetime: {\n                    type: 'integer',\n                    minimum: 1,\n                    maximum: 72,\n                },\n                keysgroup: {\n                    type: 'array',\n                    uniqueItems: true,\n                    minItems: 1,\n                    maxItems: 15,\n                    items: {\n                        type: 'string',\n                        format: 'additionPublicKey',\n                    },\n                },\n            },\n        },\n    },\n};\nconst setMemberAccounts = (store, membersPublicKeys) => {\n    membersPublicKeys.forEach(memberPublicKey => {\n        const address = lisk_cryptography_1.getAddressFromPublicKey(memberPublicKey);\n        const memberAccount = store.account.getOrDefault(address);\n        const memberAccountWithPublicKey = Object.assign({}, memberAccount, { publicKey: memberAccount.publicKey || memberPublicKey });\n        store.account.set(memberAccount.address, memberAccountWithPublicKey);\n    });\n};\nconst extractPublicKeysFromAsset = (assetPublicKeys) => assetPublicKeys.map(key => key.substring(1));\nclass MultisignatureTransaction extends base_transaction_1.BaseTransaction {\n    constructor(rawTransaction) {\n        super(rawTransaction);\n        this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;\n        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null\n            ? rawTransaction\n            : {});\n        this.asset = (tx.asset || { multisignature: {} });\n    }\n    assetToBytes() {\n        const { multisignature: { min, lifetime, keysgroup }, } = this.asset;\n        const minBuffer = Buffer.alloc(1, min);\n        const lifetimeBuffer = Buffer.alloc(1, lifetime);\n        const keysgroupBuffer = Buffer.from(keysgroup.join(''), 'utf8');\n        return Buffer.concat([minBuffer, lifetimeBuffer, keysgroupBuffer]);\n    }\n    async prepare(store) {\n        const membersAddresses = extractPublicKeysFromAsset(this.asset.multisignature.keysgroup).map(publicKey => ({ address: lisk_cryptography_1.getAddressFromPublicKey(publicKey) }));\n        await store.account.cache([\n            {\n                address: this.senderId,\n            },\n            ...membersAddresses,\n        ]);\n    }\n    verifyAgainstTransactions(transactions) {\n        const errors = transactions\n            .filter(tx => tx.type === this.type && tx.senderPublicKey === this.senderPublicKey)\n            .map(tx => new errors_1.TransactionError('Register multisignature only allowed once per account.', tx.id, '.asset.multisignature'));\n        return errors;\n    }\n    validateAsset() {\n        utils_1.validator.validate(exports.multisignatureAssetFormatSchema, this.asset);\n        const errors = errors_1.convertToAssetError(this.id, utils_1.validator.errors);\n        if (!this.amount.eq(0)) {\n            errors.push(new errors_1.TransactionError('Amount must be zero for multisignature registration transaction', this.id, '.amount', this.amount.toString(), '0'));\n        }\n        if (errors.length > 0) {\n            return errors;\n        }\n        if (this.asset.multisignature.min > this.asset.multisignature.keysgroup.length) {\n            errors.push(new errors_1.TransactionError('Invalid multisignature min. Must be less than or equal to keysgroup size', this.id, '.asset.multisignature.min', this.asset.multisignature.min));\n        }\n        if (this.recipientId) {\n            errors.push(new errors_1.TransactionError('RecipientId is expected to be undefined', this.id, '.recipientId', this.recipientId));\n        }\n        if (this.recipientPublicKey) {\n            errors.push(new errors_1.TransactionError('RecipientPublicKey is expected to be undefined', this.id, '.recipientPublicKey', this.recipientPublicKey));\n        }\n        return errors;\n    }\n    validateFee() {\n        const expectedFee = new BigNum(MultisignatureTransaction.FEE).mul(this.asset.multisignature.keysgroup.length + 1);\n        return !this.fee.eq(expectedFee)\n            ? new errors_1.TransactionError(`Fee must be equal to ${expectedFee.toString()}`, this.id, '.fee', this.fee.toString(), expectedFee.toString())\n            : undefined;\n    }\n    processMultisignatures(_) {\n        const transactionBytes = this.getBasicBytes();\n        const { valid, errors } = utils_1.validateMultisignatures(this.asset.multisignature.keysgroup.map(signedPublicKey => signedPublicKey.substring(1)), this.signatures, this.asset.multisignature.keysgroup.length, transactionBytes, this.id);\n        if (valid) {\n            this._multisignatureStatus = base_transaction_1.MultisignatureStatus.READY;\n            return response_1.createResponse(this.id, errors);\n        }\n        if (errors &&\n            errors.length === 1 &&\n            errors[0] instanceof errors_1.TransactionPendingError) {\n            this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;\n            return {\n                id: this.id,\n                status: response_1.Status.PENDING,\n                errors,\n            };\n        }\n        this._multisignatureStatus = base_transaction_1.MultisignatureStatus.FAIL;\n        return response_1.createResponse(this.id, errors);\n    }\n    applyAsset(store) {\n        const errors = [];\n        const sender = store.account.get(this.senderId);\n        if (sender.membersPublicKeys && sender.membersPublicKeys.length > 0) {\n            errors.push(new errors_1.TransactionError('Register multisignature only allowed once per account.', this.id, '.signatures'));\n        }\n        if (this.asset.multisignature.keysgroup.includes(`+${sender.publicKey}`)) {\n            errors.push(new errors_1.TransactionError('Invalid multisignature keysgroup. Can not contain sender', this.id, '.signatures'));\n        }\n        const updatedSender = Object.assign({}, sender, { membersPublicKeys: extractPublicKeysFromAsset(this.asset.multisignature.keysgroup), multiMin: this.asset.multisignature.min, multiLifetime: this.asset.multisignature.lifetime });\n        store.account.set(updatedSender.address, updatedSender);\n        setMemberAccounts(store, updatedSender.membersPublicKeys);\n        return errors;\n    }\n    undoAsset(store) {\n        const sender = store.account.get(this.senderId);\n        const resetSender = Object.assign({}, sender, { membersPublicKeys: [], multiMin: 0, multiLifetime: 0 });\n        store.account.set(resetSender.address, resetSender);\n        return [];\n    }\n    addMultisignature(store, signatureObject) {\n        const keysgroup = this.asset.multisignature.keysgroup.map((aKey) => aKey.slice(1));\n        if (!keysgroup.includes(signatureObject.publicKey)) {\n            return response_1.createResponse(this.id, [\n                new errors_1.TransactionError(`Public Key '${signatureObject.publicKey}' is not a member.`, this.id),\n            ]);\n        }\n        if (this.signatures.includes(signatureObject.signature)) {\n            return response_1.createResponse(this.id, [\n                new errors_1.TransactionError('Encountered duplicate signature in transaction', this.id),\n            ]);\n        }\n        const { valid } = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, this.getBasicBytes(), this.id);\n        if (valid) {\n            this.signatures.push(signatureObject.signature);\n            return this.processMultisignatures(store);\n        }\n        const errors = valid\n            ? []\n            : [\n                new errors_1.TransactionError(`Failed to add signature ${signatureObject.signature}.`, this.id, '.signatures'),\n            ];\n        return response_1.createResponse(this.id, errors);\n    }\n    assetFromSync(raw) {\n        if (!raw.m_keysgroup) {\n            return undefined;\n        }\n        const multisignature = {\n            min: raw.m_min,\n            lifetime: raw.m_lifetime,\n            keysgroup: typeof raw.m_keysgroup === 'string'\n                ? raw.m_keysgroup.split(',')\n                : raw.m_keysgroup,\n        };\n        return { multisignature };\n    }\n}\nMultisignatureTransaction.TYPE = 4;\nMultisignatureTransaction.FEE = constants_1.MULTISIGNATURE_FEE.toString();\nexports.MultisignatureTransaction = MultisignatureTransaction;\n//# sourceMappingURL=4_multisignature_transaction.js.map"]},"metadata":{},"sourceType":"script"}