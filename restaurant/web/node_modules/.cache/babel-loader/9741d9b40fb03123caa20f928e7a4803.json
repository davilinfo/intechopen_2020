{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst schemas = require(\"./schema\");\n\nconst validator_1 = require(\"./validator\");\n\nconst TRANSACTION_TYPE_MULTI_SIGNATURE = 4;\nconst schemaMap = {\n  0: validator_1.validator.compile(schemas.transferTransaction),\n  1: validator_1.validator.compile(schemas.signatureTransaction),\n  2: validator_1.validator.compile(schemas.delegateTransaction),\n  3: validator_1.validator.compile(schemas.voteTransaction),\n  4: validator_1.validator.compile(schemas.multiTransaction),\n  5: validator_1.validator.compile(schemas.dappTransaction)\n};\n\nconst getTransactionSchemaValidator = type => {\n  const schema = schemaMap[type];\n\n  if (!schema) {\n    throw new Error('Unsupported transaction type.');\n  }\n\n  return schema;\n};\n\nconst validateMultiTransaction = tx => {\n  if (tx.asset.multisignature.min > tx.asset.multisignature.keysgroup.length) {\n    return {\n      valid: false,\n      errors: [{\n        dataPath: '.asset.multisignature.min',\n        keyword: 'multisignatures.keysgroup.min',\n        message: '.asset.multisignature.min cannot be greater than .asset.multisignature.keysgroup.length',\n        params: {},\n        schemaPath: 'lisk/base-transaction'\n      }]\n    };\n  }\n\n  return {\n    valid: true\n  };\n};\n\nexports.validateTransaction = tx => {\n  if (tx.type === undefined || tx.type === null) {\n    throw new Error('Transaction type is required.');\n  }\n\n  const validateSchema = getTransactionSchemaValidator(tx.type);\n  const valid = validateSchema(tx);\n  const errors = validateSchema.errors ? validateSchema.errors.filter(e => e.keyword !== '$merge') : undefined;\n\n  if (valid && tx.type === TRANSACTION_TYPE_MULTI_SIGNATURE) {\n    return validateMultiTransaction(tx);\n  }\n\n  return {\n    valid,\n    errors\n  };\n};","map":{"version":3,"sources":["../../../src/utils/validation/validate_transaction.ts"],"names":[],"mappings":";;;;;;AAiBA,MAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAEA,MAAM,gCAAgC,GAAG,CAAzC;AAEA,MAAM,SAAS,GAAiD;AAC/D,KAAG,WAAA,CAAA,SAAA,CAAU,OAAV,CAAkB,OAAO,CAAC,mBAA1B,CAD4D;AAE/D,KAAG,WAAA,CAAA,SAAA,CAAU,OAAV,CAAkB,OAAO,CAAC,oBAA1B,CAF4D;AAG/D,KAAG,WAAA,CAAA,SAAA,CAAU,OAAV,CAAkB,OAAO,CAAC,mBAA1B,CAH4D;AAI/D,KAAG,WAAA,CAAA,SAAA,CAAU,OAAV,CAAkB,OAAO,CAAC,eAA1B,CAJ4D;AAK/D,KAAG,WAAA,CAAA,SAAA,CAAU,OAAV,CAAkB,OAAO,CAAC,gBAA1B,CAL4D;AAM/D,KAAG,WAAA,CAAA,SAAA,CAAU,OAAV,CAAkB,OAAO,CAAC,eAA1B;AAN4D,CAAhE;;AASA,MAAM,6BAA6B,GAAI,IAAD,IAAmC;AACxE,QAAM,MAAM,GAAG,SAAS,CAAC,IAAD,CAAxB;;AACA,MAAI,CAAC,MAAL,EAAa;AACZ,UAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN;AACA;;AAED,SAAO,MAAP;AACA,CAPD;;AAcA,MAAM,wBAAwB,GAAI,EAAD,IAA0C;AAC1E,MACE,EAAE,CAAC,KAAH,CAAiC,cAAjC,CAAgD,GAAhD,GACA,EAAE,CAAC,KAAH,CAAiC,cAAjC,CAAgD,SAAhD,CAA0D,MAF5D,EAGE;AACD,WAAO;AACN,MAAA,KAAK,EAAE,KADD;AAEN,MAAA,MAAM,EAAE,CACP;AACC,QAAA,QAAQ,EAAE,2BADX;AAEC,QAAA,OAAO,EAAE,+BAFV;AAGC,QAAA,OAAO,EACN,yFAJF;AAKC,QAAA,MAAM,EAAE,EALT;AAMC,QAAA,UAAU,EAAE;AANb,OADO;AAFF,KAAP;AAaA;;AAED,SAAO;AACN,IAAA,KAAK,EAAE;AADD,GAAP;AAGA,CAvBD;;AAyBa,OAAA,CAAA,mBAAA,GAAuB,EAAD,IAA0C;AAC5E,MAAI,EAAE,CAAC,IAAH,KAAY,SAAZ,IAAyB,EAAE,CAAC,IAAH,KAAY,IAAzC,EAA+C;AAC9C,UAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN;AACA;;AAED,QAAM,cAAc,GAAG,6BAA6B,CAAC,EAAE,CAAC,IAAJ,CAApD;AACA,QAAM,KAAK,GAAG,cAAc,CAAC,EAAD,CAA5B;AAEA,QAAM,MAAM,GAAG,cAAc,CAAC,MAAf,GACZ,cAAc,CAAC,MAAf,CAAsB,MAAtB,CACC,CAAD,IAAqC,CAAC,CAAC,OAAF,KAAc,QADnD,CADY,GAIZ,SAJH;;AAKA,MAAI,KAAK,IAAI,EAAE,CAAC,IAAH,KAAY,gCAAzB,EAA2D;AAC1D,WAAO,wBAAwB,CAAC,EAAD,CAA/B;AACA;;AAED,SAAO;AACN,IAAA,KADM;AAEN,IAAA;AAFM,GAAP;AAIA,CArBY","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst schemas = require(\"./schema\");\r\nconst validator_1 = require(\"./validator\");\r\nconst TRANSACTION_TYPE_MULTI_SIGNATURE = 4;\r\nconst schemaMap = {\r\n    0: validator_1.validator.compile(schemas.transferTransaction),\r\n    1: validator_1.validator.compile(schemas.signatureTransaction),\r\n    2: validator_1.validator.compile(schemas.delegateTransaction),\r\n    3: validator_1.validator.compile(schemas.voteTransaction),\r\n    4: validator_1.validator.compile(schemas.multiTransaction),\r\n    5: validator_1.validator.compile(schemas.dappTransaction),\r\n};\r\nconst getTransactionSchemaValidator = (type) => {\r\n    const schema = schemaMap[type];\r\n    if (!schema) {\r\n        throw new Error('Unsupported transaction type.');\r\n    }\r\n    return schema;\r\n};\r\nconst validateMultiTransaction = (tx) => {\r\n    if (tx.asset.multisignature.min >\r\n        tx.asset.multisignature.keysgroup.length) {\r\n        return {\r\n            valid: false,\r\n            errors: [\r\n                {\r\n                    dataPath: '.asset.multisignature.min',\r\n                    keyword: 'multisignatures.keysgroup.min',\r\n                    message: '.asset.multisignature.min cannot be greater than .asset.multisignature.keysgroup.length',\r\n                    params: {},\r\n                    schemaPath: 'lisk/base-transaction',\r\n                },\r\n            ],\r\n        };\r\n    }\r\n    return {\r\n        valid: true,\r\n    };\r\n};\r\nexports.validateTransaction = (tx) => {\r\n    if (tx.type === undefined || tx.type === null) {\r\n        throw new Error('Transaction type is required.');\r\n    }\r\n    const validateSchema = getTransactionSchemaValidator(tx.type);\r\n    const valid = validateSchema(tx);\r\n    const errors = validateSchema.errors\r\n        ? validateSchema.errors.filter((e) => e.keyword !== '$merge')\r\n        : undefined;\r\n    if (valid && tx.type === TRANSACTION_TYPE_MULTI_SIGNATURE) {\r\n        return validateMultiTransaction(tx);\r\n    }\r\n    return {\r\n        valid,\r\n        errors,\r\n    };\r\n};\r\n//# sourceMappingURL=validate_transaction.js.map"]},"metadata":{},"sourceType":"script"}