{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BigNum = require(\"@liskhq/bignum\");\n\nexports.BIG_ENDIAN = 'big';\nexports.LITTLE_ENDIAN = 'little';\n\nexports.intToBuffer = (value, byteLength, endianness = exports.BIG_ENDIAN) => new BigNum(value).toBuffer({\n  size: byteLength,\n  endian: endianness\n});\n\nexports.bufferToIntAsString = buffer => BigNum.fromBuffer(buffer).toString();\n\nexports.bigNumberToBuffer = (bignumber, size, endian = exports.BIG_ENDIAN) => exports.intToBuffer(bignumber, size, endian);\n\nexports.bufferToBigNumberString = bigNumberBuffer => exports.bufferToIntAsString(bigNumberBuffer);\n\nexports.bufferToHex = buffer => Buffer.from(buffer).toString('hex');\n\nconst hexRegex = /^[0-9a-f]+/i;\n\nexports.hexToBuffer = (hex, argumentName = 'Argument') => {\n  if (typeof hex !== 'string') {\n    throw new TypeError(`${argumentName} must be a string.`);\n  }\n\n  const matchedHex = (hex.match(hexRegex) || [])[0];\n\n  if (!matchedHex || matchedHex.length !== hex.length) {\n    throw new TypeError(`${argumentName} must be a valid hex string.`);\n  }\n\n  if (matchedHex.length % 2 !== 0) {\n    throw new TypeError(`${argumentName} must have a valid length of hex string.`);\n  }\n\n  return Buffer.from(matchedHex, 'hex');\n};\n\nexports.stringToBuffer = str => Buffer.from(str, 'utf8');","map":{"version":3,"sources":["../src/buffer.ts"],"names":[],"mappings":";;;;;;AAcA,MAAA,MAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEa,OAAA,CAAA,UAAA,GAAa,KAAb;AACA,OAAA,CAAA,aAAA,GAAgB,QAAhB;;AAEA,OAAA,CAAA,WAAA,GAAc,CAC1B,KAD0B,EAE1B,UAF0B,EAG1B,UAAA,GAAqB,OAAA,CAAA,UAHK,KAItB,IAAI,MAAJ,CAAW,KAAX,EAAkB,QAAlB,CAA2B;AAAE,EAAA,IAAI,EAAE,UAAR;AAAoB,EAAA,MAAM,EAAE;AAA5B,CAA3B,CAJQ;;AAMA,OAAA,CAAA,mBAAA,GAAuB,MAAD,IAClC,MAAM,CAAC,UAAP,CAAkB,MAAlB,EAA0B,QAA1B,EADY;;AAOA,OAAA,CAAA,iBAAA,GAAoB,CAChC,SADgC,EAEhC,IAFgC,EAGhC,MAAA,GAAiB,OAAA,CAAA,UAHe,KAI5B,OAAA,CAAA,WAAA,CAAY,SAAZ,EAAuB,IAAvB,EAA6B,MAA7B,CAJQ;;AAUA,OAAA,CAAA,uBAAA,GAA2B,eAAD,IACtC,OAAA,CAAA,mBAAA,CAAoB,eAApB,CADY;;AAGA,OAAA,CAAA,WAAA,GAAe,MAAD,IAC1B,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,QAApB,CAA6B,KAA7B,CADY;;AAGb,MAAM,QAAQ,GAAG,aAAjB;;AACa,OAAA,CAAA,WAAA,GAAc,CAAC,GAAD,EAAc,YAAY,GAAG,UAA7B,KAAmD;AAC7E,MAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AAC5B,UAAM,IAAI,SAAJ,CAAc,GAAG,YAAY,oBAA7B,CAAN;AACA;;AACD,QAAM,UAAU,GAAG,CAAC,GAAG,CAAC,KAAJ,CAAU,QAAV,KAAuB,EAAxB,EAA4B,CAA5B,CAAnB;;AACA,MAAI,CAAC,UAAD,IAAe,UAAU,CAAC,MAAX,KAAsB,GAAG,CAAC,MAA7C,EAAqD;AACpD,UAAM,IAAI,SAAJ,CAAc,GAAG,YAAY,8BAA7B,CAAN;AACA;;AAED,MAAI,UAAU,CAAC,MAAX,GAAoB,CAApB,KAA0B,CAA9B,EAAiC;AAChC,UAAM,IAAI,SAAJ,CACL,GAAG,YAAY,0CADV,CAAN;AAGA;;AAED,SAAO,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAwB,KAAxB,CAAP;AACA,CAhBY;;AAkBA,OAAA,CAAA,cAAA,GAAkB,GAAD,IAAyB,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,MAAjB,CAA1C","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BigNum = require(\"@liskhq/bignum\");\nexports.BIG_ENDIAN = 'big';\nexports.LITTLE_ENDIAN = 'little';\nexports.intToBuffer = (value, byteLength, endianness = exports.BIG_ENDIAN) => new BigNum(value).toBuffer({ size: byteLength, endian: endianness });\nexports.bufferToIntAsString = (buffer) => BigNum.fromBuffer(buffer).toString();\nexports.bigNumberToBuffer = (bignumber, size, endian = exports.BIG_ENDIAN) => exports.intToBuffer(bignumber, size, endian);\nexports.bufferToBigNumberString = (bigNumberBuffer) => exports.bufferToIntAsString(bigNumberBuffer);\nexports.bufferToHex = (buffer) => Buffer.from(buffer).toString('hex');\nconst hexRegex = /^[0-9a-f]+/i;\nexports.hexToBuffer = (hex, argumentName = 'Argument') => {\n    if (typeof hex !== 'string') {\n        throw new TypeError(`${argumentName} must be a string.`);\n    }\n    const matchedHex = (hex.match(hexRegex) || [])[0];\n    if (!matchedHex || matchedHex.length !== hex.length) {\n        throw new TypeError(`${argumentName} must be a valid hex string.`);\n    }\n    if (matchedHex.length % 2 !== 0) {\n        throw new TypeError(`${argumentName} must have a valid length of hex string.`);\n    }\n    return Buffer.from(matchedHex, 'hex');\n};\nexports.stringToBuffer = (str) => Buffer.from(str, 'utf8');\n//# sourceMappingURL=buffer.js.map"]},"metadata":{},"sourceType":"script"}