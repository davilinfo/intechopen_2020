{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tweetnacl = require(\"tweetnacl\");\n\nexports.box = function (messageInBytes, nonceInBytes, convertedPublicKey, convertedPrivateKey) {\n  return Buffer.from(tweetnacl.box(messageInBytes, nonceInBytes, convertedPublicKey, convertedPrivateKey));\n};\n\nexports.openBox = function (cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey) {\n  var originalMessage = tweetnacl.box.open(cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey);\n\n  if (originalMessage === null) {\n    throw new Error('Failed to decrypt message');\n  }\n\n  return Buffer.from(originalMessage);\n};\n\nexports.signDetached = function (messageBytes, privateKeyBytes) {\n  return Buffer.from(tweetnacl.sign.detached(messageBytes, privateKeyBytes));\n};\n\nexports.verifyDetached = tweetnacl.sign.detached.verify;\n\nexports.getRandomBytes = function (length) {\n  return Buffer.from(tweetnacl.randomBytes(length));\n};\n\nexports.getKeyPair = function (hashedSeed) {\n  var _tweetnacl$sign$keyPa = tweetnacl.sign.keyPair.fromSeed(hashedSeed),\n      publicKey = _tweetnacl$sign$keyPa.publicKey,\n      secretKey = _tweetnacl$sign$keyPa.secretKey;\n\n  return {\n    privateKeyBytes: Buffer.from(secretKey),\n    publicKeyBytes: Buffer.from(publicKey)\n  };\n};\n\nvar PRIVATE_KEY_LENGTH = 32;\n\nexports.getPublicKey = function (privateKey) {\n  var _tweetnacl$sign$keyPa2 = tweetnacl.sign.keyPair.fromSeed(privateKey.slice(0, PRIVATE_KEY_LENGTH)),\n      publicKey = _tweetnacl$sign$keyPa2.publicKey;\n\n  return Buffer.from(publicKey);\n};","map":{"version":3,"sources":["../../src/nacl/slow.ts"],"names":[],"mappings":";;;;;;AAcA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAGa,OAAA,CAAA,GAAA,GAA4B,UACxC,cADwC,EAExC,YAFwC,EAGxC,kBAHwC,EAIxC,mBAJwC;AAAA,SAMxC,MAAM,CAAC,IAAP,CACC,SAAS,CAAC,GAAV,CACC,cADD,EAEC,YAFD,EAGC,kBAHD,EAIC,mBAJD,CADD,CANwC;AAAA,CAA5B;;AAeA,OAAA,CAAA,OAAA,GAAoC,UAChD,WADgD,EAEhD,UAFgD,EAGhD,kBAHgD,EAIhD,mBAJgD,EAK7C;AACH,MAAM,eAAe,GAAG,SAAS,CAAC,GAAV,CAAc,IAAd,CACvB,WADuB,EAEvB,UAFuB,EAGvB,kBAHuB,EAIvB,mBAJuB,CAAxB;;AAOA,MAAI,eAAe,KAAK,IAAxB,EAA8B;AAC7B,UAAM,IAAI,KAAJ,CAAU,2BAAV,CAAN;AACA;;AAED,SAAO,MAAM,CAAC,IAAP,CAAY,eAAZ,CAAP;AACA,CAlBY;;AAoBA,OAAA,CAAA,YAAA,GAA8C,UAC1D,YAD0D,EAE1D,eAF0D;AAAA,SAGtD,MAAM,CAAC,IAAP,CAAY,SAAS,CAAC,IAAV,CAAe,QAAf,CAAwB,YAAxB,EAAsC,eAAtC,CAAZ,CAHsD;AAAA,CAA9C;;AAKA,OAAA,CAAA,cAAA,GAEZ,SAAS,CAAC,IAAV,CAAe,QAAf,CAAwB,MAFZ;;AAIA,OAAA,CAAA,cAAA,GAAkD,UAAA,MAAM;AAAA,SACpE,MAAM,CAAC,IAAP,CAAY,SAAS,CAAC,WAAV,CAAsB,MAAtB,CAAZ,CADoE;AAAA,CAAxD;;AAGA,OAAA,CAAA,UAAA,GAA0C,UAAA,UAAU,EAAG;AAAA,8BAClC,SAAS,CAAC,IAAV,CAAe,OAAf,CAAuB,QAAvB,CAAgC,UAAhC,CADkC;AAAA,MAC3D,SAD2D,yBAC3D,SAD2D;AAAA,MAChD,SADgD,yBAChD,SADgD;;AAGnE,SAAO;AACN,IAAA,eAAe,EAAE,MAAM,CAAC,IAAP,CAAY,SAAZ,CADX;AAEN,IAAA,cAAc,EAAE,MAAM,CAAC,IAAP,CAAY,SAAZ;AAFV,GAAP;AAIA,CAPY;;AASb,IAAM,kBAAkB,GAAG,EAA3B;;AAEa,OAAA,CAAA,YAAA,GAA8C,UAAA,UAAU,EAAG;AAAA,+BACjD,SAAS,CAAC,IAAV,CAAe,OAAf,CAAuB,QAAvB,CACrB,UAAU,CAAC,KAAX,CAAiB,CAAjB,EAAoB,kBAApB,CADqB,CADiD;AAAA,MAC/D,SAD+D,0BAC/D,SAD+D;;AAKvE,SAAO,MAAM,CAAC,IAAP,CAAY,SAAZ,CAAP;AACA,CANY","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tweetnacl = require(\"tweetnacl\");\nexports.box = (messageInBytes, nonceInBytes, convertedPublicKey, convertedPrivateKey) => Buffer.from(tweetnacl.box(messageInBytes, nonceInBytes, convertedPublicKey, convertedPrivateKey));\nexports.openBox = (cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey) => {\n    const originalMessage = tweetnacl.box.open(cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey);\n    if (originalMessage === null) {\n        throw new Error('Failed to decrypt message');\n    }\n    return Buffer.from(originalMessage);\n};\nexports.signDetached = (messageBytes, privateKeyBytes) => Buffer.from(tweetnacl.sign.detached(messageBytes, privateKeyBytes));\nexports.verifyDetached = tweetnacl.sign.detached.verify;\nexports.getRandomBytes = length => Buffer.from(tweetnacl.randomBytes(length));\nexports.getKeyPair = hashedSeed => {\n    const { publicKey, secretKey } = tweetnacl.sign.keyPair.fromSeed(hashedSeed);\n    return {\n        privateKeyBytes: Buffer.from(secretKey),\n        publicKeyBytes: Buffer.from(publicKey),\n    };\n};\nconst PRIVATE_KEY_LENGTH = 32;\nexports.getPublicKey = privateKey => {\n    const { publicKey } = tweetnacl.sign.keyPair.fromSeed(privateKey.slice(0, PRIVATE_KEY_LENGTH));\n    return Buffer.from(publicKey);\n};\n//# sourceMappingURL=slow.js.map"]},"metadata":{},"sourceType":"script"}