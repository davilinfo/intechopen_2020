{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto = require(\"crypto\");\n\nvar buffer_1 = require(\"./buffer\");\n\nvar convert_1 = require(\"./convert\");\n\nvar keys_1 = require(\"./keys\");\n\nvar nacl_1 = require(\"./nacl\");\n\nvar PBKDF2_ITERATIONS = 1e6;\nvar PBKDF2_KEYLEN = 32;\nvar PBKDF2_HASH_FUNCTION = 'sha256';\nvar ENCRYPTION_VERSION = '1';\n\nexports.encryptMessageWithPassphrase = function (message, passphrase, recipientPublicKey) {\n  var _keys_1$getPrivateAnd = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase),\n      senderPrivateKeyBytes = _keys_1$getPrivateAnd.privateKeyBytes;\n\n  var convertedPrivateKey = Buffer.from(convert_1.convertPrivateKeyEd2Curve(senderPrivateKeyBytes));\n  var recipientPublicKeyBytes = buffer_1.hexToBuffer(recipientPublicKey);\n  var messageInBytes = Buffer.from(message, 'utf8');\n  var nonceSize = 24;\n  var nonce = nacl_1.getRandomBytes(nonceSize);\n  var publicKeyUint8Array = convert_1.convertPublicKeyEd2Curve(recipientPublicKeyBytes);\n\n  if (publicKeyUint8Array === null) {\n    throw new Error('given public key is not a valid Ed25519 public key');\n  }\n\n  var convertedPublicKey = Buffer.from(publicKeyUint8Array);\n  var cipherBytes = nacl_1.box(messageInBytes, nonce, convertedPublicKey, convertedPrivateKey);\n  var nonceHex = buffer_1.bufferToHex(nonce);\n  var encryptedMessage = buffer_1.bufferToHex(cipherBytes);\n  return {\n    nonce: nonceHex,\n    encryptedMessage: encryptedMessage\n  };\n};\n\nexports.decryptMessageWithPassphrase = function (cipherHex, nonce, passphrase, senderPublicKey) {\n  var _keys_1$getPrivateAnd2 = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase),\n      recipientPrivateKeyBytes = _keys_1$getPrivateAnd2.privateKeyBytes;\n\n  var convertedPrivateKey = Buffer.from(convert_1.convertPrivateKeyEd2Curve(recipientPrivateKeyBytes));\n  var senderPublicKeyBytes = buffer_1.hexToBuffer(senderPublicKey);\n  var cipherBytes = buffer_1.hexToBuffer(cipherHex);\n  var nonceBytes = buffer_1.hexToBuffer(nonce);\n  var publicKeyUint8Array = convert_1.convertPublicKeyEd2Curve(senderPublicKeyBytes);\n\n  if (publicKeyUint8Array === null) {\n    throw new Error('given public key is not a valid Ed25519 public key');\n  }\n\n  var convertedPublicKey = Buffer.from(publicKeyUint8Array);\n\n  try {\n    var decoded = nacl_1.openBox(cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey);\n    return Buffer.from(decoded).toString();\n  } catch (error) {\n    if (error.message.match(/bad nonce size|nonce must be a buffer of size crypto_box_NONCEBYTES/)) {\n      throw new Error('Expected nonce to be 24 bytes.');\n    }\n\n    throw new Error('Something went wrong during decryption. Is this the full encrypted message?');\n  }\n};\n\nvar getKeyFromPassword = function getKeyFromPassword(password, salt, iterations) {\n  return crypto.pbkdf2Sync(password, salt, iterations, PBKDF2_KEYLEN, PBKDF2_HASH_FUNCTION);\n};\n\nvar encryptAES256GCMWithPassword = function encryptAES256GCMWithPassword(plainText, password) {\n  var iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PBKDF2_ITERATIONS;\n  var IV_BUFFER_SIZE = 12;\n  var SALT_BUFFER_SIZE = 16;\n  var iv = crypto.randomBytes(IV_BUFFER_SIZE);\n  var salt = crypto.randomBytes(SALT_BUFFER_SIZE);\n  var key = getKeyFromPassword(password, salt, iterations);\n  var cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\n  var firstBlock = cipher.update(plainText, 'utf8');\n  var encrypted = Buffer.concat([firstBlock, cipher.final()]);\n  var tag = cipher.getAuthTag();\n  return {\n    iterations: iterations,\n    cipherText: encrypted.toString('hex'),\n    iv: iv.toString('hex'),\n    salt: salt.toString('hex'),\n    tag: tag.toString('hex'),\n    version: ENCRYPTION_VERSION\n  };\n};\n\nvar getTagBuffer = function getTagBuffer(tag) {\n  var TAG_BUFFER_SIZE = 16;\n  var tagBuffer = buffer_1.hexToBuffer(tag, 'Tag');\n\n  if (tagBuffer.length !== TAG_BUFFER_SIZE) {\n    throw new Error('Tag must be 16 bytes.');\n  }\n\n  return tagBuffer;\n};\n\nvar decryptAES256GCMWithPassword = function decryptAES256GCMWithPassword(encryptedPassphrase, password) {\n  var _encryptedPassphrase$ = encryptedPassphrase.iterations,\n      iterations = _encryptedPassphrase$ === void 0 ? PBKDF2_ITERATIONS : _encryptedPassphrase$,\n      cipherText = encryptedPassphrase.cipherText,\n      iv = encryptedPassphrase.iv,\n      salt = encryptedPassphrase.salt,\n      tag = encryptedPassphrase.tag;\n  var tagBuffer = getTagBuffer(tag);\n  var key = getKeyFromPassword(password, buffer_1.hexToBuffer(salt, 'Salt'), iterations);\n  var decipher = crypto.createDecipheriv('aes-256-gcm', key, buffer_1.hexToBuffer(iv, 'IV'));\n  decipher.setAuthTag(tagBuffer);\n  var firstBlock = decipher.update(buffer_1.hexToBuffer(cipherText, 'Cipher text'));\n  var decrypted = Buffer.concat([firstBlock, decipher.final()]);\n  return decrypted.toString();\n};\n\nexports.encryptPassphraseWithPassword = encryptAES256GCMWithPassword;\nexports.decryptPassphraseWithPassword = decryptAES256GCMWithPassword;","map":{"version":3,"sources":["../src/encrypt.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto = require(\"crypto\");\nconst buffer_1 = require(\"./buffer\");\nconst convert_1 = require(\"./convert\");\nconst keys_1 = require(\"./keys\");\nconst nacl_1 = require(\"./nacl\");\nconst PBKDF2_ITERATIONS = 1e6;\nconst PBKDF2_KEYLEN = 32;\nconst PBKDF2_HASH_FUNCTION = 'sha256';\nconst ENCRYPTION_VERSION = '1';\nexports.encryptMessageWithPassphrase = (message, passphrase, recipientPublicKey) => {\n    const { privateKeyBytes: senderPrivateKeyBytes, } = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\n    const convertedPrivateKey = Buffer.from(convert_1.convertPrivateKeyEd2Curve(senderPrivateKeyBytes));\n    const recipientPublicKeyBytes = buffer_1.hexToBuffer(recipientPublicKey);\n    const messageInBytes = Buffer.from(message, 'utf8');\n    const nonceSize = 24;\n    const nonce = nacl_1.getRandomBytes(nonceSize);\n    const publicKeyUint8Array = convert_1.convertPublicKeyEd2Curve(recipientPublicKeyBytes);\n    if (publicKeyUint8Array === null) {\n        throw new Error('given public key is not a valid Ed25519 public key');\n    }\n    const convertedPublicKey = Buffer.from(publicKeyUint8Array);\n    const cipherBytes = nacl_1.box(messageInBytes, nonce, convertedPublicKey, convertedPrivateKey);\n    const nonceHex = buffer_1.bufferToHex(nonce);\n    const encryptedMessage = buffer_1.bufferToHex(cipherBytes);\n    return {\n        nonce: nonceHex,\n        encryptedMessage,\n    };\n};\nexports.decryptMessageWithPassphrase = (cipherHex, nonce, passphrase, senderPublicKey) => {\n    const { privateKeyBytes: recipientPrivateKeyBytes, } = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\n    const convertedPrivateKey = Buffer.from(convert_1.convertPrivateKeyEd2Curve(recipientPrivateKeyBytes));\n    const senderPublicKeyBytes = buffer_1.hexToBuffer(senderPublicKey);\n    const cipherBytes = buffer_1.hexToBuffer(cipherHex);\n    const nonceBytes = buffer_1.hexToBuffer(nonce);\n    const publicKeyUint8Array = convert_1.convertPublicKeyEd2Curve(senderPublicKeyBytes);\n    if (publicKeyUint8Array === null) {\n        throw new Error('given public key is not a valid Ed25519 public key');\n    }\n    const convertedPublicKey = Buffer.from(publicKeyUint8Array);\n    try {\n        const decoded = nacl_1.openBox(cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey);\n        return Buffer.from(decoded).toString();\n    }\n    catch (error) {\n        if (error.message.match(/bad nonce size|nonce must be a buffer of size crypto_box_NONCEBYTES/)) {\n            throw new Error('Expected nonce to be 24 bytes.');\n        }\n        throw new Error('Something went wrong during decryption. Is this the full encrypted message?');\n    }\n};\nconst getKeyFromPassword = (password, salt, iterations) => crypto.pbkdf2Sync(password, salt, iterations, PBKDF2_KEYLEN, PBKDF2_HASH_FUNCTION);\nconst encryptAES256GCMWithPassword = (plainText, password, iterations = PBKDF2_ITERATIONS) => {\n    const IV_BUFFER_SIZE = 12;\n    const SALT_BUFFER_SIZE = 16;\n    const iv = crypto.randomBytes(IV_BUFFER_SIZE);\n    const salt = crypto.randomBytes(SALT_BUFFER_SIZE);\n    const key = getKeyFromPassword(password, salt, iterations);\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\n    const firstBlock = cipher.update(plainText, 'utf8');\n    const encrypted = Buffer.concat([firstBlock, cipher.final()]);\n    const tag = cipher.getAuthTag();\n    return {\n        iterations,\n        cipherText: encrypted.toString('hex'),\n        iv: iv.toString('hex'),\n        salt: salt.toString('hex'),\n        tag: tag.toString('hex'),\n        version: ENCRYPTION_VERSION,\n    };\n};\nconst getTagBuffer = (tag) => {\n    const TAG_BUFFER_SIZE = 16;\n    const tagBuffer = buffer_1.hexToBuffer(tag, 'Tag');\n    if (tagBuffer.length !== TAG_BUFFER_SIZE) {\n        throw new Error('Tag must be 16 bytes.');\n    }\n    return tagBuffer;\n};\nconst decryptAES256GCMWithPassword = (encryptedPassphrase, password) => {\n    const { iterations = PBKDF2_ITERATIONS, cipherText, iv, salt, tag, } = encryptedPassphrase;\n    const tagBuffer = getTagBuffer(tag);\n    const key = getKeyFromPassword(password, buffer_1.hexToBuffer(salt, 'Salt'), iterations);\n    const decipher = crypto.createDecipheriv('aes-256-gcm', key, buffer_1.hexToBuffer(iv, 'IV'));\n    decipher.setAuthTag(tagBuffer);\n    const firstBlock = decipher.update(buffer_1.hexToBuffer(cipherText, 'Cipher text'));\n    const decrypted = Buffer.concat([firstBlock, decipher.final()]);\n    return decrypted.toString();\n};\nexports.encryptPassphraseWithPassword = encryptAES256GCMWithPassword;\nexports.decryptPassphraseWithPassword = decryptAES256GCMWithPassword;\n//# sourceMappingURL=encrypt.js.map"]},"metadata":{},"sourceType":"script"}