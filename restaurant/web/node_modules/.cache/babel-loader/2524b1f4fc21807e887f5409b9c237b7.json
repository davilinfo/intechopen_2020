{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nconst base_transaction_1 = require(\"./base_transaction\");\n\nconst constants_1 = require(\"./constants\");\n\nconst errors_1 = require(\"./errors\");\n\nconst utils_1 = require(\"./utils\");\n\nexports.secondSignatureAssetFormatSchema = {\n  type: 'object',\n  required: ['signature'],\n  properties: {\n    signature: {\n      type: 'object',\n      required: ['publicKey'],\n      properties: {\n        publicKey: {\n          type: 'string',\n          format: 'publicKey'\n        }\n      }\n    }\n  }\n};\n\nclass SecondSignatureTransaction extends base_transaction_1.BaseTransaction {\n  constructor(rawTransaction) {\n    super(rawTransaction);\n    const tx = typeof rawTransaction === 'object' && rawTransaction !== null ? rawTransaction : {};\n    this.asset = tx.asset || {\n      signature: {}\n    };\n  }\n\n  assetToBytes() {\n    const {\n      signature: {\n        publicKey\n      }\n    } = this.asset;\n    return lisk_cryptography_1.hexToBuffer(publicKey);\n  }\n\n  async prepare(store) {\n    await store.account.cache([{\n      address: this.senderId\n    }]);\n  }\n\n  verifyAgainstTransactions(transactions) {\n    return transactions.filter(tx => tx.type === this.type && tx.senderPublicKey === this.senderPublicKey).map(tx => new errors_1.TransactionError('Register second signature only allowed once per account.', tx.id, '.asset.signature'));\n  }\n\n  validateAsset() {\n    utils_1.validator.validate(exports.secondSignatureAssetFormatSchema, this.asset);\n    const errors = errors_1.convertToAssetError(this.id, utils_1.validator.errors);\n\n    if (!this.amount.eq(0)) {\n      errors.push(new errors_1.TransactionError('Amount must be zero for second signature registration transaction', this.id, '.amount', this.amount.toString(), '0'));\n    }\n\n    if (this.recipientId) {\n      errors.push(new errors_1.TransactionError('RecipientId is expected to be undefined.', this.id, '.recipientId', this.recipientId, ''));\n    }\n\n    if (this.recipientPublicKey) {\n      errors.push(new errors_1.TransactionError('RecipientPublicKey is expected to be undefined.', this.id, '.recipientPublicKey', this.recipientPublicKey, ''));\n    }\n\n    return errors;\n  }\n\n  applyAsset(store) {\n    const errors = [];\n    const sender = store.account.get(this.senderId);\n\n    if (sender.secondPublicKey) {\n      errors.push(new errors_1.TransactionError('Register second signature only allowed once per account.', this.id, '.secondPublicKey'));\n    }\n\n    const updatedSender = Object.assign({}, sender, {\n      secondPublicKey: this.asset.signature.publicKey,\n      secondSignature: 1\n    });\n    store.account.set(updatedSender.address, updatedSender);\n    return errors;\n  }\n\n  undoAsset(store) {\n    const sender = store.account.get(this.senderId);\n    const resetSender = Object.assign({}, sender, {\n      secondPublicKey: null,\n      secondSignature: 0\n    });\n    store.account.set(resetSender.address, resetSender);\n    return [];\n  }\n\n  sign(passphrase) {\n    this._signature = undefined;\n    this._signSignature = undefined;\n    this._signature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(this.getBytes()), passphrase);\n    this._id = utils_1.getId(this.getBytes());\n  }\n\n  assetFromSync(raw) {\n    if (!raw.s_publicKey) {\n      return undefined;\n    }\n\n    const signature = {\n      transactionId: raw.t_id,\n      publicKey: raw.s_publicKey\n    };\n    return {\n      signature\n    };\n  }\n\n}\n\nSecondSignatureTransaction.TYPE = 1;\nSecondSignatureTransaction.FEE = constants_1.SIGNATURE_FEE.toString();\nexports.SecondSignatureTransaction = SecondSignatureTransaction;","map":{"version":3,"sources":["../src/1_second_signature_transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\r\nconst base_transaction_1 = require(\"./base_transaction\");\r\nconst constants_1 = require(\"./constants\");\r\nconst errors_1 = require(\"./errors\");\r\nconst utils_1 = require(\"./utils\");\r\nexports.secondSignatureAssetFormatSchema = {\r\n    type: 'object',\r\n    required: ['signature'],\r\n    properties: {\r\n        signature: {\r\n            type: 'object',\r\n            required: ['publicKey'],\r\n            properties: {\r\n                publicKey: {\r\n                    type: 'string',\r\n                    format: 'publicKey',\r\n                },\r\n            },\r\n        },\r\n    },\r\n};\r\nclass SecondSignatureTransaction extends base_transaction_1.BaseTransaction {\r\n    constructor(rawTransaction) {\r\n        super(rawTransaction);\r\n        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null\r\n            ? rawTransaction\r\n            : {});\r\n        this.asset = (tx.asset || { signature: {} });\r\n    }\r\n    assetToBytes() {\r\n        const { signature: { publicKey }, } = this.asset;\r\n        return lisk_cryptography_1.hexToBuffer(publicKey);\r\n    }\r\n    async prepare(store) {\r\n        await store.account.cache([\r\n            {\r\n                address: this.senderId,\r\n            },\r\n        ]);\r\n    }\r\n    verifyAgainstTransactions(transactions) {\r\n        return transactions\r\n            .filter(tx => tx.type === this.type && tx.senderPublicKey === this.senderPublicKey)\r\n            .map(tx => new errors_1.TransactionError('Register second signature only allowed once per account.', tx.id, '.asset.signature'));\r\n    }\r\n    validateAsset() {\r\n        utils_1.validator.validate(exports.secondSignatureAssetFormatSchema, this.asset);\r\n        const errors = errors_1.convertToAssetError(this.id, utils_1.validator.errors);\r\n        if (!this.amount.eq(0)) {\r\n            errors.push(new errors_1.TransactionError('Amount must be zero for second signature registration transaction', this.id, '.amount', this.amount.toString(), '0'));\r\n        }\r\n        if (this.recipientId) {\r\n            errors.push(new errors_1.TransactionError('RecipientId is expected to be undefined.', this.id, '.recipientId', this.recipientId, ''));\r\n        }\r\n        if (this.recipientPublicKey) {\r\n            errors.push(new errors_1.TransactionError('RecipientPublicKey is expected to be undefined.', this.id, '.recipientPublicKey', this.recipientPublicKey, ''));\r\n        }\r\n        return errors;\r\n    }\r\n    applyAsset(store) {\r\n        const errors = [];\r\n        const sender = store.account.get(this.senderId);\r\n        if (sender.secondPublicKey) {\r\n            errors.push(new errors_1.TransactionError('Register second signature only allowed once per account.', this.id, '.secondPublicKey'));\r\n        }\r\n        const updatedSender = Object.assign({}, sender, { secondPublicKey: this.asset.signature.publicKey, secondSignature: 1 });\r\n        store.account.set(updatedSender.address, updatedSender);\r\n        return errors;\r\n    }\r\n    undoAsset(store) {\r\n        const sender = store.account.get(this.senderId);\r\n        const resetSender = Object.assign({}, sender, { secondPublicKey: null, secondSignature: 0 });\r\n        store.account.set(resetSender.address, resetSender);\r\n        return [];\r\n    }\r\n    sign(passphrase) {\r\n        this._signature = undefined;\r\n        this._signSignature = undefined;\r\n        this._signature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(this.getBytes()), passphrase);\r\n        this._id = utils_1.getId(this.getBytes());\r\n    }\r\n    assetFromSync(raw) {\r\n        if (!raw.s_publicKey) {\r\n            return undefined;\r\n        }\r\n        const signature = {\r\n            transactionId: raw.t_id,\r\n            publicKey: raw.s_publicKey,\r\n        };\r\n        return { signature };\r\n    }\r\n}\r\nSecondSignatureTransaction.TYPE = 1;\r\nSecondSignatureTransaction.FEE = constants_1.SIGNATURE_FEE.toString();\r\nexports.SecondSignatureTransaction = SecondSignatureTransaction;\r\n//# sourceMappingURL=1_second_signature_transaction.js.map"]},"metadata":{},"sourceType":"script"}