{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst varuint_bitcoin_1 = require(\"varuint-bitcoin\");\n\nconst buffer_1 = require(\"./buffer\");\n\nconst constants_1 = require(\"./constants\");\n\nconst hash_1 = require(\"./hash\");\n\nconst keys_1 = require(\"./keys\");\n\nconst nacl_1 = require(\"./nacl\");\n\nconst createHeader = text => `-----${text}-----`;\n\nconst signedMessageHeader = createHeader('BEGIN LISK SIGNED MESSAGE');\nconst messageHeader = createHeader('MESSAGE');\nconst publicKeyHeader = createHeader('PUBLIC KEY');\nconst secondPublicKeyHeader = createHeader('SECOND PUBLIC KEY');\nconst signatureHeader = createHeader('SIGNATURE');\nconst secondSignatureHeader = createHeader('SECOND SIGNATURE');\nconst signatureFooter = createHeader('END LISK SIGNED MESSAGE');\nconst SIGNED_MESSAGE_PREFIX_BYTES = Buffer.from(constants_1.SIGNED_MESSAGE_PREFIX, 'utf8');\nconst SIGNED_MESSAGE_PREFIX_LENGTH = varuint_bitcoin_1.encode(constants_1.SIGNED_MESSAGE_PREFIX.length);\n\nexports.digestMessage = message => {\n  const msgBytes = Buffer.from(message, 'utf8');\n  const msgLenBytes = varuint_bitcoin_1.encode(message.length);\n  const dataBytes = Buffer.concat([SIGNED_MESSAGE_PREFIX_LENGTH, SIGNED_MESSAGE_PREFIX_BYTES, msgLenBytes, msgBytes]);\n  return hash_1.hash(hash_1.hash(dataBytes));\n};\n\nexports.signMessageWithPassphrase = (message, passphrase) => {\n  const msgBytes = exports.digestMessage(message);\n  const {\n    privateKeyBytes,\n    publicKeyBytes\n  } = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\n  const signature = nacl_1.signDetached(msgBytes, privateKeyBytes);\n  return {\n    message,\n    publicKey: buffer_1.bufferToHex(publicKeyBytes),\n    signature: buffer_1.bufferToHex(signature)\n  };\n};\n\nexports.verifyMessageWithPublicKey = ({\n  message,\n  publicKey,\n  signature\n}) => {\n  const msgBytes = exports.digestMessage(message);\n  const signatureBytes = buffer_1.hexToBuffer(signature);\n  const publicKeyBytes = buffer_1.hexToBuffer(publicKey);\n\n  if (publicKeyBytes.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\n    throw new Error(`Invalid publicKey, expected ${nacl_1.NACL_SIGN_PUBLICKEY_LENGTH}-byte publicKey`);\n  }\n\n  if (signatureBytes.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\n    throw new Error(`Invalid signature length, expected ${nacl_1.NACL_SIGN_SIGNATURE_LENGTH}-byte signature`);\n  }\n\n  return nacl_1.verifyDetached(msgBytes, signatureBytes, publicKeyBytes);\n};\n\nexports.signMessageWithTwoPassphrases = (message, passphrase, secondPassphrase) => {\n  const msgBytes = exports.digestMessage(message);\n  const keypairBytes = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\n  const secondKeypairBytes = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(secondPassphrase);\n  const signature = nacl_1.signDetached(msgBytes, keypairBytes.privateKeyBytes);\n  const secondSignature = nacl_1.signDetached(msgBytes, secondKeypairBytes.privateKeyBytes);\n  return {\n    message,\n    publicKey: buffer_1.bufferToHex(keypairBytes.publicKeyBytes),\n    secondPublicKey: buffer_1.bufferToHex(secondKeypairBytes.publicKeyBytes),\n    signature: buffer_1.bufferToHex(signature),\n    secondSignature: buffer_1.bufferToHex(secondSignature)\n  };\n};\n\nexports.verifyMessageWithTwoPublicKeys = ({\n  message,\n  signature,\n  secondSignature,\n  publicKey,\n  secondPublicKey\n}) => {\n  const messageBytes = exports.digestMessage(message);\n  const signatureBytes = buffer_1.hexToBuffer(signature);\n  const secondSignatureBytes = buffer_1.hexToBuffer(secondSignature);\n  const publicKeyBytes = buffer_1.hexToBuffer(publicKey);\n  const secondPublicKeyBytes = buffer_1.hexToBuffer(secondPublicKey);\n\n  if (signatureBytes.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\n    throw new Error(`Invalid first signature length, expected ${nacl_1.NACL_SIGN_SIGNATURE_LENGTH}-byte signature`);\n  }\n\n  if (secondSignatureBytes.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\n    throw new Error(`Invalid second signature length, expected ${nacl_1.NACL_SIGN_SIGNATURE_LENGTH}-byte signature`);\n  }\n\n  if (publicKeyBytes.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\n    throw new Error(`Invalid first publicKey, expected ${nacl_1.NACL_SIGN_PUBLICKEY_LENGTH}-byte publicKey`);\n  }\n\n  if (secondPublicKeyBytes.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\n    throw new Error(`Invalid second publicKey, expected ${nacl_1.NACL_SIGN_PUBLICKEY_LENGTH}-byte publicKey`);\n  }\n\n  const verifyFirstSignature = () => nacl_1.verifyDetached(messageBytes, signatureBytes, publicKeyBytes);\n\n  const verifySecondSignature = () => nacl_1.verifyDetached(messageBytes, secondSignatureBytes, secondPublicKeyBytes);\n\n  return verifyFirstSignature() && verifySecondSignature();\n};\n\nexports.printSignedMessage = ({\n  message,\n  signature,\n  publicKey,\n  secondSignature,\n  secondPublicKey\n}) => [signedMessageHeader, messageHeader, message, publicKeyHeader, publicKey, secondPublicKey ? secondPublicKeyHeader : undefined, secondPublicKey, signatureHeader, signature, secondSignature ? secondSignatureHeader : undefined, secondSignature, signatureFooter].filter(Boolean).join('\\n');\n\nexports.signAndPrintMessage = (message, passphrase, secondPassphrase) => {\n  const signedMessage = secondPassphrase ? exports.signMessageWithTwoPassphrases(message, passphrase, secondPassphrase) : exports.signMessageWithPassphrase(message, passphrase);\n  return exports.printSignedMessage(signedMessage);\n};\n\nexports.signDataWithPrivateKey = (data, privateKey) => {\n  const signature = nacl_1.signDetached(data, privateKey);\n  return buffer_1.bufferToHex(signature);\n};\n\nexports.signDataWithPassphrase = (data, passphrase) => {\n  const {\n    privateKeyBytes\n  } = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\n  return exports.signDataWithPrivateKey(data, privateKeyBytes);\n};\n\nexports.signData = exports.signDataWithPassphrase;\n\nexports.verifyData = (data, signature, publicKey) => nacl_1.verifyDetached(data, buffer_1.hexToBuffer(signature), buffer_1.hexToBuffer(publicKey));","map":{"version":3,"sources":["../src/sign.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst varuint_bitcoin_1 = require(\"varuint-bitcoin\");\nconst buffer_1 = require(\"./buffer\");\nconst constants_1 = require(\"./constants\");\nconst hash_1 = require(\"./hash\");\nconst keys_1 = require(\"./keys\");\nconst nacl_1 = require(\"./nacl\");\nconst createHeader = (text) => `-----${text}-----`;\nconst signedMessageHeader = createHeader('BEGIN LISK SIGNED MESSAGE');\nconst messageHeader = createHeader('MESSAGE');\nconst publicKeyHeader = createHeader('PUBLIC KEY');\nconst secondPublicKeyHeader = createHeader('SECOND PUBLIC KEY');\nconst signatureHeader = createHeader('SIGNATURE');\nconst secondSignatureHeader = createHeader('SECOND SIGNATURE');\nconst signatureFooter = createHeader('END LISK SIGNED MESSAGE');\nconst SIGNED_MESSAGE_PREFIX_BYTES = Buffer.from(constants_1.SIGNED_MESSAGE_PREFIX, 'utf8');\nconst SIGNED_MESSAGE_PREFIX_LENGTH = varuint_bitcoin_1.encode(constants_1.SIGNED_MESSAGE_PREFIX.length);\nexports.digestMessage = (message) => {\n    const msgBytes = Buffer.from(message, 'utf8');\n    const msgLenBytes = varuint_bitcoin_1.encode(message.length);\n    const dataBytes = Buffer.concat([\n        SIGNED_MESSAGE_PREFIX_LENGTH,\n        SIGNED_MESSAGE_PREFIX_BYTES,\n        msgLenBytes,\n        msgBytes,\n    ]);\n    return hash_1.hash(hash_1.hash(dataBytes));\n};\nexports.signMessageWithPassphrase = (message, passphrase) => {\n    const msgBytes = exports.digestMessage(message);\n    const { privateKeyBytes, publicKeyBytes, } = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\n    const signature = nacl_1.signDetached(msgBytes, privateKeyBytes);\n    return {\n        message,\n        publicKey: buffer_1.bufferToHex(publicKeyBytes),\n        signature: buffer_1.bufferToHex(signature),\n    };\n};\nexports.verifyMessageWithPublicKey = ({ message, publicKey, signature, }) => {\n    const msgBytes = exports.digestMessage(message);\n    const signatureBytes = buffer_1.hexToBuffer(signature);\n    const publicKeyBytes = buffer_1.hexToBuffer(publicKey);\n    if (publicKeyBytes.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\n        throw new Error(`Invalid publicKey, expected ${nacl_1.NACL_SIGN_PUBLICKEY_LENGTH}-byte publicKey`);\n    }\n    if (signatureBytes.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\n        throw new Error(`Invalid signature length, expected ${nacl_1.NACL_SIGN_SIGNATURE_LENGTH}-byte signature`);\n    }\n    return nacl_1.verifyDetached(msgBytes, signatureBytes, publicKeyBytes);\n};\nexports.signMessageWithTwoPassphrases = (message, passphrase, secondPassphrase) => {\n    const msgBytes = exports.digestMessage(message);\n    const keypairBytes = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\n    const secondKeypairBytes = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(secondPassphrase);\n    const signature = nacl_1.signDetached(msgBytes, keypairBytes.privateKeyBytes);\n    const secondSignature = nacl_1.signDetached(msgBytes, secondKeypairBytes.privateKeyBytes);\n    return {\n        message,\n        publicKey: buffer_1.bufferToHex(keypairBytes.publicKeyBytes),\n        secondPublicKey: buffer_1.bufferToHex(secondKeypairBytes.publicKeyBytes),\n        signature: buffer_1.bufferToHex(signature),\n        secondSignature: buffer_1.bufferToHex(secondSignature),\n    };\n};\nexports.verifyMessageWithTwoPublicKeys = ({ message, signature, secondSignature, publicKey, secondPublicKey, }) => {\n    const messageBytes = exports.digestMessage(message);\n    const signatureBytes = buffer_1.hexToBuffer(signature);\n    const secondSignatureBytes = buffer_1.hexToBuffer(secondSignature);\n    const publicKeyBytes = buffer_1.hexToBuffer(publicKey);\n    const secondPublicKeyBytes = buffer_1.hexToBuffer(secondPublicKey);\n    if (signatureBytes.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\n        throw new Error(`Invalid first signature length, expected ${nacl_1.NACL_SIGN_SIGNATURE_LENGTH}-byte signature`);\n    }\n    if (secondSignatureBytes.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\n        throw new Error(`Invalid second signature length, expected ${nacl_1.NACL_SIGN_SIGNATURE_LENGTH}-byte signature`);\n    }\n    if (publicKeyBytes.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\n        throw new Error(`Invalid first publicKey, expected ${nacl_1.NACL_SIGN_PUBLICKEY_LENGTH}-byte publicKey`);\n    }\n    if (secondPublicKeyBytes.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\n        throw new Error(`Invalid second publicKey, expected ${nacl_1.NACL_SIGN_PUBLICKEY_LENGTH}-byte publicKey`);\n    }\n    const verifyFirstSignature = () => nacl_1.verifyDetached(messageBytes, signatureBytes, publicKeyBytes);\n    const verifySecondSignature = () => nacl_1.verifyDetached(messageBytes, secondSignatureBytes, secondPublicKeyBytes);\n    return verifyFirstSignature() && verifySecondSignature();\n};\nexports.printSignedMessage = ({ message, signature, publicKey, secondSignature, secondPublicKey, }) => [\n    signedMessageHeader,\n    messageHeader,\n    message,\n    publicKeyHeader,\n    publicKey,\n    secondPublicKey ? secondPublicKeyHeader : undefined,\n    secondPublicKey,\n    signatureHeader,\n    signature,\n    secondSignature ? secondSignatureHeader : undefined,\n    secondSignature,\n    signatureFooter,\n]\n    .filter(Boolean)\n    .join('\\n');\nexports.signAndPrintMessage = (message, passphrase, secondPassphrase) => {\n    const signedMessage = secondPassphrase\n        ? exports.signMessageWithTwoPassphrases(message, passphrase, secondPassphrase)\n        : exports.signMessageWithPassphrase(message, passphrase);\n    return exports.printSignedMessage(signedMessage);\n};\nexports.signDataWithPrivateKey = (data, privateKey) => {\n    const signature = nacl_1.signDetached(data, privateKey);\n    return buffer_1.bufferToHex(signature);\n};\nexports.signDataWithPassphrase = (data, passphrase) => {\n    const { privateKeyBytes } = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\n    return exports.signDataWithPrivateKey(data, privateKeyBytes);\n};\nexports.signData = exports.signDataWithPassphrase;\nexports.verifyData = (data, signature, publicKey) => nacl_1.verifyDetached(data, buffer_1.hexToBuffer(signature), buffer_1.hexToBuffer(publicKey));\n//# sourceMappingURL=sign.js.map"]},"metadata":{},"sourceType":"script"}