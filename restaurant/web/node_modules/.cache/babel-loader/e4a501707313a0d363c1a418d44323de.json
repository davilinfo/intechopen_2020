{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar reverse = require(\"buffer-reverse\");\n\nvar ed2curve = require(\"ed2curve\");\n\nvar querystring = require(\"querystring\");\n\nvar buffer_1 = require(\"./buffer\");\n\nvar hash_1 = require(\"./hash\");\n\nexports.getFirstEightBytesReversed = function (input) {\n  var BUFFER_SIZE = 8;\n\n  if (typeof input === 'string') {\n    return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\n  }\n\n  return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\n};\n\nexports.toAddress = function (buffer) {\n  var BUFFER_SIZE = 8;\n\n  if (!Buffer.from(buffer).slice(0, BUFFER_SIZE).equals(buffer)) {\n    throw new Error('The buffer for Lisk addresses must not have more than 8 bytes');\n  }\n\n  return \"\".concat(buffer_1.bufferToIntAsString(buffer), \"L\");\n};\n\nexports.getAddressFromPublicKey = function (publicKey) {\n  var publicKeyHash = hash_1.hash(publicKey, 'hex');\n  var publicKeyTransform = exports.getFirstEightBytesReversed(publicKeyHash);\n  var address = exports.toAddress(publicKeyTransform);\n  return address;\n};\n\nexports.convertPublicKeyEd2Curve = ed2curve.convertPublicKey;\nexports.convertPrivateKeyEd2Curve = ed2curve.convertSecretKey;\n\nexports.stringifyEncryptedPassphrase = function (encryptedPassphrase) {\n  if (typeof encryptedPassphrase !== 'object' || encryptedPassphrase === null) {\n    throw new Error('Encrypted passphrase to stringify must be an object.');\n  }\n\n  var objectToStringify = encryptedPassphrase.iterations ? encryptedPassphrase : {\n    salt: encryptedPassphrase.salt,\n    cipherText: encryptedPassphrase.cipherText,\n    iv: encryptedPassphrase.iv,\n    tag: encryptedPassphrase.tag,\n    version: encryptedPassphrase.version\n  };\n  return querystring.stringify(objectToStringify);\n};\n\nvar parseIterations = function parseIterations(iterationsString) {\n  var iterations = iterationsString === undefined ? undefined : parseInt(iterationsString, 10);\n\n  if (typeof iterations !== 'undefined' && Number.isNaN(iterations)) {\n    throw new Error('Could not parse iterations.');\n  }\n\n  return iterations;\n};\n\nexports.parseEncryptedPassphrase = function (encryptedPassphrase) {\n  if (typeof encryptedPassphrase !== 'string') {\n    throw new Error('Encrypted passphrase to parse must be a string.');\n  }\n\n  var keyValuePairs = querystring.parse(encryptedPassphrase);\n  var iterations = keyValuePairs.iterations,\n      salt = keyValuePairs.salt,\n      cipherText = keyValuePairs.cipherText,\n      iv = keyValuePairs.iv,\n      tag = keyValuePairs.tag,\n      version = keyValuePairs.version;\n\n  if (typeof iterations !== 'string' && typeof iterations !== 'undefined' || typeof salt !== 'string' || typeof cipherText !== 'string' || typeof iv !== 'string' || typeof tag !== 'string' || typeof version !== 'string') {\n    throw new Error('Encrypted passphrase to parse must have only one value per key.');\n  }\n\n  return {\n    iterations: parseIterations(iterations),\n    salt: salt,\n    cipherText: cipherText,\n    iv: iv,\n    tag: tag,\n    version: version\n  };\n};","map":{"version":3,"sources":["../src/convert.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst reverse = require(\"buffer-reverse\");\r\nconst ed2curve = require(\"ed2curve\");\r\nconst querystring = require(\"querystring\");\r\nconst buffer_1 = require(\"./buffer\");\r\nconst hash_1 = require(\"./hash\");\r\nexports.getFirstEightBytesReversed = (input) => {\r\n    const BUFFER_SIZE = 8;\r\n    if (typeof input === 'string') {\r\n        return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\r\n    }\r\n    return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\r\n};\r\nexports.toAddress = (buffer) => {\r\n    const BUFFER_SIZE = 8;\r\n    if (!Buffer.from(buffer)\r\n        .slice(0, BUFFER_SIZE)\r\n        .equals(buffer)) {\r\n        throw new Error('The buffer for Lisk addresses must not have more than 8 bytes');\r\n    }\r\n    return `${buffer_1.bufferToIntAsString(buffer)}L`;\r\n};\r\nexports.getAddressFromPublicKey = (publicKey) => {\r\n    const publicKeyHash = hash_1.hash(publicKey, 'hex');\r\n    const publicKeyTransform = exports.getFirstEightBytesReversed(publicKeyHash);\r\n    const address = exports.toAddress(publicKeyTransform);\r\n    return address;\r\n};\r\nexports.convertPublicKeyEd2Curve = ed2curve.convertPublicKey;\r\nexports.convertPrivateKeyEd2Curve = ed2curve.convertSecretKey;\r\nexports.stringifyEncryptedPassphrase = (encryptedPassphrase) => {\r\n    if (typeof encryptedPassphrase !== 'object' || encryptedPassphrase === null) {\r\n        throw new Error('Encrypted passphrase to stringify must be an object.');\r\n    }\r\n    const objectToStringify = encryptedPassphrase.iterations\r\n        ? encryptedPassphrase\r\n        : {\r\n            salt: encryptedPassphrase.salt,\r\n            cipherText: encryptedPassphrase.cipherText,\r\n            iv: encryptedPassphrase.iv,\r\n            tag: encryptedPassphrase.tag,\r\n            version: encryptedPassphrase.version,\r\n        };\r\n    return querystring.stringify(objectToStringify);\r\n};\r\nconst parseIterations = (iterationsString) => {\r\n    const iterations = iterationsString === undefined ? undefined : parseInt(iterationsString, 10);\r\n    if (typeof iterations !== 'undefined' && Number.isNaN(iterations)) {\r\n        throw new Error('Could not parse iterations.');\r\n    }\r\n    return iterations;\r\n};\r\nexports.parseEncryptedPassphrase = (encryptedPassphrase) => {\r\n    if (typeof encryptedPassphrase !== 'string') {\r\n        throw new Error('Encrypted passphrase to parse must be a string.');\r\n    }\r\n    const keyValuePairs = querystring.parse(encryptedPassphrase);\r\n    const { iterations, salt, cipherText, iv, tag, version } = keyValuePairs;\r\n    if ((typeof iterations !== 'string' && typeof iterations !== 'undefined') ||\r\n        typeof salt !== 'string' ||\r\n        typeof cipherText !== 'string' ||\r\n        typeof iv !== 'string' ||\r\n        typeof tag !== 'string' ||\r\n        typeof version !== 'string') {\r\n        throw new Error('Encrypted passphrase to parse must have only one value per key.');\r\n    }\r\n    return {\r\n        iterations: parseIterations(iterations),\r\n        salt,\r\n        cipherText,\r\n        iv,\r\n        tag,\r\n        version,\r\n    };\r\n};\r\n//# sourceMappingURL=convert.js.map"]},"metadata":{},"sourceType":"script"}