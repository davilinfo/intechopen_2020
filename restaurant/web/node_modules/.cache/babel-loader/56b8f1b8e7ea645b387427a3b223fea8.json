{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:\\\\PoC\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar cryptography = require(\"@liskhq/lisk-cryptography\");\n\nvar errors_1 = require(\"../errors\");\n\nvar get_transaction_hash_1 = require(\"./get_transaction_hash\");\n\nexports.multiSignTransaction = function (transaction, passphrase) {\n  var signature = transaction.signature,\n      signSignature = transaction.signSignature,\n      transactionToSign = __rest(transaction, [\"signature\", \"signSignature\"]);\n\n  var transactionHash = get_transaction_hash_1.getTransactionHash(transactionToSign);\n  return cryptography.signData(transactionHash, passphrase);\n};\n\nexports.validateSignature = function (publicKey, signature, transactionBytes, id) {\n  var transactionHash = cryptography.hash(transactionBytes);\n  var valid = cryptography.verifyData(transactionHash, signature, publicKey);\n  return {\n    valid: valid,\n    error: !valid ? new errors_1.TransactionError(\"Failed to validate signature \".concat(signature), id, '.signature') : undefined\n  };\n};\n\nexports.signaturesAreUnique = function (signatures) {\n  var uniqueSignatures = _toConsumableArray(new Set(signatures));\n\n  if (uniqueSignatures.length !== signatures.length) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.checkPublicKeySignatureUniqueness = function (publicKeys, signatures, transactionBytes, id) {\n  var checkedPublicKeys = new Set();\n  var validSignatures = new Set();\n  publicKeys.forEach(function (publicKey) {\n    signatures.forEach(function (signature) {\n      if (checkedPublicKeys.has(publicKey) || validSignatures.has(signature)) {\n        return;\n      }\n\n      var _exports$validateSign = exports.validateSignature(publicKey, signature, transactionBytes, id),\n          signatureValid = _exports$validateSign.valid;\n\n      if (signatureValid) {\n        checkedPublicKeys.add(publicKey);\n        validSignatures.add(signature);\n      }\n    });\n  });\n  return validSignatures;\n};\n\nexports.validateMultisignatures = function (publicKeys, signatures, minimumValidations, transactionBytes, id) {\n  if (!exports.signaturesAreUnique(signatures)) {\n    return {\n      valid: false,\n      errors: [new errors_1.TransactionError('Encountered duplicate signature in transaction', id, '.signatures')]\n    };\n  }\n\n  var validSignatures = exports.checkPublicKeySignatureUniqueness(publicKeys, signatures, transactionBytes, id);\n  var invalidTransactionSignatures = signatures.filter(function (signature) {\n    return !validSignatures.has(signature);\n  });\n\n  if (signatures.length < minimumValidations) {\n    return {\n      valid: false,\n      errors: [new errors_1.TransactionPendingError(\"Missing signatures\", id, '.signatures')]\n    };\n  }\n\n  return {\n    valid: validSignatures.size >= minimumValidations && invalidTransactionSignatures.length === 0,\n    errors: invalidTransactionSignatures.length > 0 ? invalidTransactionSignatures.map(function (signature) {\n      return new errors_1.TransactionError(\"Failed to validate signature \".concat(signature), id, '.signatures');\n    }) : []\n  };\n};\n\nexports.signTransaction = function (transaction, passphrase) {\n  var transactionHash = get_transaction_hash_1.getTransactionHash(transaction);\n  return cryptography.signData(transactionHash, passphrase);\n};\n\nexports.secondSignTransaction = function (transaction, secondPassphrase) {\n  return Object.assign({}, transaction, {\n    signSignature: exports.signTransaction(transaction, secondPassphrase)\n  });\n};\n\nexports.verifyTransaction = function (transaction, secondPublicKey) {\n  if (!transaction.signature) {\n    throw new Error('Cannot verify transaction without signature.');\n  }\n\n  if (!!transaction.signSignature && !secondPublicKey) {\n    throw new Error('Cannot verify signSignature without secondPublicKey.');\n  }\n\n  var signature = transaction.signature,\n      signSignature = transaction.signSignature,\n      transactionWithoutSignatures = __rest(transaction, [\"signature\", \"signSignature\"]);\n\n  var transactionWithoutSignature = !!transaction.signSignature ? Object.assign({}, transactionWithoutSignatures, {\n    signature: signature\n  }) : transactionWithoutSignatures;\n  var transactionHash = get_transaction_hash_1.getTransactionHash(transactionWithoutSignature);\n  var publicKey = !!transaction.signSignature && secondPublicKey ? secondPublicKey : transaction.senderPublicKey;\n  var lastSignature = transaction.signSignature ? transaction.signSignature : transaction.signature;\n  var verified = cryptography.verifyData(transactionHash, lastSignature, publicKey);\n  return !!transaction.signSignature ? verified && exports.verifyTransaction(transactionWithoutSignature) : verified;\n};","map":{"version":3,"sources":["../../src/utils/sign_and_validate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cryptography = require(\"@liskhq/lisk-cryptography\");\r\nconst errors_1 = require(\"../errors\");\r\nconst get_transaction_hash_1 = require(\"./get_transaction_hash\");\r\nexports.multiSignTransaction = (transaction, passphrase) => {\r\n    const { signature, signSignature } = transaction, transactionToSign = __rest(transaction, [\"signature\", \"signSignature\"]);\r\n    const transactionHash = get_transaction_hash_1.getTransactionHash(transactionToSign);\r\n    return cryptography.signData(transactionHash, passphrase);\r\n};\r\nexports.validateSignature = (publicKey, signature, transactionBytes, id) => {\r\n    const transactionHash = cryptography.hash(transactionBytes);\r\n    const valid = cryptography.verifyData(transactionHash, signature, publicKey);\r\n    return {\r\n        valid,\r\n        error: !valid\r\n            ? new errors_1.TransactionError(`Failed to validate signature ${signature}`, id, '.signature')\r\n            : undefined,\r\n    };\r\n};\r\nexports.signaturesAreUnique = (signatures) => {\r\n    const uniqueSignatures = [...new Set(signatures)];\r\n    if (uniqueSignatures.length !== signatures.length) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\nexports.checkPublicKeySignatureUniqueness = (publicKeys, signatures, transactionBytes, id) => {\r\n    const checkedPublicKeys = new Set();\r\n    const validSignatures = new Set();\r\n    publicKeys.forEach(publicKey => {\r\n        signatures.forEach((signature) => {\r\n            if (checkedPublicKeys.has(publicKey) || validSignatures.has(signature)) {\r\n                return;\r\n            }\r\n            const { valid: signatureValid } = exports.validateSignature(publicKey, signature, transactionBytes, id);\r\n            if (signatureValid) {\r\n                checkedPublicKeys.add(publicKey);\r\n                validSignatures.add(signature);\r\n            }\r\n        });\r\n    });\r\n    return validSignatures;\r\n};\r\nexports.validateMultisignatures = (publicKeys, signatures, minimumValidations, transactionBytes, id) => {\r\n    if (!exports.signaturesAreUnique(signatures)) {\r\n        return {\r\n            valid: false,\r\n            errors: [\r\n                new errors_1.TransactionError('Encountered duplicate signature in transaction', id, '.signatures'),\r\n            ],\r\n        };\r\n    }\r\n    const validSignatures = exports.checkPublicKeySignatureUniqueness(publicKeys, signatures, transactionBytes, id);\r\n    const invalidTransactionSignatures = signatures.filter(signature => !validSignatures.has(signature));\r\n    if (signatures.length < minimumValidations) {\r\n        return {\r\n            valid: false,\r\n            errors: [\r\n                new errors_1.TransactionPendingError(`Missing signatures`, id, '.signatures'),\r\n            ],\r\n        };\r\n    }\r\n    return {\r\n        valid: validSignatures.size >= minimumValidations &&\r\n            invalidTransactionSignatures.length === 0,\r\n        errors: invalidTransactionSignatures.length > 0\r\n            ? invalidTransactionSignatures.map(signature => new errors_1.TransactionError(`Failed to validate signature ${signature}`, id, '.signatures'))\r\n            : [],\r\n    };\r\n};\r\nexports.signTransaction = (transaction, passphrase) => {\r\n    const transactionHash = get_transaction_hash_1.getTransactionHash(transaction);\r\n    return cryptography.signData(transactionHash, passphrase);\r\n};\r\nexports.secondSignTransaction = (transaction, secondPassphrase) => (Object.assign({}, transaction, { signSignature: exports.signTransaction(transaction, secondPassphrase) }));\r\nexports.verifyTransaction = (transaction, secondPublicKey) => {\r\n    if (!transaction.signature) {\r\n        throw new Error('Cannot verify transaction without signature.');\r\n    }\r\n    if (!!transaction.signSignature && !secondPublicKey) {\r\n        throw new Error('Cannot verify signSignature without secondPublicKey.');\r\n    }\r\n    const { signature, signSignature } = transaction, transactionWithoutSignatures = __rest(transaction, [\"signature\", \"signSignature\"]);\r\n    const transactionWithoutSignature = !!transaction.signSignature\r\n        ? Object.assign({}, transactionWithoutSignatures, { signature }) : transactionWithoutSignatures;\r\n    const transactionHash = get_transaction_hash_1.getTransactionHash(transactionWithoutSignature);\r\n    const publicKey = !!transaction.signSignature && secondPublicKey\r\n        ? secondPublicKey\r\n        : transaction.senderPublicKey;\r\n    const lastSignature = transaction.signSignature\r\n        ? transaction.signSignature\r\n        : transaction.signature;\r\n    const verified = cryptography.verifyData(transactionHash, lastSignature, publicKey);\r\n    return !!transaction.signSignature\r\n        ? verified && exports.verifyTransaction(transactionWithoutSignature)\r\n        : verified;\r\n};\r\n//# sourceMappingURL=sign_and_validate.js.map"]},"metadata":{},"sourceType":"script"}