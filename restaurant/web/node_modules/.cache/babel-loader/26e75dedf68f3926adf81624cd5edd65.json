{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto = require(\"crypto\");\n\nconst buffer_1 = require(\"./buffer\");\n\nconst convert_1 = require(\"./convert\");\n\nconst keys_1 = require(\"./keys\");\n\nconst nacl_1 = require(\"./nacl\");\n\nconst PBKDF2_ITERATIONS = 1e6;\nconst PBKDF2_KEYLEN = 32;\nconst PBKDF2_HASH_FUNCTION = 'sha256';\nconst ENCRYPTION_VERSION = '1';\n\nexports.encryptMessageWithPassphrase = (message, passphrase, recipientPublicKey) => {\n  const {\n    privateKeyBytes: senderPrivateKeyBytes\n  } = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\n  const convertedPrivateKey = Buffer.from(convert_1.convertPrivateKeyEd2Curve(senderPrivateKeyBytes));\n  const recipientPublicKeyBytes = buffer_1.hexToBuffer(recipientPublicKey);\n  const messageInBytes = Buffer.from(message, 'utf8');\n  const nonceSize = 24;\n  const nonce = nacl_1.getRandomBytes(nonceSize);\n  const publicKeyUint8Array = convert_1.convertPublicKeyEd2Curve(recipientPublicKeyBytes);\n\n  if (publicKeyUint8Array === null) {\n    throw new Error('given public key is not a valid Ed25519 public key');\n  }\n\n  const convertedPublicKey = Buffer.from(publicKeyUint8Array);\n  const cipherBytes = nacl_1.box(messageInBytes, nonce, convertedPublicKey, convertedPrivateKey);\n  const nonceHex = buffer_1.bufferToHex(nonce);\n  const encryptedMessage = buffer_1.bufferToHex(cipherBytes);\n  return {\n    nonce: nonceHex,\n    encryptedMessage\n  };\n};\n\nexports.decryptMessageWithPassphrase = (cipherHex, nonce, passphrase, senderPublicKey) => {\n  const {\n    privateKeyBytes: recipientPrivateKeyBytes\n  } = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\n  const convertedPrivateKey = Buffer.from(convert_1.convertPrivateKeyEd2Curve(recipientPrivateKeyBytes));\n  const senderPublicKeyBytes = buffer_1.hexToBuffer(senderPublicKey);\n  const cipherBytes = buffer_1.hexToBuffer(cipherHex);\n  const nonceBytes = buffer_1.hexToBuffer(nonce);\n  const publicKeyUint8Array = convert_1.convertPublicKeyEd2Curve(senderPublicKeyBytes);\n\n  if (publicKeyUint8Array === null) {\n    throw new Error('given public key is not a valid Ed25519 public key');\n  }\n\n  const convertedPublicKey = Buffer.from(publicKeyUint8Array);\n\n  try {\n    const decoded = nacl_1.openBox(cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey);\n    return Buffer.from(decoded).toString();\n  } catch (error) {\n    if (error.message.match(/bad nonce size|nonce must be a buffer of size crypto_box_NONCEBYTES/)) {\n      throw new Error('Expected nonce to be 24 bytes.');\n    }\n\n    throw new Error('Something went wrong during decryption. Is this the full encrypted message?');\n  }\n};\n\nconst getKeyFromPassword = (password, salt, iterations) => crypto.pbkdf2Sync(password, salt, iterations, PBKDF2_KEYLEN, PBKDF2_HASH_FUNCTION);\n\nconst encryptAES256GCMWithPassword = (plainText, password, iterations = PBKDF2_ITERATIONS) => {\n  const IV_BUFFER_SIZE = 12;\n  const SALT_BUFFER_SIZE = 16;\n  const iv = crypto.randomBytes(IV_BUFFER_SIZE);\n  const salt = crypto.randomBytes(SALT_BUFFER_SIZE);\n  const key = getKeyFromPassword(password, salt, iterations);\n  const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\n  const firstBlock = cipher.update(plainText, 'utf8');\n  const encrypted = Buffer.concat([firstBlock, cipher.final()]);\n  const tag = cipher.getAuthTag();\n  return {\n    iterations,\n    cipherText: encrypted.toString('hex'),\n    iv: iv.toString('hex'),\n    salt: salt.toString('hex'),\n    tag: tag.toString('hex'),\n    version: ENCRYPTION_VERSION\n  };\n};\n\nconst getTagBuffer = tag => {\n  const TAG_BUFFER_SIZE = 16;\n  const tagBuffer = buffer_1.hexToBuffer(tag, 'Tag');\n\n  if (tagBuffer.length !== TAG_BUFFER_SIZE) {\n    throw new Error('Tag must be 16 bytes.');\n  }\n\n  return tagBuffer;\n};\n\nconst decryptAES256GCMWithPassword = (encryptedPassphrase, password) => {\n  const {\n    iterations = PBKDF2_ITERATIONS,\n    cipherText,\n    iv,\n    salt,\n    tag\n  } = encryptedPassphrase;\n  const tagBuffer = getTagBuffer(tag);\n  const key = getKeyFromPassword(password, buffer_1.hexToBuffer(salt, 'Salt'), iterations);\n  const decipher = crypto.createDecipheriv('aes-256-gcm', key, buffer_1.hexToBuffer(iv, 'IV'));\n  decipher.setAuthTag(tagBuffer);\n  const firstBlock = decipher.update(buffer_1.hexToBuffer(cipherText, 'Cipher text'));\n  const decrypted = Buffer.concat([firstBlock, decipher.final()]);\n  return decrypted.toString();\n};\n\nexports.encryptPassphraseWithPassword = encryptAES256GCMWithPassword;\nexports.decryptPassphraseWithPassword = decryptAES256GCMWithPassword;","map":{"version":3,"sources":["../src/encrypt.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst crypto = require(\"crypto\");\r\nconst buffer_1 = require(\"./buffer\");\r\nconst convert_1 = require(\"./convert\");\r\nconst keys_1 = require(\"./keys\");\r\nconst nacl_1 = require(\"./nacl\");\r\nconst PBKDF2_ITERATIONS = 1e6;\r\nconst PBKDF2_KEYLEN = 32;\r\nconst PBKDF2_HASH_FUNCTION = 'sha256';\r\nconst ENCRYPTION_VERSION = '1';\r\nexports.encryptMessageWithPassphrase = (message, passphrase, recipientPublicKey) => {\r\n    const { privateKeyBytes: senderPrivateKeyBytes, } = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\r\n    const convertedPrivateKey = Buffer.from(convert_1.convertPrivateKeyEd2Curve(senderPrivateKeyBytes));\r\n    const recipientPublicKeyBytes = buffer_1.hexToBuffer(recipientPublicKey);\r\n    const messageInBytes = Buffer.from(message, 'utf8');\r\n    const nonceSize = 24;\r\n    const nonce = nacl_1.getRandomBytes(nonceSize);\r\n    const publicKeyUint8Array = convert_1.convertPublicKeyEd2Curve(recipientPublicKeyBytes);\r\n    if (publicKeyUint8Array === null) {\r\n        throw new Error('given public key is not a valid Ed25519 public key');\r\n    }\r\n    const convertedPublicKey = Buffer.from(publicKeyUint8Array);\r\n    const cipherBytes = nacl_1.box(messageInBytes, nonce, convertedPublicKey, convertedPrivateKey);\r\n    const nonceHex = buffer_1.bufferToHex(nonce);\r\n    const encryptedMessage = buffer_1.bufferToHex(cipherBytes);\r\n    return {\r\n        nonce: nonceHex,\r\n        encryptedMessage,\r\n    };\r\n};\r\nexports.decryptMessageWithPassphrase = (cipherHex, nonce, passphrase, senderPublicKey) => {\r\n    const { privateKeyBytes: recipientPrivateKeyBytes, } = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\r\n    const convertedPrivateKey = Buffer.from(convert_1.convertPrivateKeyEd2Curve(recipientPrivateKeyBytes));\r\n    const senderPublicKeyBytes = buffer_1.hexToBuffer(senderPublicKey);\r\n    const cipherBytes = buffer_1.hexToBuffer(cipherHex);\r\n    const nonceBytes = buffer_1.hexToBuffer(nonce);\r\n    const publicKeyUint8Array = convert_1.convertPublicKeyEd2Curve(senderPublicKeyBytes);\r\n    if (publicKeyUint8Array === null) {\r\n        throw new Error('given public key is not a valid Ed25519 public key');\r\n    }\r\n    const convertedPublicKey = Buffer.from(publicKeyUint8Array);\r\n    try {\r\n        const decoded = nacl_1.openBox(cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey);\r\n        return Buffer.from(decoded).toString();\r\n    }\r\n    catch (error) {\r\n        if (error.message.match(/bad nonce size|nonce must be a buffer of size crypto_box_NONCEBYTES/)) {\r\n            throw new Error('Expected nonce to be 24 bytes.');\r\n        }\r\n        throw new Error('Something went wrong during decryption. Is this the full encrypted message?');\r\n    }\r\n};\r\nconst getKeyFromPassword = (password, salt, iterations) => crypto.pbkdf2Sync(password, salt, iterations, PBKDF2_KEYLEN, PBKDF2_HASH_FUNCTION);\r\nconst encryptAES256GCMWithPassword = (plainText, password, iterations = PBKDF2_ITERATIONS) => {\r\n    const IV_BUFFER_SIZE = 12;\r\n    const SALT_BUFFER_SIZE = 16;\r\n    const iv = crypto.randomBytes(IV_BUFFER_SIZE);\r\n    const salt = crypto.randomBytes(SALT_BUFFER_SIZE);\r\n    const key = getKeyFromPassword(password, salt, iterations);\r\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\r\n    const firstBlock = cipher.update(plainText, 'utf8');\r\n    const encrypted = Buffer.concat([firstBlock, cipher.final()]);\r\n    const tag = cipher.getAuthTag();\r\n    return {\r\n        iterations,\r\n        cipherText: encrypted.toString('hex'),\r\n        iv: iv.toString('hex'),\r\n        salt: salt.toString('hex'),\r\n        tag: tag.toString('hex'),\r\n        version: ENCRYPTION_VERSION,\r\n    };\r\n};\r\nconst getTagBuffer = (tag) => {\r\n    const TAG_BUFFER_SIZE = 16;\r\n    const tagBuffer = buffer_1.hexToBuffer(tag, 'Tag');\r\n    if (tagBuffer.length !== TAG_BUFFER_SIZE) {\r\n        throw new Error('Tag must be 16 bytes.');\r\n    }\r\n    return tagBuffer;\r\n};\r\nconst decryptAES256GCMWithPassword = (encryptedPassphrase, password) => {\r\n    const { iterations = PBKDF2_ITERATIONS, cipherText, iv, salt, tag, } = encryptedPassphrase;\r\n    const tagBuffer = getTagBuffer(tag);\r\n    const key = getKeyFromPassword(password, buffer_1.hexToBuffer(salt, 'Salt'), iterations);\r\n    const decipher = crypto.createDecipheriv('aes-256-gcm', key, buffer_1.hexToBuffer(iv, 'IV'));\r\n    decipher.setAuthTag(tagBuffer);\r\n    const firstBlock = decipher.update(buffer_1.hexToBuffer(cipherText, 'Cipher text'));\r\n    const decrypted = Buffer.concat([firstBlock, decipher.final()]);\r\n    return decrypted.toString();\r\n};\r\nexports.encryptPassphraseWithPassword = encryptAES256GCMWithPassword;\r\nexports.decryptPassphraseWithPassword = decryptAES256GCMWithPassword;\r\n//# sourceMappingURL=encrypt.js.map"]},"metadata":{},"sourceType":"script"}