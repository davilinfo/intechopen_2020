{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nconst base_transaction_1 = require(\"./base_transaction\");\n\nconst constants_1 = require(\"./constants\");\n\nconst errors_1 = require(\"./errors\");\n\nconst PREFIX_UPVOTE = '+';\nconst PREFIX_UNVOTE = '-';\nconst MAX_VOTE_PER_ACCOUNT = 101;\nconst MIN_VOTE_PER_TX = 1;\nconst MAX_VOTE_PER_TX = 33;\nexports.voteAssetFormatSchema = {\n  type: 'object',\n  required: ['votes'],\n  properties: {\n    votes: {\n      type: 'array',\n      minItems: MIN_VOTE_PER_TX,\n      maxItems: MAX_VOTE_PER_TX,\n      items: {\n        type: 'string',\n        format: 'signedPublicKey'\n      },\n      uniqueSignedPublicKeys: true\n    }\n  }\n};\n\nclass VoteTransaction extends base_transaction_1.BaseTransaction {\n  constructor(rawTransaction) {\n    super(rawTransaction);\n    const tx = typeof rawTransaction === 'object' && rawTransaction !== null ? rawTransaction : {};\n\n    if (tx.asset) {\n      const rawAsset = tx.asset;\n      this.asset = {\n        votes: rawAsset.votes\n      };\n    } else {\n      this.asset = {};\n    }\n\n    this.containsUniqueData = true;\n  }\n\n  assetToJSON() {\n    return {\n      votes: this.asset.votes\n    };\n  }\n\n  assetToBytes() {\n    return lisk_cryptography_1.stringToBuffer(this.asset.votes.join(''));\n  }\n\n  async prepare(store) {\n    const publicKeyObjectArray = this.asset.votes.map(pkWithAction => {\n      const publicKey = pkWithAction.slice(1);\n      return {\n        publicKey\n      };\n    });\n    const filterArray = [{\n      address: this.senderId\n    }, ...publicKeyObjectArray];\n    await store.account.cache(filterArray);\n  }\n\n  verifyAgainstTransactions(transactions) {\n    const sameTypeTransactions = transactions.filter(tx => tx.senderPublicKey === this.senderPublicKey && tx.type === this.type).map(tx => new VoteTransaction(tx));\n    const publicKeys = this.asset.votes.map(vote => vote.substring(1));\n    return sameTypeTransactions.reduce((previous, tx) => {\n      const conflictingVotes = tx.asset.votes.map(vote => vote.substring(1)).filter(publicKey => publicKeys.includes(publicKey));\n\n      if (conflictingVotes.length > 0) {\n        return [...previous, new errors_1.TransactionError(`Transaction includes conflicting votes: ${conflictingVotes.toString()}`, this.id, '.asset.votes')];\n      }\n\n      return previous;\n    }, []);\n  }\n\n  validateAsset() {\n    const asset = this.assetToJSON();\n    const schemaErrors = lisk_validator_1.validator.validate(exports.voteAssetFormatSchema, asset);\n    const errors = errors_1.convertToAssetError(this.id, schemaErrors);\n    return errors;\n  }\n\n  applyAsset(store) {\n    const errors = [];\n    const sender = store.account.get(this.senderId);\n    this.asset.votes.forEach(actionVotes => {\n      const vote = actionVotes.substring(1);\n      const voteAccount = store.account.find(account => account.publicKey === vote);\n\n      if (!voteAccount || voteAccount && (voteAccount.username === undefined || voteAccount.username === '' || voteAccount.username === null)) {\n        errors.push(new errors_1.TransactionError(`${vote} is not a delegate.`, this.id, '.asset.votes'));\n      }\n    });\n    const senderVotes = sender.votedDelegatesPublicKeys || [];\n    this.asset.votes.forEach(vote => {\n      const action = vote.charAt(0);\n      const publicKey = vote.substring(1);\n\n      if (action === PREFIX_UPVOTE && senderVotes.includes(publicKey)) {\n        errors.push(new errors_1.TransactionError(`${publicKey} is already voted.`, this.id, '.asset.votes'));\n      } else if (action === PREFIX_UNVOTE && !senderVotes.includes(publicKey)) {\n        errors.push(new errors_1.TransactionError(`${publicKey} is not voted.`, this.id, '.asset.votes'));\n      }\n    });\n    const upvotes = this.asset.votes.filter(vote => vote.charAt(0) === PREFIX_UPVOTE).map(vote => vote.substring(1));\n    const unvotes = this.asset.votes.filter(vote => vote.charAt(0) === PREFIX_UNVOTE).map(vote => vote.substring(1));\n    const originalVotes = sender.votedDelegatesPublicKeys || [];\n    const votedDelegatesPublicKeys = [...originalVotes, ...upvotes].filter(vote => !unvotes.includes(vote));\n\n    if (votedDelegatesPublicKeys.length > MAX_VOTE_PER_ACCOUNT) {\n      errors.push(new errors_1.TransactionError(`Vote cannot exceed ${MAX_VOTE_PER_ACCOUNT} but has ${votedDelegatesPublicKeys.length}.`, this.id, '.asset.votes', votedDelegatesPublicKeys.length.toString(), MAX_VOTE_PER_ACCOUNT));\n    }\n\n    const updatedSender = { ...sender,\n      votedDelegatesPublicKeys\n    };\n    store.account.set(updatedSender.address, updatedSender);\n    return errors;\n  }\n\n  undoAsset(store) {\n    const errors = [];\n    const sender = store.account.get(this.senderId);\n    const upvotes = this.asset.votes.filter(vote => vote.charAt(0) === PREFIX_UPVOTE).map(vote => vote.substring(1));\n    const unvotes = this.asset.votes.filter(vote => vote.charAt(0) === PREFIX_UNVOTE).map(vote => vote.substring(1));\n    const originalVotes = sender.votedDelegatesPublicKeys || [];\n    const votedDelegatesPublicKeys = [...originalVotes, ...unvotes].filter(vote => !upvotes.includes(vote));\n\n    if (votedDelegatesPublicKeys.length > MAX_VOTE_PER_ACCOUNT) {\n      errors.push(new errors_1.TransactionError(`Vote cannot exceed ${MAX_VOTE_PER_ACCOUNT} but has ${votedDelegatesPublicKeys.length}.`, this.id, '.asset.votes', votedDelegatesPublicKeys.length.toString(), MAX_VOTE_PER_ACCOUNT));\n    }\n\n    const updatedSender = { ...sender,\n      votedDelegatesPublicKeys\n    };\n    store.account.set(updatedSender.address, updatedSender);\n    return errors;\n  }\n\n}\n\nexports.VoteTransaction = VoteTransaction;\nVoteTransaction.TYPE = 11;\nVoteTransaction.FEE = constants_1.VOTE_FEE.toString();","map":{"version":3,"sources":["../src/11_vote_transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nconst base_transaction_1 = require(\"./base_transaction\");\nconst constants_1 = require(\"./constants\");\nconst errors_1 = require(\"./errors\");\nconst PREFIX_UPVOTE = '+';\nconst PREFIX_UNVOTE = '-';\nconst MAX_VOTE_PER_ACCOUNT = 101;\nconst MIN_VOTE_PER_TX = 1;\nconst MAX_VOTE_PER_TX = 33;\nexports.voteAssetFormatSchema = {\n    type: 'object',\n    required: ['votes'],\n    properties: {\n        votes: {\n            type: 'array',\n            minItems: MIN_VOTE_PER_TX,\n            maxItems: MAX_VOTE_PER_TX,\n            items: {\n                type: 'string',\n                format: 'signedPublicKey',\n            },\n            uniqueSignedPublicKeys: true,\n        },\n    },\n};\nclass VoteTransaction extends base_transaction_1.BaseTransaction {\n    constructor(rawTransaction) {\n        super(rawTransaction);\n        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null\n            ? rawTransaction\n            : {});\n        if (tx.asset) {\n            const rawAsset = tx.asset;\n            this.asset = {\n                votes: rawAsset.votes,\n            };\n        }\n        else {\n            this.asset = {};\n        }\n        this.containsUniqueData = true;\n    }\n    assetToJSON() {\n        return {\n            votes: this.asset.votes,\n        };\n    }\n    assetToBytes() {\n        return lisk_cryptography_1.stringToBuffer(this.asset.votes.join(''));\n    }\n    async prepare(store) {\n        const publicKeyObjectArray = this.asset.votes.map(pkWithAction => {\n            const publicKey = pkWithAction.slice(1);\n            return {\n                publicKey,\n            };\n        });\n        const filterArray = [\n            {\n                address: this.senderId,\n            },\n            ...publicKeyObjectArray,\n        ];\n        await store.account.cache(filterArray);\n    }\n    verifyAgainstTransactions(transactions) {\n        const sameTypeTransactions = transactions\n            .filter(tx => tx.senderPublicKey === this.senderPublicKey && tx.type === this.type)\n            .map(tx => new VoteTransaction(tx));\n        const publicKeys = this.asset.votes.map(vote => vote.substring(1));\n        return sameTypeTransactions.reduce((previous, tx) => {\n            const conflictingVotes = tx.asset.votes\n                .map(vote => vote.substring(1))\n                .filter(publicKey => publicKeys.includes(publicKey));\n            if (conflictingVotes.length > 0) {\n                return [\n                    ...previous,\n                    new errors_1.TransactionError(`Transaction includes conflicting votes: ${conflictingVotes.toString()}`, this.id, '.asset.votes'),\n                ];\n            }\n            return previous;\n        }, []);\n    }\n    validateAsset() {\n        const asset = this.assetToJSON();\n        const schemaErrors = lisk_validator_1.validator.validate(exports.voteAssetFormatSchema, asset);\n        const errors = errors_1.convertToAssetError(this.id, schemaErrors);\n        return errors;\n    }\n    applyAsset(store) {\n        const errors = [];\n        const sender = store.account.get(this.senderId);\n        this.asset.votes.forEach(actionVotes => {\n            const vote = actionVotes.substring(1);\n            const voteAccount = store.account.find(account => account.publicKey === vote);\n            if (!voteAccount ||\n                (voteAccount &&\n                    (voteAccount.username === undefined ||\n                        voteAccount.username === '' ||\n                        voteAccount.username === null))) {\n                errors.push(new errors_1.TransactionError(`${vote} is not a delegate.`, this.id, '.asset.votes'));\n            }\n        });\n        const senderVotes = sender.votedDelegatesPublicKeys || [];\n        this.asset.votes.forEach(vote => {\n            const action = vote.charAt(0);\n            const publicKey = vote.substring(1);\n            if (action === PREFIX_UPVOTE && senderVotes.includes(publicKey)) {\n                errors.push(new errors_1.TransactionError(`${publicKey} is already voted.`, this.id, '.asset.votes'));\n            }\n            else if (action === PREFIX_UNVOTE && !senderVotes.includes(publicKey)) {\n                errors.push(new errors_1.TransactionError(`${publicKey} is not voted.`, this.id, '.asset.votes'));\n            }\n        });\n        const upvotes = this.asset.votes\n            .filter(vote => vote.charAt(0) === PREFIX_UPVOTE)\n            .map(vote => vote.substring(1));\n        const unvotes = this.asset.votes\n            .filter(vote => vote.charAt(0) === PREFIX_UNVOTE)\n            .map(vote => vote.substring(1));\n        const originalVotes = sender.votedDelegatesPublicKeys || [];\n        const votedDelegatesPublicKeys = [\n            ...originalVotes,\n            ...upvotes,\n        ].filter(vote => !unvotes.includes(vote));\n        if (votedDelegatesPublicKeys.length > MAX_VOTE_PER_ACCOUNT) {\n            errors.push(new errors_1.TransactionError(`Vote cannot exceed ${MAX_VOTE_PER_ACCOUNT} but has ${votedDelegatesPublicKeys.length}.`, this.id, '.asset.votes', votedDelegatesPublicKeys.length.toString(), MAX_VOTE_PER_ACCOUNT));\n        }\n        const updatedSender = {\n            ...sender,\n            votedDelegatesPublicKeys,\n        };\n        store.account.set(updatedSender.address, updatedSender);\n        return errors;\n    }\n    undoAsset(store) {\n        const errors = [];\n        const sender = store.account.get(this.senderId);\n        const upvotes = this.asset.votes\n            .filter(vote => vote.charAt(0) === PREFIX_UPVOTE)\n            .map(vote => vote.substring(1));\n        const unvotes = this.asset.votes\n            .filter(vote => vote.charAt(0) === PREFIX_UNVOTE)\n            .map(vote => vote.substring(1));\n        const originalVotes = sender.votedDelegatesPublicKeys || [];\n        const votedDelegatesPublicKeys = [\n            ...originalVotes,\n            ...unvotes,\n        ].filter(vote => !upvotes.includes(vote));\n        if (votedDelegatesPublicKeys.length > MAX_VOTE_PER_ACCOUNT) {\n            errors.push(new errors_1.TransactionError(`Vote cannot exceed ${MAX_VOTE_PER_ACCOUNT} but has ${votedDelegatesPublicKeys.length}.`, this.id, '.asset.votes', votedDelegatesPublicKeys.length.toString(), MAX_VOTE_PER_ACCOUNT));\n        }\n        const updatedSender = {\n            ...sender,\n            votedDelegatesPublicKeys,\n        };\n        store.account.set(updatedSender.address, updatedSender);\n        return errors;\n    }\n}\nexports.VoteTransaction = VoteTransaction;\nVoteTransaction.TYPE = 11;\nVoteTransaction.FEE = constants_1.VOTE_FEE.toString();\n//# sourceMappingURL=11_vote_transaction.js.map"]},"metadata":{},"sourceType":"script"}