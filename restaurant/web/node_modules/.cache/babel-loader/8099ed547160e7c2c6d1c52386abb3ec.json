{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst cryptography = require(\"@liskhq/lisk-cryptography\");\n\nconst _10_delegate_transaction_1 = require(\"./10_delegate_transaction\");\n\nconst _11_vote_transaction_1 = require(\"./11_vote_transaction\");\n\nconst _12_multisignature_transaction_1 = require(\"./12_multisignature_transaction\");\n\nconst _8_transfer_transaction_1 = require(\"./8_transfer_transaction\");\n\nconst _9_second_signature_transaction_1 = require(\"./9_second_signature_transaction\");\n\nconst transactionMap = {\n  8: _8_transfer_transaction_1.TransferTransaction,\n  9: _9_second_signature_transaction_1.SecondSignatureTransaction,\n  10: _10_delegate_transaction_1.DelegateTransaction,\n  11: _11_vote_transaction_1.VoteTransaction,\n  12: _12_multisignature_transaction_1.MultisignatureTransaction\n};\n\nexports.createSignatureObject = options => {\n  const {\n    transaction,\n    passphrase,\n    networkIdentifier\n  } = options;\n\n  if (transaction.type === undefined || transaction.type === null) {\n    throw new Error('Transaction type is required.');\n  }\n\n  if (!Object.keys(transactionMap).includes(String(transaction.type))) {\n    throw new Error('Invalid transaction type.');\n  }\n\n  if (!transaction.id) {\n    throw new Error('Transaction ID is required to create a signature object.');\n  }\n\n  const TransactionClass = transactionMap[transaction.type];\n  const tx = new TransactionClass({ ...transaction,\n    networkIdentifier\n  });\n  const validStatus = tx.validate();\n\n  if (validStatus.errors.length > 0) {\n    throw new Error('Invalid transaction.');\n  }\n\n  const {\n    publicKey\n  } = cryptography.getPrivateAndPublicKeyFromPassphrase(passphrase);\n  tx._signature = undefined;\n  tx._signSignature = undefined;\n  const networkIdentifierBytes = Buffer.from(networkIdentifier, 'hex');\n  const transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifierBytes, tx.getBytes()]);\n  const multiSignature = cryptography.signData(cryptography.hash(transactionWithNetworkIdentifierBytes), passphrase);\n  return {\n    transactionId: tx.id,\n    publicKey,\n    signature: multiSignature\n  };\n};","map":{"version":3,"sources":["../src/create_signature_object.ts"],"names":[],"mappings":";;;;;;AAcA,MAAA,YAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;AAEA,MAAA,0BAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;AACA,MAAA,sBAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AACA,MAAA,gCAAA,GAAA,OAAA,CAAA,iCAAA,CAAA;;AACA,MAAA,yBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AACA,MAAA,iCAAA,GAAA,OAAA,CAAA,kCAAA,CAAA;;AAWA,MAAM,cAAc,GAAoC;AACvD,KAAG,yBAAA,CAAA,mBADoD;AAEvD,KAAG,iCAAA,CAAA,0BAFoD;AAGvD,MAAI,0BAAA,CAAA,mBAHmD;AAIvD,MAAI,sBAAA,CAAA,eAJmD;AAKvD,MAAI,gCAAA,CAAA;AALmD,CAAxD;;AAQa,OAAA,CAAA,qBAAA,GAAyB,OAAD,IAIf;AACrB,QAAM;AAAE,IAAA,WAAF;AAAe,IAAA,UAAf;AAA2B,IAAA;AAA3B,MAAiD,OAAvD;;AACA,MAAI,WAAW,CAAC,IAAZ,KAAqB,SAArB,IAAkC,WAAW,CAAC,IAAZ,KAAqB,IAA3D,EAAiE;AAChE,UAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN;AACA;;AAGD,MAAI,CAAC,MAAM,CAAC,IAAP,CAAY,cAAZ,EAA4B,QAA5B,CAAqC,MAAM,CAAC,WAAW,CAAC,IAAb,CAA3C,CAAL,EAAqE;AACpE,UAAM,IAAI,KAAJ,CAAU,2BAAV,CAAN;AACA;;AAED,MAAI,CAAC,WAAW,CAAC,EAAjB,EAAqB;AACpB,UAAM,IAAI,KAAJ,CAAU,0DAAV,CAAN;AACA;;AAGD,QAAM,gBAAgB,GAAG,cAAc,CAAC,WAAW,CAAC,IAAb,CAAvC;AACA,QAAM,EAAE,GAAG,IAAI,gBAAJ,CAAqB,EAC/B,GAAG,WAD4B;AAE/B,IAAA;AAF+B,GAArB,CAAX;AAKA,QAAM,WAAW,GAAG,EAAE,CAAC,QAAH,EAApB;;AACA,MAAI,WAAW,CAAC,MAAZ,CAAmB,MAAnB,GAA4B,CAAhC,EAAmC;AAClC,UAAM,IAAI,KAAJ,CAAU,sBAAV,CAAN;AACA;;AAED,QAAM;AAAE,IAAA;AAAF,MAAgB,YAAY,CAAC,oCAAb,CACrB,UADqB,CAAtB;AAKC,EAAA,EAAU,CAAC,UAAX,GAAwB,SAAxB;AAEA,EAAA,EAAU,CAAC,cAAX,GAA4B,SAA5B;AAED,QAAM,sBAAsB,GAAG,MAAM,CAAC,IAAP,CAAY,iBAAZ,EAA+B,KAA/B,CAA/B;AACA,QAAM,qCAAqC,GAAG,MAAM,CAAC,MAAP,CAAc,CAC3D,sBAD2D,EAE3D,EAAE,CAAC,QAAH,EAF2D,CAAd,CAA9C;AAKA,QAAM,cAAc,GAAG,YAAY,CAAC,QAAb,CACtB,YAAY,CAAC,IAAb,CAAkB,qCAAlB,CADsB,EAEtB,UAFsB,CAAvB;AAKA,SAAO;AACN,IAAA,aAAa,EAAE,EAAE,CAAC,EADZ;AAEN,IAAA,SAFM;AAGN,IAAA,SAAS,EAAE;AAHL,GAAP;AAKA,CAxDY","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cryptography = require(\"@liskhq/lisk-cryptography\");\r\nconst _10_delegate_transaction_1 = require(\"./10_delegate_transaction\");\r\nconst _11_vote_transaction_1 = require(\"./11_vote_transaction\");\r\nconst _12_multisignature_transaction_1 = require(\"./12_multisignature_transaction\");\r\nconst _8_transfer_transaction_1 = require(\"./8_transfer_transaction\");\r\nconst _9_second_signature_transaction_1 = require(\"./9_second_signature_transaction\");\r\nconst transactionMap = {\r\n    8: _8_transfer_transaction_1.TransferTransaction,\r\n    9: _9_second_signature_transaction_1.SecondSignatureTransaction,\r\n    10: _10_delegate_transaction_1.DelegateTransaction,\r\n    11: _11_vote_transaction_1.VoteTransaction,\r\n    12: _12_multisignature_transaction_1.MultisignatureTransaction,\r\n};\r\nexports.createSignatureObject = (options) => {\r\n    const { transaction, passphrase, networkIdentifier } = options;\r\n    if (transaction.type === undefined || transaction.type === null) {\r\n        throw new Error('Transaction type is required.');\r\n    }\r\n    if (!Object.keys(transactionMap).includes(String(transaction.type))) {\r\n        throw new Error('Invalid transaction type.');\r\n    }\r\n    if (!transaction.id) {\r\n        throw new Error('Transaction ID is required to create a signature object.');\r\n    }\r\n    const TransactionClass = transactionMap[transaction.type];\r\n    const tx = new TransactionClass({\r\n        ...transaction,\r\n        networkIdentifier,\r\n    });\r\n    const validStatus = tx.validate();\r\n    if (validStatus.errors.length > 0) {\r\n        throw new Error('Invalid transaction.');\r\n    }\r\n    const { publicKey } = cryptography.getPrivateAndPublicKeyFromPassphrase(passphrase);\r\n    tx._signature = undefined;\r\n    tx._signSignature = undefined;\r\n    const networkIdentifierBytes = Buffer.from(networkIdentifier, 'hex');\r\n    const transactionWithNetworkIdentifierBytes = Buffer.concat([\r\n        networkIdentifierBytes,\r\n        tx.getBytes(),\r\n    ]);\r\n    const multiSignature = cryptography.signData(cryptography.hash(transactionWithNetworkIdentifierBytes), passphrase);\r\n    return {\r\n        transactionId: tx.id,\r\n        publicKey,\r\n        signature: multiSignature,\r\n    };\r\n};\r\n//# sourceMappingURL=create_signature_object.js.map"]},"metadata":{},"sourceType":"script"}