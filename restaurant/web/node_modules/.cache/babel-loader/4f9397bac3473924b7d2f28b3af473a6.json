{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BigNum = require(\"@liskhq/bignum\");\n\nexports.BIG_ENDIAN = 'big';\nexports.LITTLE_ENDIAN = 'little';\n\nexports.intToBuffer = function (value, byteLength) {\n  var endianness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.BIG_ENDIAN;\n  return new BigNum(value).toBuffer({\n    size: byteLength,\n    endian: endianness\n  });\n};\n\nexports.bufferToIntAsString = function (buffer) {\n  return BigNum.fromBuffer(buffer).toString();\n};\n\nexports.bigNumberToBuffer = function (bignumber, size) {\n  var endian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.BIG_ENDIAN;\n  return exports.intToBuffer(bignumber, size, endian);\n};\n\nexports.bufferToBigNumberString = function (bigNumberBuffer) {\n  return exports.bufferToIntAsString(bigNumberBuffer);\n};\n\nexports.bufferToHex = function (buffer) {\n  return Buffer.from(buffer).toString('hex');\n};\n\nvar hexRegex = /^[0-9a-f]+/i;\n\nexports.hexToBuffer = function (hex) {\n  var argumentName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Argument';\n\n  if (typeof hex !== 'string') {\n    throw new TypeError(\"\".concat(argumentName, \" must be a string.\"));\n  }\n\n  var matchedHex = (hex.match(hexRegex) || [])[0];\n\n  if (!matchedHex || matchedHex.length !== hex.length) {\n    throw new TypeError(\"\".concat(argumentName, \" must be a valid hex string.\"));\n  }\n\n  if (matchedHex.length % 2 !== 0) {\n    throw new TypeError(\"\".concat(argumentName, \" must have a valid length of hex string.\"));\n  }\n\n  return Buffer.from(matchedHex, 'hex');\n};","map":{"version":3,"sources":["../src/buffer.ts"],"names":[],"mappings":";;;;;;AAcA,IAAA,MAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEa,OAAA,CAAA,UAAA,GAAa,KAAb;AACA,OAAA,CAAA,aAAA,GAAgB,QAAhB;;AAEA,OAAA,CAAA,WAAA,GAAc,UAC1B,KAD0B,EAE1B,UAF0B;AAAA,MAG1B,UAH0B,uEAGL,OAAA,CAAA,UAHK;AAAA,SAItB,IAAI,MAAJ,CAAW,KAAX,EAAkB,QAAlB,CAA2B;AAAE,IAAA,IAAI,EAAE,UAAR;AAAoB,IAAA,MAAM,EAAE;AAA5B,GAA3B,CAJsB;AAAA,CAAd;;AAMA,OAAA,CAAA,mBAAA,GAAsB,UAAC,MAAD;AAAA,SAClC,MAAM,CAAC,UAAP,CAAkB,MAAlB,EAA0B,QAA1B,EADkC;AAAA,CAAtB;;AAOA,OAAA,CAAA,iBAAA,GAAoB,UAChC,SADgC,EAEhC,IAFgC;AAAA,MAGhC,MAHgC,uEAGf,OAAA,CAAA,UAHe;AAAA,SAI5B,OAAA,CAAA,WAAA,CAAY,SAAZ,EAAuB,IAAvB,EAA6B,MAA7B,CAJ4B;AAAA,CAApB;;AAUA,OAAA,CAAA,uBAAA,GAA0B,UAAC,eAAD;AAAA,SACtC,OAAA,CAAA,mBAAA,CAAoB,eAApB,CADsC;AAAA,CAA1B;;AAGA,OAAA,CAAA,WAAA,GAAc,UAAC,MAAD;AAAA,SAC1B,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,QAApB,CAA6B,KAA7B,CAD0B;AAAA,CAAd;;AAGb,IAAM,QAAQ,GAAG,aAAjB;;AACa,OAAA,CAAA,WAAA,GAAc,UAAC,GAAD,EAAmD;AAAA,MAArC,YAAqC,uEAAtB,UAAsB;;AAC7E,MAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AAC5B,UAAM,IAAI,SAAJ,WAAiB,YAAjB,wBAAN;AACA;;AACD,MAAM,UAAU,GAAG,CAAC,GAAG,CAAC,KAAJ,CAAU,QAAV,KAAuB,EAAxB,EAA4B,CAA5B,CAAnB;;AACA,MAAI,CAAC,UAAD,IAAe,UAAU,CAAC,MAAX,KAAsB,GAAG,CAAC,MAA7C,EAAqD;AACpD,UAAM,IAAI,SAAJ,WAAiB,YAAjB,kCAAN;AACA;;AAED,MAAI,UAAU,CAAC,MAAX,GAAoB,CAApB,KAA0B,CAA9B,EAAiC;AAChC,UAAM,IAAI,SAAJ,WACF,YADE,8CAAN;AAGA;;AAED,SAAO,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAwB,KAAxB,CAAP;AACA,CAhBY","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BigNum = require(\"@liskhq/bignum\");\r\nexports.BIG_ENDIAN = 'big';\r\nexports.LITTLE_ENDIAN = 'little';\r\nexports.intToBuffer = (value, byteLength, endianness = exports.BIG_ENDIAN) => new BigNum(value).toBuffer({ size: byteLength, endian: endianness });\r\nexports.bufferToIntAsString = (buffer) => BigNum.fromBuffer(buffer).toString();\r\nexports.bigNumberToBuffer = (bignumber, size, endian = exports.BIG_ENDIAN) => exports.intToBuffer(bignumber, size, endian);\r\nexports.bufferToBigNumberString = (bigNumberBuffer) => exports.bufferToIntAsString(bigNumberBuffer);\r\nexports.bufferToHex = (buffer) => Buffer.from(buffer).toString('hex');\r\nconst hexRegex = /^[0-9a-f]+/i;\r\nexports.hexToBuffer = (hex, argumentName = 'Argument') => {\r\n    if (typeof hex !== 'string') {\r\n        throw new TypeError(`${argumentName} must be a string.`);\r\n    }\r\n    const matchedHex = (hex.match(hexRegex) || [])[0];\r\n    if (!matchedHex || matchedHex.length !== hex.length) {\r\n        throw new TypeError(`${argumentName} must be a valid hex string.`);\r\n    }\r\n    if (matchedHex.length % 2 !== 0) {\r\n        throw new TypeError(`${argumentName} must have a valid length of hex string.`);\r\n    }\r\n    return Buffer.from(matchedHex, 'hex');\r\n};\r\n//# sourceMappingURL=buffer.js.map"]},"metadata":{},"sourceType":"script"}