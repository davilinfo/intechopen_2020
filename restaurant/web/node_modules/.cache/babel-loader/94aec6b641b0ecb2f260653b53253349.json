{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BigNum = require(\"@liskhq/bignum\");\n\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nconst semver_1 = require(\"semver\");\n\nconst validator = require(\"validator\");\n\nconst constants_1 = require(\"./constants\");\n\nexports.isNullCharacterIncluded = input => new RegExp(/\\0|\\\\u0000|\\\\x00/).test(input);\n\nexports.isUsername = username => {\n  if (exports.isNullCharacterIncluded(username)) {\n    return false;\n  }\n\n  if (username !== username.trim().toLowerCase()) {\n    return false;\n  }\n\n  if (/^[0-9]{1,21}[L|l]$/g.test(username)) {\n    return false;\n  }\n\n  if (!/^[a-z0-9!@$&_.]+$/g.test(username)) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.isSignature = signature => /^[a-f0-9]{128}$/i.test(signature);\n\nexports.isGreaterThanZero = amount => amount.cmp(0) > 0;\n\nexports.isGreaterThanMaxTransactionAmount = amount => amount.cmp(constants_1.MAX_INT64) > 0;\n\nexports.isGreaterThanMaxTransactionId = id => id.cmp(constants_1.MAX_EIGHT_BYTE_NUMBER) > 0;\n\nexports.isNumberString = num => {\n  if (typeof num !== 'string') {\n    return false;\n  }\n\n  return validator.isInt(num);\n};\n\nexports.isPositiveNumberString = num => {\n  if (typeof num !== 'string') {\n    return false;\n  }\n\n  return /^[0-9]+$/g.test(num);\n};\n\nexports.isValidInteger = num => typeof num === 'number' ? Math.floor(num) === num : false;\n\nexports.hasNoDuplicate = values => {\n  const unique = [...new Set(values)];\n  return unique.length === values.length;\n};\n\nexports.isStringBufferLessThan = (data, max) => {\n  if (typeof data !== 'string') {\n    return false;\n  }\n\n  return Buffer.from(data).length <= max;\n};\n\nexports.isHexString = data => {\n  if (typeof data !== 'string') {\n    return false;\n  }\n\n  return data === '' || /^[a-f0-9]+$/i.test(data);\n};\n\nexports.isEncryptedPassphrase = data => {\n  const keyRegExp = /[a-zA-Z0-9]{2,15}/;\n  const valueRegExp = /[a-f0-9]{1,256}/;\n  const keyValueRegExp = new RegExp(`${keyRegExp.source}=${valueRegExp.source}`);\n  const encryptedPassphraseRegExp = new RegExp(`^(${keyValueRegExp.source})(?:&(${keyValueRegExp.source})){0,10}$`);\n  return encryptedPassphraseRegExp.test(data);\n};\n\nexports.isSemVer = version => !!semver_1.valid(version);\n\nexports.isRangedSemVer = version => !!semver_1.validRange(version);\n\nexports.isLessThanRangedVersion = semver_1.ltr;\nexports.isGreaterThanRangedVersion = semver_1.gtr;\n\nexports.isProtocolString = data => /^(\\d|[1-9]\\d{1,2})\\.(\\d|[1-9]\\d{1,2})$/.test(data);\n\nconst IPV4_NUMBER = 4;\nconst IPV6_NUMBER = 6;\n\nexports.isIPV4 = data => validator.isIP(data, IPV4_NUMBER);\n\nexports.isIPV6 = data => validator.isIP(data, IPV6_NUMBER);\n\nexports.isIP = data => exports.isIPV4(data) || exports.isIPV6(data);\n\nexports.isPort = port => validator.isPort(port);\n\nexports.validatePublicKeysForDuplicates = publicKeys => publicKeys.every((element, index) => {\n  if (publicKeys.slice(index + 1).includes(element)) {\n    throw new Error(`Duplicated public key: ${publicKeys[index]}.`);\n  }\n\n  return true;\n});\n\nexports.isStringEndsWith = (target, suffixes) => suffixes.some(suffix => target.endsWith(suffix));\n\nexports.isVersionMatch = semver_1.gte;\n\nexports.validatePublicKey = publicKey => {\n  const publicKeyBuffer = lisk_cryptography_1.hexToBuffer(publicKey);\n\n  if (publicKeyBuffer.length !== constants_1.MAX_PUBLIC_KEY_LENGTH) {\n    throw new Error(`Public key ${publicKey} length differs from the expected 32 bytes for a public key.`);\n  }\n\n  return true;\n};\n\nexports.validatePublicKeys = publicKeys => publicKeys.every(exports.validatePublicKey) && exports.validatePublicKeysForDuplicates(publicKeys);\n\nexports.validateKeysgroup = (keysgroup, min, max) => {\n  if (keysgroup.length < min || keysgroup.length > max) {\n    throw new Error(`Expected between ${min} and ${max} public keys in the keysgroup.`);\n  }\n\n  return exports.validatePublicKeys(keysgroup);\n};\n\nconst MIN_ADDRESS_LENGTH = 2;\nconst MAX_ADDRESS_LENGTH = 22;\nconst BASE_TEN = 10;\n\nexports.validateAddress = address => {\n  if (address.length < MIN_ADDRESS_LENGTH || address.length > MAX_ADDRESS_LENGTH) {\n    throw new Error('Address length does not match requirements. Expected between 2 and 22 characters.');\n  }\n\n  if (address[address.length - 1] !== 'L') {\n    throw new Error('Address format does not match requirements. Expected \"L\" at the end.');\n  }\n\n  if (address.includes('.')) {\n    throw new Error('Address format does not match requirements. Address includes invalid character: `.`.');\n  }\n\n  const addressString = address.slice(0, -1);\n  const addressNumber = new BigNum(addressString);\n\n  if (addressNumber.cmp(new BigNum(constants_1.MAX_EIGHT_BYTE_NUMBER)) > 0) {\n    throw new Error('Address format does not match requirements. Address out of maximum range.');\n  }\n\n  if (addressString !== addressNumber.toString(BASE_TEN)) {\n    throw new Error(\"Address string format does not match it's number representation.\");\n  }\n\n  return true;\n};\n\nexports.isValidNonTransferAmount = data => exports.isNumberString(data) && data === '0';\n\nexports.isValidTransferAmount = data => exports.isNumberString(data) && exports.isGreaterThanZero(new BigNum(data)) && !exports.isGreaterThanMaxTransactionAmount(new BigNum(data));\n\nexports.isValidFee = data => exports.isNumberString(data) && exports.isGreaterThanZero(new BigNum(data)) && !exports.isGreaterThanMaxTransactionAmount(new BigNum(data));\n\nexports.isCsv = data => {\n  if (typeof data !== 'string') {\n    return false;\n  }\n\n  const csvAsArray = data.split(',');\n\n  if (csvAsArray.length > 0) {\n    return true;\n  }\n\n  return false;\n};\n\nconst MAX_TRANSFER_ASSET_DATA_LENGTH = 64;\n\nexports.isValidTransferData = data => Buffer.byteLength(data, 'utf8') <= MAX_TRANSFER_ASSET_DATA_LENGTH;\n\nconst NETWORK_IDENTIFIER_LENGTH = 32;\n\nexports.validateNetworkIdentifier = networkIdentifier => {\n  if (!networkIdentifier) {\n    throw new Error(`Network identifier can not be empty.`);\n  }\n\n  const networkIdentifierBuffer = lisk_cryptography_1.hexToBuffer(networkIdentifier);\n\n  if (networkIdentifierBuffer.length !== NETWORK_IDENTIFIER_LENGTH) {\n    throw new Error(`Invalid network identifier length: ${networkIdentifier}`);\n  }\n\n  return true;\n};","map":{"version":3,"sources":["../src/validation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BigNum = require(\"@liskhq/bignum\");\r\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\r\nconst semver_1 = require(\"semver\");\r\nconst validator = require(\"validator\");\r\nconst constants_1 = require(\"./constants\");\r\nexports.isNullCharacterIncluded = (input) => new RegExp(/\\0|\\\\u0000|\\\\x00/).test(input);\r\nexports.isUsername = (username) => {\r\n    if (exports.isNullCharacterIncluded(username)) {\r\n        return false;\r\n    }\r\n    if (username !== username.trim().toLowerCase()) {\r\n        return false;\r\n    }\r\n    if (/^[0-9]{1,21}[L|l]$/g.test(username)) {\r\n        return false;\r\n    }\r\n    if (!/^[a-z0-9!@$&_.]+$/g.test(username)) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\nexports.isSignature = (signature) => /^[a-f0-9]{128}$/i.test(signature);\r\nexports.isGreaterThanZero = (amount) => amount.cmp(0) > 0;\r\nexports.isGreaterThanMaxTransactionAmount = (amount) => amount.cmp(constants_1.MAX_INT64) > 0;\r\nexports.isGreaterThanMaxTransactionId = (id) => id.cmp(constants_1.MAX_EIGHT_BYTE_NUMBER) > 0;\r\nexports.isNumberString = (num) => {\r\n    if (typeof num !== 'string') {\r\n        return false;\r\n    }\r\n    return validator.isInt(num);\r\n};\r\nexports.isPositiveNumberString = (num) => {\r\n    if (typeof num !== 'string') {\r\n        return false;\r\n    }\r\n    return /^[0-9]+$/g.test(num);\r\n};\r\nexports.isValidInteger = (num) => typeof num === 'number' ? Math.floor(num) === num : false;\r\nexports.hasNoDuplicate = (values) => {\r\n    const unique = [...new Set(values)];\r\n    return unique.length === values.length;\r\n};\r\nexports.isStringBufferLessThan = (data, max) => {\r\n    if (typeof data !== 'string') {\r\n        return false;\r\n    }\r\n    return Buffer.from(data).length <= max;\r\n};\r\nexports.isHexString = (data) => {\r\n    if (typeof data !== 'string') {\r\n        return false;\r\n    }\r\n    return data === '' || /^[a-f0-9]+$/i.test(data);\r\n};\r\nexports.isEncryptedPassphrase = (data) => {\r\n    const keyRegExp = /[a-zA-Z0-9]{2,15}/;\r\n    const valueRegExp = /[a-f0-9]{1,256}/;\r\n    const keyValueRegExp = new RegExp(`${keyRegExp.source}=${valueRegExp.source}`);\r\n    const encryptedPassphraseRegExp = new RegExp(`^(${keyValueRegExp.source})(?:&(${keyValueRegExp.source})){0,10}$`);\r\n    return encryptedPassphraseRegExp.test(data);\r\n};\r\nexports.isSemVer = (version) => !!semver_1.valid(version);\r\nexports.isRangedSemVer = (version) => !!semver_1.validRange(version);\r\nexports.isLessThanRangedVersion = semver_1.ltr;\r\nexports.isGreaterThanRangedVersion = semver_1.gtr;\r\nexports.isProtocolString = (data) => /^(\\d|[1-9]\\d{1,2})\\.(\\d|[1-9]\\d{1,2})$/.test(data);\r\nconst IPV4_NUMBER = 4;\r\nconst IPV6_NUMBER = 6;\r\nexports.isIPV4 = (data) => validator.isIP(data, IPV4_NUMBER);\r\nexports.isIPV6 = (data) => validator.isIP(data, IPV6_NUMBER);\r\nexports.isIP = (data) => exports.isIPV4(data) || exports.isIPV6(data);\r\nexports.isPort = (port) => validator.isPort(port);\r\nexports.validatePublicKeysForDuplicates = (publicKeys) => publicKeys.every((element, index) => {\r\n    if (publicKeys.slice(index + 1).includes(element)) {\r\n        throw new Error(`Duplicated public key: ${publicKeys[index]}.`);\r\n    }\r\n    return true;\r\n});\r\nexports.isStringEndsWith = (target, suffixes) => suffixes.some(suffix => target.endsWith(suffix));\r\nexports.isVersionMatch = semver_1.gte;\r\nexports.validatePublicKey = (publicKey) => {\r\n    const publicKeyBuffer = lisk_cryptography_1.hexToBuffer(publicKey);\r\n    if (publicKeyBuffer.length !== constants_1.MAX_PUBLIC_KEY_LENGTH) {\r\n        throw new Error(`Public key ${publicKey} length differs from the expected 32 bytes for a public key.`);\r\n    }\r\n    return true;\r\n};\r\nexports.validatePublicKeys = (publicKeys) => publicKeys.every(exports.validatePublicKey) &&\r\n    exports.validatePublicKeysForDuplicates(publicKeys);\r\nexports.validateKeysgroup = (keysgroup, min, max) => {\r\n    if (keysgroup.length < min || keysgroup.length > max) {\r\n        throw new Error(`Expected between ${min} and ${max} public keys in the keysgroup.`);\r\n    }\r\n    return exports.validatePublicKeys(keysgroup);\r\n};\r\nconst MIN_ADDRESS_LENGTH = 2;\r\nconst MAX_ADDRESS_LENGTH = 22;\r\nconst BASE_TEN = 10;\r\nexports.validateAddress = (address) => {\r\n    if (address.length < MIN_ADDRESS_LENGTH ||\r\n        address.length > MAX_ADDRESS_LENGTH) {\r\n        throw new Error('Address length does not match requirements. Expected between 2 and 22 characters.');\r\n    }\r\n    if (address[address.length - 1] !== 'L') {\r\n        throw new Error('Address format does not match requirements. Expected \"L\" at the end.');\r\n    }\r\n    if (address.includes('.')) {\r\n        throw new Error('Address format does not match requirements. Address includes invalid character: `.`.');\r\n    }\r\n    const addressString = address.slice(0, -1);\r\n    const addressNumber = new BigNum(addressString);\r\n    if (addressNumber.cmp(new BigNum(constants_1.MAX_EIGHT_BYTE_NUMBER)) > 0) {\r\n        throw new Error('Address format does not match requirements. Address out of maximum range.');\r\n    }\r\n    if (addressString !== addressNumber.toString(BASE_TEN)) {\r\n        throw new Error(\"Address string format does not match it's number representation.\");\r\n    }\r\n    return true;\r\n};\r\nexports.isValidNonTransferAmount = (data) => exports.isNumberString(data) && data === '0';\r\nexports.isValidTransferAmount = (data) => exports.isNumberString(data) &&\r\n    exports.isGreaterThanZero(new BigNum(data)) &&\r\n    !exports.isGreaterThanMaxTransactionAmount(new BigNum(data));\r\nexports.isValidFee = (data) => exports.isNumberString(data) &&\r\n    exports.isGreaterThanZero(new BigNum(data)) &&\r\n    !exports.isGreaterThanMaxTransactionAmount(new BigNum(data));\r\nexports.isCsv = (data) => {\r\n    if (typeof data !== 'string') {\r\n        return false;\r\n    }\r\n    const csvAsArray = data.split(',');\r\n    if (csvAsArray.length > 0) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\nconst MAX_TRANSFER_ASSET_DATA_LENGTH = 64;\r\nexports.isValidTransferData = (data) => Buffer.byteLength(data, 'utf8') <= MAX_TRANSFER_ASSET_DATA_LENGTH;\r\nconst NETWORK_IDENTIFIER_LENGTH = 32;\r\nexports.validateNetworkIdentifier = (networkIdentifier) => {\r\n    if (!networkIdentifier) {\r\n        throw new Error(`Network identifier can not be empty.`);\r\n    }\r\n    const networkIdentifierBuffer = lisk_cryptography_1.hexToBuffer(networkIdentifier);\r\n    if (networkIdentifierBuffer.length !== NETWORK_IDENTIFIER_LENGTH) {\r\n        throw new Error(`Invalid network identifier length: ${networkIdentifier}`);\r\n    }\r\n    return true;\r\n};\r\n//# sourceMappingURL=validation.js.map"]},"metadata":{},"sourceType":"script"}