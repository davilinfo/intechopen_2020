{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BigNum = require(\"@liskhq/bignum\");\n\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nconst base_transaction_1 = require(\"./base_transaction\");\n\nconst constants_1 = require(\"./constants\");\n\nconst errors_1 = require(\"./errors\");\n\nconst response_1 = require(\"./response\");\n\nconst utils_1 = require(\"./utils\");\n\nexports.multisignatureAssetFormatSchema = {\n  type: 'object',\n  required: ['min', 'lifetime', 'keysgroup'],\n  properties: {\n    min: {\n      type: 'integer',\n      minimum: 1,\n      maximum: 15\n    },\n    lifetime: {\n      type: 'integer',\n      minimum: 1,\n      maximum: 72\n    },\n    keysgroup: {\n      type: 'array',\n      uniqueItems: true,\n      minItems: 1,\n      maxItems: 15,\n      items: {\n        type: 'string',\n        format: 'additionPublicKey'\n      }\n    }\n  }\n};\n\nconst setMemberAccounts = (store, membersPublicKeys) => {\n  membersPublicKeys.forEach(memberPublicKey => {\n    const address = lisk_cryptography_1.getAddressFromPublicKey(memberPublicKey);\n    const memberAccount = store.account.getOrDefault(address);\n    const memberAccountWithPublicKey = { ...memberAccount,\n      publicKey: memberAccount.publicKey || memberPublicKey\n    };\n    store.account.set(memberAccount.address, memberAccountWithPublicKey);\n  });\n};\n\nconst extractPublicKeysFromAsset = assetPublicKeys => assetPublicKeys.map(key => key.substring(1));\n\nclass MultisignatureTransaction extends base_transaction_1.BaseTransaction {\n  constructor(rawTransaction) {\n    super(rawTransaction);\n    this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;\n    const tx = typeof rawTransaction === 'object' && rawTransaction !== null ? rawTransaction : {};\n    this.asset = tx.asset || {};\n    this.fee = new BigNum(MultisignatureTransaction.FEE).mul((this.asset.keysgroup && this.asset.keysgroup.length ? this.asset.keysgroup.length : 0) + 1);\n  }\n\n  assetToBytes() {\n    const {\n      min,\n      lifetime,\n      keysgroup\n    } = this.asset;\n    const minBuffer = Buffer.alloc(1, min);\n    const lifetimeBuffer = Buffer.alloc(1, lifetime);\n    const keysgroupBuffer = Buffer.from(keysgroup.join(''), 'utf8');\n    return Buffer.concat([minBuffer, lifetimeBuffer, keysgroupBuffer]);\n  }\n\n  async prepare(store) {\n    const membersAddresses = extractPublicKeysFromAsset(this.asset.keysgroup).map(publicKey => ({\n      address: lisk_cryptography_1.getAddressFromPublicKey(publicKey)\n    }));\n    await store.account.cache([{\n      address: this.senderId\n    }, ...membersAddresses]);\n  }\n\n  verifyAgainstTransactions(transactions) {\n    const errors = transactions.filter(tx => tx.type === this.type && tx.senderPublicKey === this.senderPublicKey).map(tx => new errors_1.TransactionError('Register multisignature only allowed once per account.', tx.id, '.asset.multisignature'));\n    return errors;\n  }\n\n  validateAsset() {\n    const schemaErrors = lisk_validator_1.validator.validate(exports.multisignatureAssetFormatSchema, this.asset);\n    const errors = errors_1.convertToAssetError(this.id, schemaErrors);\n\n    if (errors.length > 0) {\n      return errors;\n    }\n\n    if (this.asset.min > this.asset.keysgroup.length) {\n      errors.push(new errors_1.TransactionError('Invalid multisignature min. Must be less than or equal to keysgroup size', this.id, '.asset.min', this.asset.min));\n    }\n\n    return errors;\n  }\n\n  processMultisignatures(_) {\n    const transactionBytes = this.getBasicBytes();\n    const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\n    const transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifierBytes, transactionBytes]);\n    const {\n      valid,\n      errors\n    } = utils_1.validateMultisignatures(this.asset.keysgroup.map(signedPublicKey => signedPublicKey.substring(1)), this.signatures, this.asset.keysgroup.length, transactionWithNetworkIdentifierBytes, this.id);\n\n    if (valid) {\n      this._multisignatureStatus = base_transaction_1.MultisignatureStatus.READY;\n      return response_1.createResponse(this.id, errors);\n    }\n\n    if (errors && errors.length === 1 && errors[0] instanceof errors_1.TransactionPendingError) {\n      this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;\n      return {\n        id: this.id,\n        status: response_1.Status.PENDING,\n        errors\n      };\n    }\n\n    this._multisignatureStatus = base_transaction_1.MultisignatureStatus.FAIL;\n    return response_1.createResponse(this.id, errors);\n  }\n\n  applyAsset(store) {\n    const errors = [];\n    const sender = store.account.get(this.senderId);\n\n    if (sender.membersPublicKeys && sender.membersPublicKeys.length > 0) {\n      errors.push(new errors_1.TransactionError('Register multisignature only allowed once per account.', this.id, '.signatures'));\n    }\n\n    if (this.asset.keysgroup.includes(`+${sender.publicKey}`)) {\n      errors.push(new errors_1.TransactionError('Invalid multisignature keysgroup. Can not contain sender', this.id, '.signatures'));\n    }\n\n    const updatedSender = { ...sender,\n      membersPublicKeys: extractPublicKeysFromAsset(this.asset.keysgroup),\n      multiMin: this.asset.min,\n      multiLifetime: this.asset.lifetime\n    };\n    store.account.set(updatedSender.address, updatedSender);\n    setMemberAccounts(store, updatedSender.membersPublicKeys);\n    return errors;\n  }\n\n  undoAsset(store) {\n    const sender = store.account.get(this.senderId);\n    const resetSender = { ...sender,\n      membersPublicKeys: [],\n      multiMin: 0,\n      multiLifetime: 0\n    };\n    store.account.set(resetSender.address, resetSender);\n    return [];\n  }\n\n  addMultisignature(store, signatureObject) {\n    const keysgroup = this.asset.keysgroup.map(aKey => aKey.slice(1));\n\n    if (!keysgroup.includes(signatureObject.publicKey)) {\n      return response_1.createResponse(this.id, [new errors_1.TransactionError(`Public Key '${signatureObject.publicKey}' is not a member.`, this.id)]);\n    }\n\n    if (this.signatures.includes(signatureObject.signature)) {\n      return response_1.createResponse(this.id, [new errors_1.TransactionError('Encountered duplicate signature in transaction', this.id)]);\n    }\n\n    const transactionBytes = this.getBasicBytes();\n    const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\n    const transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifierBytes, transactionBytes]);\n    const {\n      valid\n    } = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, transactionWithNetworkIdentifierBytes, this.id);\n\n    if (valid) {\n      this.signatures.push(signatureObject.signature);\n      return this.processMultisignatures(store);\n    }\n\n    const errors = valid ? [] : [new errors_1.TransactionError(`Failed to add signature ${signatureObject.signature}.`, this.id, '.signatures')];\n    return response_1.createResponse(this.id, errors);\n  }\n\n}\n\nexports.MultisignatureTransaction = MultisignatureTransaction;\nMultisignatureTransaction.TYPE = 12;\nMultisignatureTransaction.FEE = constants_1.MULTISIGNATURE_FEE.toString();","map":{"version":3,"sources":["../src/12_multisignature_transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BigNum = require(\"@liskhq/bignum\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nconst base_transaction_1 = require(\"./base_transaction\");\nconst constants_1 = require(\"./constants\");\nconst errors_1 = require(\"./errors\");\nconst response_1 = require(\"./response\");\nconst utils_1 = require(\"./utils\");\nexports.multisignatureAssetFormatSchema = {\n    type: 'object',\n    required: ['min', 'lifetime', 'keysgroup'],\n    properties: {\n        min: {\n            type: 'integer',\n            minimum: 1,\n            maximum: 15,\n        },\n        lifetime: {\n            type: 'integer',\n            minimum: 1,\n            maximum: 72,\n        },\n        keysgroup: {\n            type: 'array',\n            uniqueItems: true,\n            minItems: 1,\n            maxItems: 15,\n            items: {\n                type: 'string',\n                format: 'additionPublicKey',\n            },\n        },\n    },\n};\nconst setMemberAccounts = (store, membersPublicKeys) => {\n    membersPublicKeys.forEach(memberPublicKey => {\n        const address = lisk_cryptography_1.getAddressFromPublicKey(memberPublicKey);\n        const memberAccount = store.account.getOrDefault(address);\n        const memberAccountWithPublicKey = {\n            ...memberAccount,\n            publicKey: memberAccount.publicKey || memberPublicKey,\n        };\n        store.account.set(memberAccount.address, memberAccountWithPublicKey);\n    });\n};\nconst extractPublicKeysFromAsset = (assetPublicKeys) => assetPublicKeys.map(key => key.substring(1));\nclass MultisignatureTransaction extends base_transaction_1.BaseTransaction {\n    constructor(rawTransaction) {\n        super(rawTransaction);\n        this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;\n        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null\n            ? rawTransaction\n            : {});\n        this.asset = (tx.asset || {});\n        this.fee = new BigNum(MultisignatureTransaction.FEE).mul((this.asset.keysgroup && this.asset.keysgroup.length\n            ? this.asset.keysgroup.length\n            : 0) + 1);\n    }\n    assetToBytes() {\n        const { min, lifetime, keysgroup } = this.asset;\n        const minBuffer = Buffer.alloc(1, min);\n        const lifetimeBuffer = Buffer.alloc(1, lifetime);\n        const keysgroupBuffer = Buffer.from(keysgroup.join(''), 'utf8');\n        return Buffer.concat([minBuffer, lifetimeBuffer, keysgroupBuffer]);\n    }\n    async prepare(store) {\n        const membersAddresses = extractPublicKeysFromAsset(this.asset.keysgroup).map(publicKey => ({ address: lisk_cryptography_1.getAddressFromPublicKey(publicKey) }));\n        await store.account.cache([\n            {\n                address: this.senderId,\n            },\n            ...membersAddresses,\n        ]);\n    }\n    verifyAgainstTransactions(transactions) {\n        const errors = transactions\n            .filter(tx => tx.type === this.type && tx.senderPublicKey === this.senderPublicKey)\n            .map(tx => new errors_1.TransactionError('Register multisignature only allowed once per account.', tx.id, '.asset.multisignature'));\n        return errors;\n    }\n    validateAsset() {\n        const schemaErrors = lisk_validator_1.validator.validate(exports.multisignatureAssetFormatSchema, this.asset);\n        const errors = errors_1.convertToAssetError(this.id, schemaErrors);\n        if (errors.length > 0) {\n            return errors;\n        }\n        if (this.asset.min > this.asset.keysgroup.length) {\n            errors.push(new errors_1.TransactionError('Invalid multisignature min. Must be less than or equal to keysgroup size', this.id, '.asset.min', this.asset.min));\n        }\n        return errors;\n    }\n    processMultisignatures(_) {\n        const transactionBytes = this.getBasicBytes();\n        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\n        const transactionWithNetworkIdentifierBytes = Buffer.concat([\n            networkIdentifierBytes,\n            transactionBytes,\n        ]);\n        const { valid, errors } = utils_1.validateMultisignatures(this.asset.keysgroup.map(signedPublicKey => signedPublicKey.substring(1)), this.signatures, this.asset.keysgroup.length, transactionWithNetworkIdentifierBytes, this.id);\n        if (valid) {\n            this._multisignatureStatus = base_transaction_1.MultisignatureStatus.READY;\n            return response_1.createResponse(this.id, errors);\n        }\n        if (errors &&\n            errors.length === 1 &&\n            errors[0] instanceof errors_1.TransactionPendingError) {\n            this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;\n            return {\n                id: this.id,\n                status: response_1.Status.PENDING,\n                errors,\n            };\n        }\n        this._multisignatureStatus = base_transaction_1.MultisignatureStatus.FAIL;\n        return response_1.createResponse(this.id, errors);\n    }\n    applyAsset(store) {\n        const errors = [];\n        const sender = store.account.get(this.senderId);\n        if (sender.membersPublicKeys && sender.membersPublicKeys.length > 0) {\n            errors.push(new errors_1.TransactionError('Register multisignature only allowed once per account.', this.id, '.signatures'));\n        }\n        if (this.asset.keysgroup.includes(`+${sender.publicKey}`)) {\n            errors.push(new errors_1.TransactionError('Invalid multisignature keysgroup. Can not contain sender', this.id, '.signatures'));\n        }\n        const updatedSender = {\n            ...sender,\n            membersPublicKeys: extractPublicKeysFromAsset(this.asset.keysgroup),\n            multiMin: this.asset.min,\n            multiLifetime: this.asset.lifetime,\n        };\n        store.account.set(updatedSender.address, updatedSender);\n        setMemberAccounts(store, updatedSender.membersPublicKeys);\n        return errors;\n    }\n    undoAsset(store) {\n        const sender = store.account.get(this.senderId);\n        const resetSender = {\n            ...sender,\n            membersPublicKeys: [],\n            multiMin: 0,\n            multiLifetime: 0,\n        };\n        store.account.set(resetSender.address, resetSender);\n        return [];\n    }\n    addMultisignature(store, signatureObject) {\n        const keysgroup = this.asset.keysgroup.map((aKey) => aKey.slice(1));\n        if (!keysgroup.includes(signatureObject.publicKey)) {\n            return response_1.createResponse(this.id, [\n                new errors_1.TransactionError(`Public Key '${signatureObject.publicKey}' is not a member.`, this.id),\n            ]);\n        }\n        if (this.signatures.includes(signatureObject.signature)) {\n            return response_1.createResponse(this.id, [\n                new errors_1.TransactionError('Encountered duplicate signature in transaction', this.id),\n            ]);\n        }\n        const transactionBytes = this.getBasicBytes();\n        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\n        const transactionWithNetworkIdentifierBytes = Buffer.concat([\n            networkIdentifierBytes,\n            transactionBytes,\n        ]);\n        const { valid } = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, transactionWithNetworkIdentifierBytes, this.id);\n        if (valid) {\n            this.signatures.push(signatureObject.signature);\n            return this.processMultisignatures(store);\n        }\n        const errors = valid\n            ? []\n            : [\n                new errors_1.TransactionError(`Failed to add signature ${signatureObject.signature}.`, this.id, '.signatures'),\n            ];\n        return response_1.createResponse(this.id, errors);\n    }\n}\nexports.MultisignatureTransaction = MultisignatureTransaction;\nMultisignatureTransaction.TYPE = 12;\nMultisignatureTransaction.FEE = constants_1.MULTISIGNATURE_FEE.toString();\n//# sourceMappingURL=12_multisignature_transaction.js.map"]},"metadata":{},"sourceType":"script"}