{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BigNum = require(\"@liskhq/bignum\");\n\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nconst base_transaction_1 = require(\"./base_transaction\");\n\nconst constants_1 = require(\"./constants\");\n\nconst errors_1 = require(\"./errors\");\n\nconst response_1 = require(\"./response\");\n\nconst utils_1 = require(\"./utils\");\n\nexports.multisignatureAssetFormatSchema = {\n  type: 'object',\n  required: ['multisignature'],\n  properties: {\n    multisignature: {\n      type: 'object',\n      required: ['min', 'lifetime', 'keysgroup'],\n      properties: {\n        min: {\n          type: 'integer',\n          minimum: 1,\n          maximum: 15\n        },\n        lifetime: {\n          type: 'integer',\n          minimum: 1,\n          maximum: 72\n        },\n        keysgroup: {\n          type: 'array',\n          uniqueItems: true,\n          minItems: 1,\n          maxItems: 15,\n          items: {\n            type: 'string',\n            format: 'additionPublicKey'\n          }\n        }\n      }\n    }\n  }\n};\n\nconst setMemberAccounts = (store, membersPublicKeys) => {\n  membersPublicKeys.forEach(memberPublicKey => {\n    const address = lisk_cryptography_1.getAddressFromPublicKey(memberPublicKey);\n    const memberAccount = store.account.getOrDefault(address);\n    const memberAccountWithPublicKey = Object.assign({}, memberAccount, {\n      publicKey: memberAccount.publicKey || memberPublicKey\n    });\n    store.account.set(memberAccount.address, memberAccountWithPublicKey);\n  });\n};\n\nconst extractPublicKeysFromAsset = assetPublicKeys => assetPublicKeys.map(key => key.substring(1));\n\nclass MultisignatureTransaction extends base_transaction_1.BaseTransaction {\n  constructor(rawTransaction) {\n    super(rawTransaction);\n    this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;\n    const tx = typeof rawTransaction === 'object' && rawTransaction !== null ? rawTransaction : {};\n    this.asset = tx.asset || {\n      multisignature: {}\n    };\n  }\n\n  assetToBytes() {\n    const {\n      multisignature: {\n        min,\n        lifetime,\n        keysgroup\n      }\n    } = this.asset;\n    const minBuffer = Buffer.alloc(1, min);\n    const lifetimeBuffer = Buffer.alloc(1, lifetime);\n    const keysgroupBuffer = Buffer.from(keysgroup.join(''), 'utf8');\n    return Buffer.concat([minBuffer, lifetimeBuffer, keysgroupBuffer]);\n  }\n\n  async prepare(store) {\n    const membersAddresses = extractPublicKeysFromAsset(this.asset.multisignature.keysgroup).map(publicKey => ({\n      address: lisk_cryptography_1.getAddressFromPublicKey(publicKey)\n    }));\n    await store.account.cache([{\n      address: this.senderId\n    }, ...membersAddresses]);\n  }\n\n  verifyAgainstTransactions(transactions) {\n    const errors = transactions.filter(tx => tx.type === this.type && tx.senderPublicKey === this.senderPublicKey).map(tx => new errors_1.TransactionError('Register multisignature only allowed once per account.', tx.id, '.asset.multisignature'));\n    return errors;\n  }\n\n  validateAsset() {\n    utils_1.validator.validate(exports.multisignatureAssetFormatSchema, this.asset);\n    const errors = errors_1.convertToAssetError(this.id, utils_1.validator.errors);\n\n    if (!this.amount.eq(0)) {\n      errors.push(new errors_1.TransactionError('Amount must be zero for multisignature registration transaction', this.id, '.amount', this.amount.toString(), '0'));\n    }\n\n    if (errors.length > 0) {\n      return errors;\n    }\n\n    if (this.asset.multisignature.min > this.asset.multisignature.keysgroup.length) {\n      errors.push(new errors_1.TransactionError('Invalid multisignature min. Must be less than or equal to keysgroup size', this.id, '.asset.multisignature.min', this.asset.multisignature.min));\n    }\n\n    if (this.recipientId) {\n      errors.push(new errors_1.TransactionError('RecipientId is expected to be undefined', this.id, '.recipientId', this.recipientId));\n    }\n\n    if (this.recipientPublicKey) {\n      errors.push(new errors_1.TransactionError('RecipientPublicKey is expected to be undefined', this.id, '.recipientPublicKey', this.recipientPublicKey));\n    }\n\n    return errors;\n  }\n\n  validateFee() {\n    const expectedFee = new BigNum(MultisignatureTransaction.FEE).mul(this.asset.multisignature.keysgroup.length + 1);\n    return !this.fee.eq(expectedFee) ? new errors_1.TransactionError(`Fee must be equal to ${expectedFee.toString()}`, this.id, '.fee', this.fee.toString(), expectedFee.toString()) : undefined;\n  }\n\n  processMultisignatures(_) {\n    const transactionBytes = this.getBasicBytes();\n    const {\n      valid,\n      errors\n    } = utils_1.validateMultisignatures(this.asset.multisignature.keysgroup.map(signedPublicKey => signedPublicKey.substring(1)), this.signatures, this.asset.multisignature.keysgroup.length, transactionBytes, this.id);\n\n    if (valid) {\n      this._multisignatureStatus = base_transaction_1.MultisignatureStatus.READY;\n      return response_1.createResponse(this.id, errors);\n    }\n\n    if (errors && errors.length === 1 && errors[0] instanceof errors_1.TransactionPendingError) {\n      this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;\n      return {\n        id: this.id,\n        status: response_1.Status.PENDING,\n        errors\n      };\n    }\n\n    this._multisignatureStatus = base_transaction_1.MultisignatureStatus.FAIL;\n    return response_1.createResponse(this.id, errors);\n  }\n\n  applyAsset(store) {\n    const errors = [];\n    const sender = store.account.get(this.senderId);\n\n    if (sender.membersPublicKeys && sender.membersPublicKeys.length > 0) {\n      errors.push(new errors_1.TransactionError('Register multisignature only allowed once per account.', this.id, '.signatures'));\n    }\n\n    if (this.asset.multisignature.keysgroup.includes(`+${sender.publicKey}`)) {\n      errors.push(new errors_1.TransactionError('Invalid multisignature keysgroup. Can not contain sender', this.id, '.signatures'));\n    }\n\n    const updatedSender = Object.assign({}, sender, {\n      membersPublicKeys: extractPublicKeysFromAsset(this.asset.multisignature.keysgroup),\n      multiMin: this.asset.multisignature.min,\n      multiLifetime: this.asset.multisignature.lifetime\n    });\n    store.account.set(updatedSender.address, updatedSender);\n    setMemberAccounts(store, updatedSender.membersPublicKeys);\n    return errors;\n  }\n\n  undoAsset(store) {\n    const sender = store.account.get(this.senderId);\n    const resetSender = Object.assign({}, sender, {\n      membersPublicKeys: [],\n      multiMin: 0,\n      multiLifetime: 0\n    });\n    store.account.set(resetSender.address, resetSender);\n    return [];\n  }\n\n  addMultisignature(store, signatureObject) {\n    const keysgroup = this.asset.multisignature.keysgroup.map(aKey => aKey.slice(1));\n\n    if (!keysgroup.includes(signatureObject.publicKey)) {\n      return response_1.createResponse(this.id, [new errors_1.TransactionError(`Public Key '${signatureObject.publicKey}' is not a member.`, this.id)]);\n    }\n\n    if (this.signatures.includes(signatureObject.signature)) {\n      return response_1.createResponse(this.id, [new errors_1.TransactionError('Encountered duplicate signature in transaction', this.id)]);\n    }\n\n    const {\n      valid\n    } = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, this.getBasicBytes(), this.id);\n\n    if (valid) {\n      this.signatures.push(signatureObject.signature);\n      return this.processMultisignatures(store);\n    }\n\n    const errors = valid ? [] : [new errors_1.TransactionError(`Failed to add signature ${signatureObject.signature}.`, this.id, '.signatures')];\n    return response_1.createResponse(this.id, errors);\n  }\n\n  assetFromSync(raw) {\n    if (!raw.m_keysgroup) {\n      return undefined;\n    }\n\n    const multisignature = {\n      min: raw.m_min,\n      lifetime: raw.m_lifetime,\n      keysgroup: typeof raw.m_keysgroup === 'string' ? raw.m_keysgroup.split(',') : raw.m_keysgroup\n    };\n    return {\n      multisignature\n    };\n  }\n\n}\n\nMultisignatureTransaction.TYPE = 4;\nMultisignatureTransaction.FEE = constants_1.MULTISIGNATURE_FEE.toString();\nexports.MultisignatureTransaction = MultisignatureTransaction;","map":{"version":3,"sources":["../src/4_multisignature_transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BigNum = require(\"@liskhq/bignum\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst base_transaction_1 = require(\"./base_transaction\");\nconst constants_1 = require(\"./constants\");\nconst errors_1 = require(\"./errors\");\nconst response_1 = require(\"./response\");\nconst utils_1 = require(\"./utils\");\nexports.multisignatureAssetFormatSchema = {\n    type: 'object',\n    required: ['multisignature'],\n    properties: {\n        multisignature: {\n            type: 'object',\n            required: ['min', 'lifetime', 'keysgroup'],\n            properties: {\n                min: {\n                    type: 'integer',\n                    minimum: 1,\n                    maximum: 15,\n                },\n                lifetime: {\n                    type: 'integer',\n                    minimum: 1,\n                    maximum: 72,\n                },\n                keysgroup: {\n                    type: 'array',\n                    uniqueItems: true,\n                    minItems: 1,\n                    maxItems: 15,\n                    items: {\n                        type: 'string',\n                        format: 'additionPublicKey',\n                    },\n                },\n            },\n        },\n    },\n};\nconst setMemberAccounts = (store, membersPublicKeys) => {\n    membersPublicKeys.forEach(memberPublicKey => {\n        const address = lisk_cryptography_1.getAddressFromPublicKey(memberPublicKey);\n        const memberAccount = store.account.getOrDefault(address);\n        const memberAccountWithPublicKey = Object.assign({}, memberAccount, { publicKey: memberAccount.publicKey || memberPublicKey });\n        store.account.set(memberAccount.address, memberAccountWithPublicKey);\n    });\n};\nconst extractPublicKeysFromAsset = (assetPublicKeys) => assetPublicKeys.map(key => key.substring(1));\nclass MultisignatureTransaction extends base_transaction_1.BaseTransaction {\n    constructor(rawTransaction) {\n        super(rawTransaction);\n        this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;\n        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null\n            ? rawTransaction\n            : {});\n        this.asset = (tx.asset || { multisignature: {} });\n    }\n    assetToBytes() {\n        const { multisignature: { min, lifetime, keysgroup }, } = this.asset;\n        const minBuffer = Buffer.alloc(1, min);\n        const lifetimeBuffer = Buffer.alloc(1, lifetime);\n        const keysgroupBuffer = Buffer.from(keysgroup.join(''), 'utf8');\n        return Buffer.concat([minBuffer, lifetimeBuffer, keysgroupBuffer]);\n    }\n    async prepare(store) {\n        const membersAddresses = extractPublicKeysFromAsset(this.asset.multisignature.keysgroup).map(publicKey => ({ address: lisk_cryptography_1.getAddressFromPublicKey(publicKey) }));\n        await store.account.cache([\n            {\n                address: this.senderId,\n            },\n            ...membersAddresses,\n        ]);\n    }\n    verifyAgainstTransactions(transactions) {\n        const errors = transactions\n            .filter(tx => tx.type === this.type && tx.senderPublicKey === this.senderPublicKey)\n            .map(tx => new errors_1.TransactionError('Register multisignature only allowed once per account.', tx.id, '.asset.multisignature'));\n        return errors;\n    }\n    validateAsset() {\n        utils_1.validator.validate(exports.multisignatureAssetFormatSchema, this.asset);\n        const errors = errors_1.convertToAssetError(this.id, utils_1.validator.errors);\n        if (!this.amount.eq(0)) {\n            errors.push(new errors_1.TransactionError('Amount must be zero for multisignature registration transaction', this.id, '.amount', this.amount.toString(), '0'));\n        }\n        if (errors.length > 0) {\n            return errors;\n        }\n        if (this.asset.multisignature.min > this.asset.multisignature.keysgroup.length) {\n            errors.push(new errors_1.TransactionError('Invalid multisignature min. Must be less than or equal to keysgroup size', this.id, '.asset.multisignature.min', this.asset.multisignature.min));\n        }\n        if (this.recipientId) {\n            errors.push(new errors_1.TransactionError('RecipientId is expected to be undefined', this.id, '.recipientId', this.recipientId));\n        }\n        if (this.recipientPublicKey) {\n            errors.push(new errors_1.TransactionError('RecipientPublicKey is expected to be undefined', this.id, '.recipientPublicKey', this.recipientPublicKey));\n        }\n        return errors;\n    }\n    validateFee() {\n        const expectedFee = new BigNum(MultisignatureTransaction.FEE).mul(this.asset.multisignature.keysgroup.length + 1);\n        return !this.fee.eq(expectedFee)\n            ? new errors_1.TransactionError(`Fee must be equal to ${expectedFee.toString()}`, this.id, '.fee', this.fee.toString(), expectedFee.toString())\n            : undefined;\n    }\n    processMultisignatures(_) {\n        const transactionBytes = this.getBasicBytes();\n        const { valid, errors } = utils_1.validateMultisignatures(this.asset.multisignature.keysgroup.map(signedPublicKey => signedPublicKey.substring(1)), this.signatures, this.asset.multisignature.keysgroup.length, transactionBytes, this.id);\n        if (valid) {\n            this._multisignatureStatus = base_transaction_1.MultisignatureStatus.READY;\n            return response_1.createResponse(this.id, errors);\n        }\n        if (errors &&\n            errors.length === 1 &&\n            errors[0] instanceof errors_1.TransactionPendingError) {\n            this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;\n            return {\n                id: this.id,\n                status: response_1.Status.PENDING,\n                errors,\n            };\n        }\n        this._multisignatureStatus = base_transaction_1.MultisignatureStatus.FAIL;\n        return response_1.createResponse(this.id, errors);\n    }\n    applyAsset(store) {\n        const errors = [];\n        const sender = store.account.get(this.senderId);\n        if (sender.membersPublicKeys && sender.membersPublicKeys.length > 0) {\n            errors.push(new errors_1.TransactionError('Register multisignature only allowed once per account.', this.id, '.signatures'));\n        }\n        if (this.asset.multisignature.keysgroup.includes(`+${sender.publicKey}`)) {\n            errors.push(new errors_1.TransactionError('Invalid multisignature keysgroup. Can not contain sender', this.id, '.signatures'));\n        }\n        const updatedSender = Object.assign({}, sender, { membersPublicKeys: extractPublicKeysFromAsset(this.asset.multisignature.keysgroup), multiMin: this.asset.multisignature.min, multiLifetime: this.asset.multisignature.lifetime });\n        store.account.set(updatedSender.address, updatedSender);\n        setMemberAccounts(store, updatedSender.membersPublicKeys);\n        return errors;\n    }\n    undoAsset(store) {\n        const sender = store.account.get(this.senderId);\n        const resetSender = Object.assign({}, sender, { membersPublicKeys: [], multiMin: 0, multiLifetime: 0 });\n        store.account.set(resetSender.address, resetSender);\n        return [];\n    }\n    addMultisignature(store, signatureObject) {\n        const keysgroup = this.asset.multisignature.keysgroup.map((aKey) => aKey.slice(1));\n        if (!keysgroup.includes(signatureObject.publicKey)) {\n            return response_1.createResponse(this.id, [\n                new errors_1.TransactionError(`Public Key '${signatureObject.publicKey}' is not a member.`, this.id),\n            ]);\n        }\n        if (this.signatures.includes(signatureObject.signature)) {\n            return response_1.createResponse(this.id, [\n                new errors_1.TransactionError('Encountered duplicate signature in transaction', this.id),\n            ]);\n        }\n        const { valid } = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, this.getBasicBytes(), this.id);\n        if (valid) {\n            this.signatures.push(signatureObject.signature);\n            return this.processMultisignatures(store);\n        }\n        const errors = valid\n            ? []\n            : [\n                new errors_1.TransactionError(`Failed to add signature ${signatureObject.signature}.`, this.id, '.signatures'),\n            ];\n        return response_1.createResponse(this.id, errors);\n    }\n    assetFromSync(raw) {\n        if (!raw.m_keysgroup) {\n            return undefined;\n        }\n        const multisignature = {\n            min: raw.m_min,\n            lifetime: raw.m_lifetime,\n            keysgroup: typeof raw.m_keysgroup === 'string'\n                ? raw.m_keysgroup.split(',')\n                : raw.m_keysgroup,\n        };\n        return { multisignature };\n    }\n}\nMultisignatureTransaction.TYPE = 4;\nMultisignatureTransaction.FEE = constants_1.MULTISIGNATURE_FEE.toString();\nexports.MultisignatureTransaction = MultisignatureTransaction;\n//# sourceMappingURL=4_multisignature_transaction.js.map"]},"metadata":{},"sourceType":"script"}