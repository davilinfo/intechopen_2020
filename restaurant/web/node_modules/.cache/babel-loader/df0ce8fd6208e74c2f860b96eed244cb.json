{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BigNum = require(\"@liskhq/bignum\");\n\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nconst constants_1 = require(\"./constants\");\n\nconst errors_1 = require(\"./errors\");\n\nconst response_1 = require(\"./response\");\n\nconst schemas = require(\"./schema\");\n\nconst utils_1 = require(\"./utils\");\n\nvar MultisignatureStatus;\n\n(function (MultisignatureStatus) {\n  MultisignatureStatus[MultisignatureStatus[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  MultisignatureStatus[MultisignatureStatus[\"NONMULTISIGNATURE\"] = 1] = \"NONMULTISIGNATURE\";\n  MultisignatureStatus[MultisignatureStatus[\"PENDING\"] = 2] = \"PENDING\";\n  MultisignatureStatus[MultisignatureStatus[\"READY\"] = 3] = \"READY\";\n  MultisignatureStatus[MultisignatureStatus[\"FAIL\"] = 4] = \"FAIL\";\n})(MultisignatureStatus = exports.MultisignatureStatus || (exports.MultisignatureStatus = {}));\n\nexports.ENTITY_ACCOUNT = 'account';\nexports.ENTITY_TRANSACTION = 'transaction';\n\nclass BaseTransaction {\n  constructor(rawTransaction) {\n    this._multisignatureStatus = MultisignatureStatus.UNKNOWN;\n    const tx = typeof rawTransaction === 'object' && rawTransaction !== null ? rawTransaction : {};\n    this.fee = new BigNum(this.constructor.FEE);\n    this.type = typeof tx.type === 'number' ? tx.type : this.constructor.TYPE;\n    this._id = tx.id;\n    this._senderPublicKey = tx.senderPublicKey || '';\n    this._signature = tx.signature;\n    this.signatures = tx.signatures || [];\n    this._signSignature = tx.signSignature;\n    this._networkIdentifier = tx.networkIdentifier || '';\n    this.timestamp = typeof tx.timestamp === 'number' ? tx.timestamp : 0;\n    this.confirmations = tx.confirmations;\n    this.blockId = tx.blockId;\n    this.height = tx.height;\n    this.receivedAt = tx.receivedAt ? new Date(tx.receivedAt) : undefined;\n    this.asset = tx.asset || {};\n  }\n\n  get id() {\n    return this._id || 'incalculable-id';\n  }\n\n  get senderId() {\n    return lisk_cryptography_1.getAddressFromPublicKey(this.senderPublicKey);\n  }\n\n  get senderPublicKey() {\n    if (!this._senderPublicKey) {\n      throw new Error('senderPublicKey is required to be set before use');\n    }\n\n    return this._senderPublicKey;\n  }\n\n  get signature() {\n    if (!this._signature) {\n      throw new Error('signature is required to be set before use');\n    }\n\n    return this._signature;\n  }\n\n  get signSignature() {\n    return this._signSignature;\n  }\n\n  toJSON() {\n    const transaction = {\n      id: this._id,\n      blockId: this.blockId,\n      height: this.height,\n      confirmations: this.confirmations,\n      type: this.type,\n      timestamp: this.timestamp,\n      senderPublicKey: this._senderPublicKey || '',\n      senderId: this._senderPublicKey ? this.senderId : '',\n      fee: this.fee.toString(),\n      signature: this._signature,\n      signSignature: this.signSignature ? this.signSignature : undefined,\n      signatures: this.signatures,\n      asset: this.assetToJSON(),\n      receivedAt: this.receivedAt ? this.receivedAt.toISOString() : undefined\n    };\n    return transaction;\n  }\n\n  stringify() {\n    return JSON.stringify(this.toJSON());\n  }\n\n  isReady() {\n    return this._multisignatureStatus === MultisignatureStatus.READY || this._multisignatureStatus === MultisignatureStatus.NONMULTISIGNATURE;\n  }\n\n  getBytes() {\n    const transactionBytes = Buffer.concat([this.getBasicBytes(), this._signature ? lisk_cryptography_1.hexToBuffer(this._signature) : Buffer.alloc(0), this._signSignature ? lisk_cryptography_1.hexToBuffer(this._signSignature) : Buffer.alloc(0)]);\n    return transactionBytes;\n  }\n\n  validate() {\n    const errors = [...this._validateSchema(), ...this.validateAsset()];\n\n    if (errors.length > 0) {\n      return response_1.createResponse(this.id, errors);\n    }\n\n    const transactionBytes = this.getBasicBytes();\n\n    if (this._networkIdentifier === undefined || this._networkIdentifier === '') {\n      throw new Error('Network identifier is required to validate a transaction ');\n    }\n\n    const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\n    const transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifierBytes, transactionBytes]);\n    this._id = utils_1.getId(this.getBytes());\n    const {\n      valid: signatureValid,\n      error: verificationError\n    } = utils_1.validateSignature(this.senderPublicKey, this.signature, transactionWithNetworkIdentifierBytes, this.id);\n\n    if (!signatureValid && verificationError) {\n      errors.push(verificationError);\n    }\n\n    if (this.type !== this.constructor.TYPE) {\n      errors.push(new errors_1.TransactionError(`Invalid type`, this.id, '.type', this.type, this.constructor.TYPE));\n    }\n\n    return response_1.createResponse(this.id, errors);\n  }\n\n  verifyAgainstTransactions(_) {\n    return [];\n  }\n\n  verifyAgainstOtherTransactions(transactions) {\n    const errors = this.verifyAgainstTransactions(transactions);\n    return response_1.createResponse(this.id, errors);\n  }\n\n  apply(store) {\n    const sender = store.account.getOrDefault(this.senderId);\n\n    const errors = this._verify(sender);\n\n    const {\n      errors: multiSigError\n    } = this.processMultisignatures(store);\n\n    if (multiSigError) {\n      errors.push(...multiSigError);\n    }\n\n    const updatedBalance = new BigNum(sender.balance).sub(this.fee);\n    const updatedSender = { ...sender,\n      balance: updatedBalance.toString(),\n      publicKey: sender.publicKey || this.senderPublicKey\n    };\n    store.account.set(updatedSender.address, updatedSender);\n    const assetErrors = this.applyAsset(store);\n    errors.push(...assetErrors);\n\n    if (this._multisignatureStatus === MultisignatureStatus.PENDING && errors.length === 1 && errors[0] instanceof errors_1.TransactionPendingError) {\n      return {\n        id: this.id,\n        status: response_1.Status.PENDING,\n        errors\n      };\n    }\n\n    return response_1.createResponse(this.id, errors);\n  }\n\n  undo(store) {\n    const sender = store.account.getOrDefault(this.senderId);\n    const updatedBalance = new BigNum(sender.balance).add(this.fee);\n    const updatedAccount = { ...sender,\n      balance: updatedBalance.toString(),\n      publicKey: sender.publicKey || this.senderPublicKey\n    };\n    const errors = updatedBalance.lte(constants_1.MAX_TRANSACTION_AMOUNT) ? [] : [new errors_1.TransactionError('Invalid balance amount', this.id, '.balance', sender.balance, updatedBalance.toString())];\n    store.account.set(updatedAccount.address, updatedAccount);\n    const assetErrors = this.undoAsset(store);\n    errors.push(...assetErrors);\n    return response_1.createResponse(this.id, errors);\n  }\n\n  async prepare(store) {\n    await store.account.cache([{\n      address: this.senderId\n    }]);\n  }\n\n  addMultisignature(store, signatureObject) {\n    const account = store.account.get(this.senderId);\n\n    if (account.membersPublicKeys && !account.membersPublicKeys.includes(signatureObject.publicKey)) {\n      return response_1.createResponse(this.id, [new errors_1.TransactionError(`Public Key '${signatureObject.publicKey}' is not a member for account '${account.address}'.`, this.id)]);\n    }\n\n    if (this.signatures.includes(signatureObject.signature)) {\n      return response_1.createResponse(this.id, [new errors_1.TransactionError(`Signature '${signatureObject.signature}' already present in transaction.`, this.id)]);\n    }\n\n    const transactionBytes = this.getBasicBytes();\n\n    if (this._networkIdentifier === undefined || this._networkIdentifier === '') {\n      throw new Error('Network identifier is required to validate a transaction ');\n    }\n\n    const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\n    const transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifierBytes, transactionBytes]);\n    const {\n      valid\n    } = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, transactionWithNetworkIdentifierBytes, this.id);\n\n    if (valid) {\n      this.signatures.push(signatureObject.signature);\n      return this.processMultisignatures(store);\n    }\n\n    const errors = valid ? [] : [new errors_1.TransactionError(`Failed to add signature '${signatureObject.signature}'.`, this.id, '.signatures')];\n    return response_1.createResponse(this.id, errors);\n  }\n\n  addVerifiedMultisignature(signature) {\n    if (!this.signatures.includes(signature)) {\n      this.signatures.push(signature);\n      return response_1.createResponse(this.id, []);\n    }\n\n    return response_1.createResponse(this.id, [new errors_1.TransactionError('Failed to add signature.', this.id, '.signatures')]);\n  }\n\n  processMultisignatures(store) {\n    const sender = store.account.get(this.senderId);\n    const transactionBytes = this.getBasicBytes();\n\n    if (this._networkIdentifier === undefined || this._networkIdentifier === '') {\n      throw new Error('Network identifier is required to validate a transaction ');\n    }\n\n    const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\n    const transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifierBytes, transactionBytes]);\n    const {\n      status,\n      errors\n    } = utils_1.verifyMultiSignatures(this.id, sender, this.signatures, transactionWithNetworkIdentifierBytes);\n    this._multisignatureStatus = status;\n\n    if (this._multisignatureStatus === MultisignatureStatus.PENDING) {\n      return {\n        id: this.id,\n        status: response_1.Status.PENDING,\n        errors\n      };\n    }\n\n    return response_1.createResponse(this.id, errors);\n  }\n\n  isExpired(date = new Date()) {\n    if (!this.receivedAt) {\n      this.receivedAt = new Date();\n    }\n\n    const timeNow = Math.floor(date.getTime() / 1000);\n    const timeOut = this._multisignatureStatus === MultisignatureStatus.PENDING || this._multisignatureStatus === MultisignatureStatus.READY ? constants_1.UNCONFIRMED_MULTISIG_TRANSACTION_TIMEOUT : constants_1.UNCONFIRMED_TRANSACTION_TIMEOUT;\n    const timeElapsed = timeNow - Math.floor(this.receivedAt.getTime() / 1000);\n    return timeElapsed > timeOut;\n  }\n\n  sign(passphrase, secondPassphrase) {\n    const {\n      publicKey\n    } = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase);\n\n    if (this._senderPublicKey !== '' && this._senderPublicKey !== publicKey) {\n      throw new Error('Transaction senderPublicKey does not match public key from passphrase');\n    }\n\n    this._senderPublicKey = publicKey;\n    this._signature = undefined;\n    this._signSignature = undefined;\n\n    if (this._networkIdentifier === undefined || this._networkIdentifier === '') {\n      throw new Error('Network identifier is required to sign a transaction ');\n    }\n\n    const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\n    const transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifierBytes, this.getBytes()]);\n    this._signature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(transactionWithNetworkIdentifierBytes), passphrase);\n\n    if (secondPassphrase) {\n      this._signSignature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(Buffer.concat([transactionWithNetworkIdentifierBytes, lisk_cryptography_1.hexToBuffer(this._signature)])), secondPassphrase);\n    }\n\n    this._id = utils_1.getId(this.getBytes());\n  }\n\n  getBasicBytes() {\n    const transactionType = Buffer.alloc(constants_1.BYTESIZES.TYPE, this.type);\n    const transactionTimestamp = Buffer.alloc(constants_1.BYTESIZES.TIMESTAMP);\n    transactionTimestamp.writeIntBE(this.timestamp, 0, constants_1.BYTESIZES.TIMESTAMP);\n    const transactionSenderPublicKey = lisk_cryptography_1.hexToBuffer(this.senderPublicKey);\n    return Buffer.concat([transactionType, transactionTimestamp, transactionSenderPublicKey, this.assetToBytes()]);\n  }\n\n  assetToJSON() {\n    return this.asset;\n  }\n\n  assetToBytes() {\n    return Buffer.from(JSON.stringify(this.asset), 'utf-8');\n  }\n\n  _verify(sender) {\n    const transactionBytes = this.getBasicBytes();\n\n    if (this._networkIdentifier === undefined || this._networkIdentifier === '') {\n      throw new Error('Network identifier is required to verify a transaction ');\n    }\n\n    const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\n    const transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifierBytes, transactionBytes]);\n    const secondSignatureTxBytes = Buffer.concat([transactionWithNetworkIdentifierBytes, lisk_cryptography_1.hexToBuffer(this.signature)]);\n    return [utils_1.verifySenderPublicKey(this.id, sender, this.senderPublicKey), utils_1.verifyBalance(this.id, sender, this.fee), utils_1.verifySecondSignature(this.id, sender, this.signSignature, secondSignatureTxBytes)].filter(Boolean);\n  }\n\n  _validateSchema() {\n    const transaction = this.toJSON();\n    const schemaErrors = lisk_validator_1.validator.validate(schemas.baseTransaction, transaction);\n    const errors = errors_1.convertToTransactionError(this.id, schemaErrors);\n\n    if (!errors.find(err => err.dataPath === '.senderPublicKey')) {\n      const senderIdError = utils_1.validateSenderIdAndPublicKey(this.id, this.senderId, this.senderPublicKey);\n\n      if (senderIdError) {\n        errors.push(senderIdError);\n      }\n    }\n\n    return errors;\n  }\n\n}\n\nexports.BaseTransaction = BaseTransaction;\nBaseTransaction.FEE = '0';","map":{"version":3,"sources":["../src/base_transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BigNum = require(\"@liskhq/bignum\");\r\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\r\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\r\nconst constants_1 = require(\"./constants\");\r\nconst errors_1 = require(\"./errors\");\r\nconst response_1 = require(\"./response\");\r\nconst schemas = require(\"./schema\");\r\nconst utils_1 = require(\"./utils\");\r\nvar MultisignatureStatus;\r\n(function (MultisignatureStatus) {\r\n    MultisignatureStatus[MultisignatureStatus[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\r\n    MultisignatureStatus[MultisignatureStatus[\"NONMULTISIGNATURE\"] = 1] = \"NONMULTISIGNATURE\";\r\n    MultisignatureStatus[MultisignatureStatus[\"PENDING\"] = 2] = \"PENDING\";\r\n    MultisignatureStatus[MultisignatureStatus[\"READY\"] = 3] = \"READY\";\r\n    MultisignatureStatus[MultisignatureStatus[\"FAIL\"] = 4] = \"FAIL\";\r\n})(MultisignatureStatus = exports.MultisignatureStatus || (exports.MultisignatureStatus = {}));\r\nexports.ENTITY_ACCOUNT = 'account';\r\nexports.ENTITY_TRANSACTION = 'transaction';\r\nclass BaseTransaction {\r\n    constructor(rawTransaction) {\r\n        this._multisignatureStatus = MultisignatureStatus.UNKNOWN;\r\n        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null\r\n            ? rawTransaction\r\n            : {});\r\n        this.fee = new BigNum(this.constructor.FEE);\r\n        this.type =\r\n            typeof tx.type === 'number'\r\n                ? tx.type\r\n                : this.constructor.TYPE;\r\n        this._id = tx.id;\r\n        this._senderPublicKey = tx.senderPublicKey || '';\r\n        this._signature = tx.signature;\r\n        this.signatures = tx.signatures || [];\r\n        this._signSignature = tx.signSignature;\r\n        this._networkIdentifier = tx.networkIdentifier || '';\r\n        this.timestamp = typeof tx.timestamp === 'number' ? tx.timestamp : 0;\r\n        this.confirmations = tx.confirmations;\r\n        this.blockId = tx.blockId;\r\n        this.height = tx.height;\r\n        this.receivedAt = tx.receivedAt ? new Date(tx.receivedAt) : undefined;\r\n        this.asset = tx.asset || {};\r\n    }\r\n    get id() {\r\n        return this._id || 'incalculable-id';\r\n    }\r\n    get senderId() {\r\n        return lisk_cryptography_1.getAddressFromPublicKey(this.senderPublicKey);\r\n    }\r\n    get senderPublicKey() {\r\n        if (!this._senderPublicKey) {\r\n            throw new Error('senderPublicKey is required to be set before use');\r\n        }\r\n        return this._senderPublicKey;\r\n    }\r\n    get signature() {\r\n        if (!this._signature) {\r\n            throw new Error('signature is required to be set before use');\r\n        }\r\n        return this._signature;\r\n    }\r\n    get signSignature() {\r\n        return this._signSignature;\r\n    }\r\n    toJSON() {\r\n        const transaction = {\r\n            id: this._id,\r\n            blockId: this.blockId,\r\n            height: this.height,\r\n            confirmations: this.confirmations,\r\n            type: this.type,\r\n            timestamp: this.timestamp,\r\n            senderPublicKey: this._senderPublicKey || '',\r\n            senderId: this._senderPublicKey ? this.senderId : '',\r\n            fee: this.fee.toString(),\r\n            signature: this._signature,\r\n            signSignature: this.signSignature ? this.signSignature : undefined,\r\n            signatures: this.signatures,\r\n            asset: this.assetToJSON(),\r\n            receivedAt: this.receivedAt ? this.receivedAt.toISOString() : undefined,\r\n        };\r\n        return transaction;\r\n    }\r\n    stringify() {\r\n        return JSON.stringify(this.toJSON());\r\n    }\r\n    isReady() {\r\n        return (this._multisignatureStatus === MultisignatureStatus.READY ||\r\n            this._multisignatureStatus === MultisignatureStatus.NONMULTISIGNATURE);\r\n    }\r\n    getBytes() {\r\n        const transactionBytes = Buffer.concat([\r\n            this.getBasicBytes(),\r\n            this._signature ? lisk_cryptography_1.hexToBuffer(this._signature) : Buffer.alloc(0),\r\n            this._signSignature ? lisk_cryptography_1.hexToBuffer(this._signSignature) : Buffer.alloc(0),\r\n        ]);\r\n        return transactionBytes;\r\n    }\r\n    validate() {\r\n        const errors = [...this._validateSchema(), ...this.validateAsset()];\r\n        if (errors.length > 0) {\r\n            return response_1.createResponse(this.id, errors);\r\n        }\r\n        const transactionBytes = this.getBasicBytes();\r\n        if (this._networkIdentifier === undefined ||\r\n            this._networkIdentifier === '') {\r\n            throw new Error('Network identifier is required to validate a transaction ');\r\n        }\r\n        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\r\n        const transactionWithNetworkIdentifierBytes = Buffer.concat([\r\n            networkIdentifierBytes,\r\n            transactionBytes,\r\n        ]);\r\n        this._id = utils_1.getId(this.getBytes());\r\n        const { valid: signatureValid, error: verificationError, } = utils_1.validateSignature(this.senderPublicKey, this.signature, transactionWithNetworkIdentifierBytes, this.id);\r\n        if (!signatureValid && verificationError) {\r\n            errors.push(verificationError);\r\n        }\r\n        if (this.type !== this.constructor.TYPE) {\r\n            errors.push(new errors_1.TransactionError(`Invalid type`, this.id, '.type', this.type, this.constructor.TYPE));\r\n        }\r\n        return response_1.createResponse(this.id, errors);\r\n    }\r\n    verifyAgainstTransactions(_) {\r\n        return [];\r\n    }\r\n    verifyAgainstOtherTransactions(transactions) {\r\n        const errors = this.verifyAgainstTransactions(transactions);\r\n        return response_1.createResponse(this.id, errors);\r\n    }\r\n    apply(store) {\r\n        const sender = store.account.getOrDefault(this.senderId);\r\n        const errors = this._verify(sender);\r\n        const { errors: multiSigError } = this.processMultisignatures(store);\r\n        if (multiSigError) {\r\n            errors.push(...multiSigError);\r\n        }\r\n        const updatedBalance = new BigNum(sender.balance).sub(this.fee);\r\n        const updatedSender = {\r\n            ...sender,\r\n            balance: updatedBalance.toString(),\r\n            publicKey: sender.publicKey || this.senderPublicKey,\r\n        };\r\n        store.account.set(updatedSender.address, updatedSender);\r\n        const assetErrors = this.applyAsset(store);\r\n        errors.push(...assetErrors);\r\n        if (this._multisignatureStatus === MultisignatureStatus.PENDING &&\r\n            errors.length === 1 &&\r\n            errors[0] instanceof errors_1.TransactionPendingError) {\r\n            return {\r\n                id: this.id,\r\n                status: response_1.Status.PENDING,\r\n                errors,\r\n            };\r\n        }\r\n        return response_1.createResponse(this.id, errors);\r\n    }\r\n    undo(store) {\r\n        const sender = store.account.getOrDefault(this.senderId);\r\n        const updatedBalance = new BigNum(sender.balance).add(this.fee);\r\n        const updatedAccount = {\r\n            ...sender,\r\n            balance: updatedBalance.toString(),\r\n            publicKey: sender.publicKey || this.senderPublicKey,\r\n        };\r\n        const errors = updatedBalance.lte(constants_1.MAX_TRANSACTION_AMOUNT)\r\n            ? []\r\n            : [\r\n                new errors_1.TransactionError('Invalid balance amount', this.id, '.balance', sender.balance, updatedBalance.toString()),\r\n            ];\r\n        store.account.set(updatedAccount.address, updatedAccount);\r\n        const assetErrors = this.undoAsset(store);\r\n        errors.push(...assetErrors);\r\n        return response_1.createResponse(this.id, errors);\r\n    }\r\n    async prepare(store) {\r\n        await store.account.cache([\r\n            {\r\n                address: this.senderId,\r\n            },\r\n        ]);\r\n    }\r\n    addMultisignature(store, signatureObject) {\r\n        const account = store.account.get(this.senderId);\r\n        if (account.membersPublicKeys &&\r\n            !account.membersPublicKeys.includes(signatureObject.publicKey)) {\r\n            return response_1.createResponse(this.id, [\r\n                new errors_1.TransactionError(`Public Key '${signatureObject.publicKey}' is not a member for account '${account.address}'.`, this.id),\r\n            ]);\r\n        }\r\n        if (this.signatures.includes(signatureObject.signature)) {\r\n            return response_1.createResponse(this.id, [\r\n                new errors_1.TransactionError(`Signature '${signatureObject.signature}' already present in transaction.`, this.id),\r\n            ]);\r\n        }\r\n        const transactionBytes = this.getBasicBytes();\r\n        if (this._networkIdentifier === undefined ||\r\n            this._networkIdentifier === '') {\r\n            throw new Error('Network identifier is required to validate a transaction ');\r\n        }\r\n        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\r\n        const transactionWithNetworkIdentifierBytes = Buffer.concat([\r\n            networkIdentifierBytes,\r\n            transactionBytes,\r\n        ]);\r\n        const { valid } = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, transactionWithNetworkIdentifierBytes, this.id);\r\n        if (valid) {\r\n            this.signatures.push(signatureObject.signature);\r\n            return this.processMultisignatures(store);\r\n        }\r\n        const errors = valid\r\n            ? []\r\n            : [\r\n                new errors_1.TransactionError(`Failed to add signature '${signatureObject.signature}'.`, this.id, '.signatures'),\r\n            ];\r\n        return response_1.createResponse(this.id, errors);\r\n    }\r\n    addVerifiedMultisignature(signature) {\r\n        if (!this.signatures.includes(signature)) {\r\n            this.signatures.push(signature);\r\n            return response_1.createResponse(this.id, []);\r\n        }\r\n        return response_1.createResponse(this.id, [\r\n            new errors_1.TransactionError('Failed to add signature.', this.id, '.signatures'),\r\n        ]);\r\n    }\r\n    processMultisignatures(store) {\r\n        const sender = store.account.get(this.senderId);\r\n        const transactionBytes = this.getBasicBytes();\r\n        if (this._networkIdentifier === undefined ||\r\n            this._networkIdentifier === '') {\r\n            throw new Error('Network identifier is required to validate a transaction ');\r\n        }\r\n        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\r\n        const transactionWithNetworkIdentifierBytes = Buffer.concat([\r\n            networkIdentifierBytes,\r\n            transactionBytes,\r\n        ]);\r\n        const { status, errors } = utils_1.verifyMultiSignatures(this.id, sender, this.signatures, transactionWithNetworkIdentifierBytes);\r\n        this._multisignatureStatus = status;\r\n        if (this._multisignatureStatus === MultisignatureStatus.PENDING) {\r\n            return {\r\n                id: this.id,\r\n                status: response_1.Status.PENDING,\r\n                errors,\r\n            };\r\n        }\r\n        return response_1.createResponse(this.id, errors);\r\n    }\r\n    isExpired(date = new Date()) {\r\n        if (!this.receivedAt) {\r\n            this.receivedAt = new Date();\r\n        }\r\n        const timeNow = Math.floor(date.getTime() / 1000);\r\n        const timeOut = this._multisignatureStatus === MultisignatureStatus.PENDING ||\r\n            this._multisignatureStatus === MultisignatureStatus.READY\r\n            ? constants_1.UNCONFIRMED_MULTISIG_TRANSACTION_TIMEOUT\r\n            : constants_1.UNCONFIRMED_TRANSACTION_TIMEOUT;\r\n        const timeElapsed = timeNow - Math.floor(this.receivedAt.getTime() / 1000);\r\n        return timeElapsed > timeOut;\r\n    }\r\n    sign(passphrase, secondPassphrase) {\r\n        const { publicKey } = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase);\r\n        if (this._senderPublicKey !== '' && this._senderPublicKey !== publicKey) {\r\n            throw new Error('Transaction senderPublicKey does not match public key from passphrase');\r\n        }\r\n        this._senderPublicKey = publicKey;\r\n        this._signature = undefined;\r\n        this._signSignature = undefined;\r\n        if (this._networkIdentifier === undefined ||\r\n            this._networkIdentifier === '') {\r\n            throw new Error('Network identifier is required to sign a transaction ');\r\n        }\r\n        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\r\n        const transactionWithNetworkIdentifierBytes = Buffer.concat([\r\n            networkIdentifierBytes,\r\n            this.getBytes(),\r\n        ]);\r\n        this._signature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(transactionWithNetworkIdentifierBytes), passphrase);\r\n        if (secondPassphrase) {\r\n            this._signSignature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(Buffer.concat([\r\n                transactionWithNetworkIdentifierBytes,\r\n                lisk_cryptography_1.hexToBuffer(this._signature),\r\n            ])), secondPassphrase);\r\n        }\r\n        this._id = utils_1.getId(this.getBytes());\r\n    }\r\n    getBasicBytes() {\r\n        const transactionType = Buffer.alloc(constants_1.BYTESIZES.TYPE, this.type);\r\n        const transactionTimestamp = Buffer.alloc(constants_1.BYTESIZES.TIMESTAMP);\r\n        transactionTimestamp.writeIntBE(this.timestamp, 0, constants_1.BYTESIZES.TIMESTAMP);\r\n        const transactionSenderPublicKey = lisk_cryptography_1.hexToBuffer(this.senderPublicKey);\r\n        return Buffer.concat([\r\n            transactionType,\r\n            transactionTimestamp,\r\n            transactionSenderPublicKey,\r\n            this.assetToBytes(),\r\n        ]);\r\n    }\r\n    assetToJSON() {\r\n        return this.asset;\r\n    }\r\n    assetToBytes() {\r\n        return Buffer.from(JSON.stringify(this.asset), 'utf-8');\r\n    }\r\n    _verify(sender) {\r\n        const transactionBytes = this.getBasicBytes();\r\n        if (this._networkIdentifier === undefined ||\r\n            this._networkIdentifier === '') {\r\n            throw new Error('Network identifier is required to verify a transaction ');\r\n        }\r\n        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);\r\n        const transactionWithNetworkIdentifierBytes = Buffer.concat([\r\n            networkIdentifierBytes,\r\n            transactionBytes,\r\n        ]);\r\n        const secondSignatureTxBytes = Buffer.concat([\r\n            transactionWithNetworkIdentifierBytes,\r\n            lisk_cryptography_1.hexToBuffer(this.signature),\r\n        ]);\r\n        return [\r\n            utils_1.verifySenderPublicKey(this.id, sender, this.senderPublicKey),\r\n            utils_1.verifyBalance(this.id, sender, this.fee),\r\n            utils_1.verifySecondSignature(this.id, sender, this.signSignature, secondSignatureTxBytes),\r\n        ].filter(Boolean);\r\n    }\r\n    _validateSchema() {\r\n        const transaction = this.toJSON();\r\n        const schemaErrors = lisk_validator_1.validator.validate(schemas.baseTransaction, transaction);\r\n        const errors = errors_1.convertToTransactionError(this.id, schemaErrors);\r\n        if (!errors.find((err) => err.dataPath === '.senderPublicKey')) {\r\n            const senderIdError = utils_1.validateSenderIdAndPublicKey(this.id, this.senderId, this.senderPublicKey);\r\n            if (senderIdError) {\r\n                errors.push(senderIdError);\r\n            }\r\n        }\r\n        return errors;\r\n    }\r\n}\r\nexports.BaseTransaction = BaseTransaction;\r\nBaseTransaction.FEE = '0';\r\n//# sourceMappingURL=base_transaction.js.map"]},"metadata":{},"sourceType":"script"}