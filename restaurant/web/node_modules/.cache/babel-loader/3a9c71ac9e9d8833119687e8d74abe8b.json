{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BigNum = require(\"@liskhq/bignum\");\n\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nconst base_transaction_1 = require(\"./base_transaction\");\n\nconst constants_1 = require(\"./constants\");\n\nconst errors_1 = require(\"./errors\");\n\nconst utils_1 = require(\"./utils\");\n\nexports.transferAssetFormatSchema = {\n  type: 'object',\n  properties: {\n    data: {\n      type: 'string',\n      format: 'transferData',\n      maxLength: 64\n    }\n  }\n};\n\nclass TransferTransaction extends base_transaction_1.BaseTransaction {\n  constructor(rawTransaction) {\n    super(rawTransaction);\n    const tx = typeof rawTransaction === 'object' && rawTransaction !== null ? rawTransaction : {};\n    this.asset = tx.asset || {};\n  }\n\n  assetToBytes() {\n    const {\n      data\n    } = this.asset;\n    return data ? Buffer.from(data, 'utf8') : Buffer.alloc(0);\n  }\n\n  async prepare(store) {\n    await store.account.cache([{\n      address: this.senderId\n    }, {\n      address: this.recipientId\n    }]);\n  }\n\n  verifyAgainstTransactions(_) {\n    return [];\n  }\n\n  validateAsset() {\n    utils_1.validator.validate(exports.transferAssetFormatSchema, this.asset);\n    const errors = errors_1.convertToAssetError(this.id, utils_1.validator.errors);\n\n    if (!utils_1.validateTransferAmount(this.amount.toString())) {\n      errors.push(new errors_1.TransactionError('Amount must be a valid number in string format.', this.id, '.amount', this.amount.toString()));\n    }\n\n    if (!this.recipientId) {\n      errors.push(new errors_1.TransactionError('`recipientId` must be provided.', this.id, '.recipientId'));\n    }\n\n    try {\n      utils_1.validateAddress(this.recipientId);\n    } catch (error) {\n      errors.push(new errors_1.TransactionError(error.message, this.id, '.recipientId', this.recipientId));\n    }\n\n    if (this.recipientPublicKey) {\n      const calculatedAddress = lisk_cryptography_1.getAddressFromPublicKey(this.recipientPublicKey);\n\n      if (this.recipientId !== calculatedAddress) {\n        errors.push(new errors_1.TransactionError('recipientId does not match recipientPublicKey.', this.id, '.recipientId', this.recipientId, calculatedAddress));\n      }\n    }\n\n    return errors;\n  }\n\n  applyAsset(store) {\n    const errors = [];\n    const sender = store.account.get(this.senderId);\n    const balanceError = utils_1.verifyAmountBalance(this.id, sender, this.amount, this.fee);\n\n    if (balanceError) {\n      errors.push(balanceError);\n    }\n\n    const updatedSenderBalance = new BigNum(sender.balance).sub(this.amount);\n    const updatedSender = Object.assign({}, sender, {\n      balance: updatedSenderBalance.toString()\n    });\n    store.account.set(updatedSender.address, updatedSender);\n    const recipient = store.account.getOrDefault(this.recipientId);\n    const updatedRecipientBalance = new BigNum(recipient.balance).add(this.amount);\n\n    if (updatedRecipientBalance.gt(constants_1.MAX_TRANSACTION_AMOUNT)) {\n      errors.push(new errors_1.TransactionError('Invalid amount', this.id, '.amount', this.amount.toString()));\n    }\n\n    const updatedRecipient = Object.assign({}, recipient, {\n      balance: updatedRecipientBalance.toString()\n    });\n    store.account.set(updatedRecipient.address, updatedRecipient);\n    return errors;\n  }\n\n  undoAsset(store) {\n    const errors = [];\n    const sender = store.account.get(this.senderId);\n    const updatedSenderBalance = new BigNum(sender.balance).add(this.amount);\n\n    if (updatedSenderBalance.gt(constants_1.MAX_TRANSACTION_AMOUNT)) {\n      errors.push(new errors_1.TransactionError('Invalid amount', this.id, '.amount', this.amount.toString()));\n    }\n\n    const updatedSender = Object.assign({}, sender, {\n      balance: updatedSenderBalance.toString()\n    });\n    store.account.set(updatedSender.address, updatedSender);\n    const recipient = store.account.getOrDefault(this.recipientId);\n    const balanceError = utils_1.verifyBalance(this.id, recipient, this.amount);\n\n    if (balanceError) {\n      errors.push(balanceError);\n    }\n\n    const updatedRecipientBalance = new BigNum(recipient.balance).sub(this.amount);\n    const updatedRecipient = Object.assign({}, recipient, {\n      balance: updatedRecipientBalance.toString()\n    });\n    store.account.set(updatedRecipient.address, updatedRecipient);\n    return errors;\n  }\n\n  assetFromSync(raw) {\n    if (raw.tf_data) {\n      const data = raw.tf_data.toString('utf8');\n      return {\n        data\n      };\n    }\n\n    return undefined;\n  }\n\n}\n\nTransferTransaction.TYPE = 0;\nTransferTransaction.FEE = constants_1.TRANSFER_FEE.toString();\nexports.TransferTransaction = TransferTransaction;","map":{"version":3,"sources":["../src/0_transfer_transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BigNum = require(\"@liskhq/bignum\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst base_transaction_1 = require(\"./base_transaction\");\nconst constants_1 = require(\"./constants\");\nconst errors_1 = require(\"./errors\");\nconst utils_1 = require(\"./utils\");\nexports.transferAssetFormatSchema = {\n    type: 'object',\n    properties: {\n        data: {\n            type: 'string',\n            format: 'transferData',\n            maxLength: 64,\n        },\n    },\n};\nclass TransferTransaction extends base_transaction_1.BaseTransaction {\n    constructor(rawTransaction) {\n        super(rawTransaction);\n        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null\n            ? rawTransaction\n            : {});\n        this.asset = (tx.asset || {});\n    }\n    assetToBytes() {\n        const { data } = this.asset;\n        return data ? Buffer.from(data, 'utf8') : Buffer.alloc(0);\n    }\n    async prepare(store) {\n        await store.account.cache([\n            {\n                address: this.senderId,\n            },\n            {\n                address: this.recipientId,\n            },\n        ]);\n    }\n    verifyAgainstTransactions(_) {\n        return [];\n    }\n    validateAsset() {\n        utils_1.validator.validate(exports.transferAssetFormatSchema, this.asset);\n        const errors = errors_1.convertToAssetError(this.id, utils_1.validator.errors);\n        if (!utils_1.validateTransferAmount(this.amount.toString())) {\n            errors.push(new errors_1.TransactionError('Amount must be a valid number in string format.', this.id, '.amount', this.amount.toString()));\n        }\n        if (!this.recipientId) {\n            errors.push(new errors_1.TransactionError('`recipientId` must be provided.', this.id, '.recipientId'));\n        }\n        try {\n            utils_1.validateAddress(this.recipientId);\n        }\n        catch (error) {\n            errors.push(new errors_1.TransactionError(error.message, this.id, '.recipientId', this.recipientId));\n        }\n        if (this.recipientPublicKey) {\n            const calculatedAddress = lisk_cryptography_1.getAddressFromPublicKey(this.recipientPublicKey);\n            if (this.recipientId !== calculatedAddress) {\n                errors.push(new errors_1.TransactionError('recipientId does not match recipientPublicKey.', this.id, '.recipientId', this.recipientId, calculatedAddress));\n            }\n        }\n        return errors;\n    }\n    applyAsset(store) {\n        const errors = [];\n        const sender = store.account.get(this.senderId);\n        const balanceError = utils_1.verifyAmountBalance(this.id, sender, this.amount, this.fee);\n        if (balanceError) {\n            errors.push(balanceError);\n        }\n        const updatedSenderBalance = new BigNum(sender.balance).sub(this.amount);\n        const updatedSender = Object.assign({}, sender, { balance: updatedSenderBalance.toString() });\n        store.account.set(updatedSender.address, updatedSender);\n        const recipient = store.account.getOrDefault(this.recipientId);\n        const updatedRecipientBalance = new BigNum(recipient.balance).add(this.amount);\n        if (updatedRecipientBalance.gt(constants_1.MAX_TRANSACTION_AMOUNT)) {\n            errors.push(new errors_1.TransactionError('Invalid amount', this.id, '.amount', this.amount.toString()));\n        }\n        const updatedRecipient = Object.assign({}, recipient, { balance: updatedRecipientBalance.toString() });\n        store.account.set(updatedRecipient.address, updatedRecipient);\n        return errors;\n    }\n    undoAsset(store) {\n        const errors = [];\n        const sender = store.account.get(this.senderId);\n        const updatedSenderBalance = new BigNum(sender.balance).add(this.amount);\n        if (updatedSenderBalance.gt(constants_1.MAX_TRANSACTION_AMOUNT)) {\n            errors.push(new errors_1.TransactionError('Invalid amount', this.id, '.amount', this.amount.toString()));\n        }\n        const updatedSender = Object.assign({}, sender, { balance: updatedSenderBalance.toString() });\n        store.account.set(updatedSender.address, updatedSender);\n        const recipient = store.account.getOrDefault(this.recipientId);\n        const balanceError = utils_1.verifyBalance(this.id, recipient, this.amount);\n        if (balanceError) {\n            errors.push(balanceError);\n        }\n        const updatedRecipientBalance = new BigNum(recipient.balance).sub(this.amount);\n        const updatedRecipient = Object.assign({}, recipient, { balance: updatedRecipientBalance.toString() });\n        store.account.set(updatedRecipient.address, updatedRecipient);\n        return errors;\n    }\n    assetFromSync(raw) {\n        if (raw.tf_data) {\n            const data = raw.tf_data.toString('utf8');\n            return { data };\n        }\n        return undefined;\n    }\n}\nTransferTransaction.TYPE = 0;\nTransferTransaction.FEE = constants_1.TRANSFER_FEE.toString();\nexports.TransferTransaction = TransferTransaction;\n//# sourceMappingURL=0_transfer_transaction.js.map"]},"metadata":{},"sourceType":"script"}