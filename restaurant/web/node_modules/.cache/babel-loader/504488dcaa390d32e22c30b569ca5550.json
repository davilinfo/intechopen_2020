{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BigNum = require(\"@liskhq/bignum\");\n\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nconst base_transaction_1 = require(\"./base_transaction\");\n\nconst constants_1 = require(\"./constants\");\n\nconst errors_1 = require(\"./errors\");\n\nconst utils_1 = require(\"./utils\");\n\nconst validation_1 = require(\"./utils/validation\");\n\nconst PREFIX_UPVOTE = '+';\nconst PREFIX_UNVOTE = '-';\nconst MAX_VOTE_PER_ACCOUNT = 101;\nconst MIN_VOTE_PER_TX = 1;\nconst MAX_VOTE_PER_TX = 33;\nexports.voteAssetFormatSchema = {\n  type: 'object',\n  required: ['votes'],\n  properties: {\n    votes: {\n      type: 'array',\n      minItems: MIN_VOTE_PER_TX,\n      maxItems: MAX_VOTE_PER_TX,\n      items: {\n        type: 'string',\n        format: 'signedPublicKey'\n      },\n      uniqueSignedPublicKeys: true\n    }\n  }\n};\n\nclass VoteTransaction extends base_transaction_1.BaseTransaction {\n  constructor(rawTransaction) {\n    super(rawTransaction);\n    const tx = typeof rawTransaction === 'object' && rawTransaction !== null ? rawTransaction : {};\n    this.asset = tx.asset || {};\n    this.containsUniqueData = true;\n  }\n\n  assetToBytes() {\n    return Buffer.from(this.asset.votes.join(''), 'utf8');\n  }\n\n  async prepare(store) {\n    const publicKeyObjectArray = this.asset.votes.map(pkWithAction => {\n      const publicKey = pkWithAction.slice(1);\n      return {\n        publicKey\n      };\n    });\n    const filterArray = [{\n      address: this.senderId\n    }, ...publicKeyObjectArray];\n    await store.account.cache(filterArray);\n  }\n\n  verifyAgainstTransactions(transactions) {\n    const sameTypeTransactions = transactions.filter(tx => tx.senderPublicKey === this.senderPublicKey && tx.type === this.type).map(tx => new VoteTransaction(tx));\n    const publicKeys = this.asset.votes.map(vote => vote.substring(1));\n    return sameTypeTransactions.reduce((previous, tx) => {\n      const conflictingVotes = tx.asset.votes.map(vote => vote.substring(1)).filter(publicKey => publicKeys.includes(publicKey));\n\n      if (conflictingVotes.length > 0) {\n        return [...previous, new errors_1.TransactionError(`Transaction includes conflicting votes: ${conflictingVotes.toString()}`, this.id, '.asset.votes')];\n      }\n\n      return previous;\n    }, []);\n  }\n\n  validateAsset() {\n    validation_1.validator.validate(exports.voteAssetFormatSchema, this.asset);\n    const errors = errors_1.convertToAssetError(this.id, validation_1.validator.errors);\n\n    if (!this.amount.eq(0)) {\n      errors.push(new errors_1.TransactionError('Amount must be zero for vote transaction', this.id, '.amount', this.amount.toString(), '0'));\n    }\n\n    try {\n      validation_1.validateAddress(this.recipientId);\n    } catch (err) {\n      errors.push(new errors_1.TransactionError('RecipientId must be set for vote transaction', this.id, '.recipientId', this.recipientId));\n    }\n\n    if (this.recipientPublicKey && this.recipientId !== lisk_cryptography_1.getAddressFromPublicKey(this.recipientPublicKey)) {\n      errors.push(new errors_1.TransactionError('recipientId does not match recipientPublicKey.', this.id, '.recipientId'));\n    }\n\n    return errors;\n  }\n\n  applyAsset(store) {\n    const errors = [];\n    const sender = store.account.get(this.senderId);\n    const balanceError = utils_1.verifyAmountBalance(this.id, sender, this.amount, this.fee);\n\n    if (balanceError) {\n      errors.push(balanceError);\n    }\n\n    const updatedSenderBalance = new BigNum(sender.balance).sub(this.amount);\n    this.asset.votes.forEach(actionVotes => {\n      const vote = actionVotes.substring(1);\n      const voteAccount = store.account.find(account => account.publicKey === vote);\n\n      if (!voteAccount || voteAccount && (voteAccount.username === undefined || voteAccount.username === '' || voteAccount.username === null)) {\n        errors.push(new errors_1.TransactionError(`${vote} is not a delegate.`, this.id, '.asset.votes'));\n      }\n    });\n    const senderVotes = sender.votedDelegatesPublicKeys || [];\n    this.asset.votes.forEach(vote => {\n      const action = vote.charAt(0);\n      const publicKey = vote.substring(1);\n\n      if (action === PREFIX_UPVOTE && senderVotes.includes(publicKey)) {\n        errors.push(new errors_1.TransactionError(`${publicKey} is already voted.`, this.id, '.asset.votes'));\n      } else if (action === PREFIX_UNVOTE && !senderVotes.includes(publicKey)) {\n        errors.push(new errors_1.TransactionError(`${publicKey} is not voted.`, this.id, '.asset.votes'));\n      }\n    });\n    const upvotes = this.asset.votes.filter(vote => vote.charAt(0) === PREFIX_UPVOTE).map(vote => vote.substring(1));\n    const unvotes = this.asset.votes.filter(vote => vote.charAt(0) === PREFIX_UNVOTE).map(vote => vote.substring(1));\n    const originalVotes = sender.votedDelegatesPublicKeys || [];\n    const votedDelegatesPublicKeys = [...originalVotes, ...upvotes].filter(vote => !unvotes.includes(vote));\n\n    if (votedDelegatesPublicKeys.length > MAX_VOTE_PER_ACCOUNT) {\n      errors.push(new errors_1.TransactionError(`Vote cannot exceed ${MAX_VOTE_PER_ACCOUNT} but has ${votedDelegatesPublicKeys.length}.`, this.id, '.asset.votes', votedDelegatesPublicKeys.length.toString(), MAX_VOTE_PER_ACCOUNT));\n    }\n\n    const updatedSender = Object.assign({}, sender, {\n      balance: updatedSenderBalance.toString(),\n      votedDelegatesPublicKeys\n    });\n    store.account.set(updatedSender.address, updatedSender);\n    return errors;\n  }\n\n  undoAsset(store) {\n    const errors = [];\n    const sender = store.account.get(this.senderId);\n    const updatedSenderBalance = new BigNum(sender.balance).add(this.amount);\n\n    if (updatedSenderBalance.gt(constants_1.MAX_TRANSACTION_AMOUNT)) {\n      errors.push(new errors_1.TransactionError('Invalid amount', this.id, '.amount', this.amount.toString()));\n    }\n\n    const upvotes = this.asset.votes.filter(vote => vote.charAt(0) === PREFIX_UPVOTE).map(vote => vote.substring(1));\n    const unvotes = this.asset.votes.filter(vote => vote.charAt(0) === PREFIX_UNVOTE).map(vote => vote.substring(1));\n    const originalVotes = sender.votedDelegatesPublicKeys || [];\n    const votedDelegatesPublicKeys = [...originalVotes, ...unvotes].filter(vote => !upvotes.includes(vote));\n\n    if (votedDelegatesPublicKeys.length > MAX_VOTE_PER_ACCOUNT) {\n      errors.push(new errors_1.TransactionError(`Vote cannot exceed ${MAX_VOTE_PER_ACCOUNT} but has ${votedDelegatesPublicKeys.length}.`, this.id, '.asset.votes', votedDelegatesPublicKeys.length.toString(), MAX_VOTE_PER_ACCOUNT));\n    }\n\n    const updatedSender = Object.assign({}, sender, {\n      balance: updatedSenderBalance.toString(),\n      votedDelegatesPublicKeys\n    });\n    store.account.set(updatedSender.address, updatedSender);\n    return errors;\n  }\n\n  assetFromSync(raw) {\n    if (!raw.v_votes) {\n      return undefined;\n    }\n\n    const votes = raw.v_votes.split(',');\n    return {\n      votes\n    };\n  }\n\n}\n\nVoteTransaction.TYPE = 3;\nVoteTransaction.FEE = constants_1.VOTE_FEE.toString();\nexports.VoteTransaction = VoteTransaction;","map":{"version":3,"sources":["../src/3_vote_transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BigNum = require(\"@liskhq/bignum\");\r\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\r\nconst base_transaction_1 = require(\"./base_transaction\");\r\nconst constants_1 = require(\"./constants\");\r\nconst errors_1 = require(\"./errors\");\r\nconst utils_1 = require(\"./utils\");\r\nconst validation_1 = require(\"./utils/validation\");\r\nconst PREFIX_UPVOTE = '+';\r\nconst PREFIX_UNVOTE = '-';\r\nconst MAX_VOTE_PER_ACCOUNT = 101;\r\nconst MIN_VOTE_PER_TX = 1;\r\nconst MAX_VOTE_PER_TX = 33;\r\nexports.voteAssetFormatSchema = {\r\n    type: 'object',\r\n    required: ['votes'],\r\n    properties: {\r\n        votes: {\r\n            type: 'array',\r\n            minItems: MIN_VOTE_PER_TX,\r\n            maxItems: MAX_VOTE_PER_TX,\r\n            items: {\r\n                type: 'string',\r\n                format: 'signedPublicKey',\r\n            },\r\n            uniqueSignedPublicKeys: true,\r\n        },\r\n    },\r\n};\r\nclass VoteTransaction extends base_transaction_1.BaseTransaction {\r\n    constructor(rawTransaction) {\r\n        super(rawTransaction);\r\n        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null\r\n            ? rawTransaction\r\n            : {});\r\n        this.asset = (tx.asset || {});\r\n        this.containsUniqueData = true;\r\n    }\r\n    assetToBytes() {\r\n        return Buffer.from(this.asset.votes.join(''), 'utf8');\r\n    }\r\n    async prepare(store) {\r\n        const publicKeyObjectArray = this.asset.votes.map(pkWithAction => {\r\n            const publicKey = pkWithAction.slice(1);\r\n            return {\r\n                publicKey,\r\n            };\r\n        });\r\n        const filterArray = [\r\n            {\r\n                address: this.senderId,\r\n            },\r\n            ...publicKeyObjectArray,\r\n        ];\r\n        await store.account.cache(filterArray);\r\n    }\r\n    verifyAgainstTransactions(transactions) {\r\n        const sameTypeTransactions = transactions\r\n            .filter(tx => tx.senderPublicKey === this.senderPublicKey && tx.type === this.type)\r\n            .map(tx => new VoteTransaction(tx));\r\n        const publicKeys = this.asset.votes.map(vote => vote.substring(1));\r\n        return sameTypeTransactions.reduce((previous, tx) => {\r\n            const conflictingVotes = tx.asset.votes\r\n                .map(vote => vote.substring(1))\r\n                .filter(publicKey => publicKeys.includes(publicKey));\r\n            if (conflictingVotes.length > 0) {\r\n                return [\r\n                    ...previous,\r\n                    new errors_1.TransactionError(`Transaction includes conflicting votes: ${conflictingVotes.toString()}`, this.id, '.asset.votes'),\r\n                ];\r\n            }\r\n            return previous;\r\n        }, []);\r\n    }\r\n    validateAsset() {\r\n        validation_1.validator.validate(exports.voteAssetFormatSchema, this.asset);\r\n        const errors = errors_1.convertToAssetError(this.id, validation_1.validator.errors);\r\n        if (!this.amount.eq(0)) {\r\n            errors.push(new errors_1.TransactionError('Amount must be zero for vote transaction', this.id, '.amount', this.amount.toString(), '0'));\r\n        }\r\n        try {\r\n            validation_1.validateAddress(this.recipientId);\r\n        }\r\n        catch (err) {\r\n            errors.push(new errors_1.TransactionError('RecipientId must be set for vote transaction', this.id, '.recipientId', this.recipientId));\r\n        }\r\n        if (this.recipientPublicKey &&\r\n            this.recipientId !== lisk_cryptography_1.getAddressFromPublicKey(this.recipientPublicKey)) {\r\n            errors.push(new errors_1.TransactionError('recipientId does not match recipientPublicKey.', this.id, '.recipientId'));\r\n        }\r\n        return errors;\r\n    }\r\n    applyAsset(store) {\r\n        const errors = [];\r\n        const sender = store.account.get(this.senderId);\r\n        const balanceError = utils_1.verifyAmountBalance(this.id, sender, this.amount, this.fee);\r\n        if (balanceError) {\r\n            errors.push(balanceError);\r\n        }\r\n        const updatedSenderBalance = new BigNum(sender.balance).sub(this.amount);\r\n        this.asset.votes.forEach(actionVotes => {\r\n            const vote = actionVotes.substring(1);\r\n            const voteAccount = store.account.find(account => account.publicKey === vote);\r\n            if (!voteAccount ||\r\n                (voteAccount &&\r\n                    (voteAccount.username === undefined ||\r\n                        voteAccount.username === '' ||\r\n                        voteAccount.username === null))) {\r\n                errors.push(new errors_1.TransactionError(`${vote} is not a delegate.`, this.id, '.asset.votes'));\r\n            }\r\n        });\r\n        const senderVotes = sender.votedDelegatesPublicKeys || [];\r\n        this.asset.votes.forEach(vote => {\r\n            const action = vote.charAt(0);\r\n            const publicKey = vote.substring(1);\r\n            if (action === PREFIX_UPVOTE && senderVotes.includes(publicKey)) {\r\n                errors.push(new errors_1.TransactionError(`${publicKey} is already voted.`, this.id, '.asset.votes'));\r\n            }\r\n            else if (action === PREFIX_UNVOTE && !senderVotes.includes(publicKey)) {\r\n                errors.push(new errors_1.TransactionError(`${publicKey} is not voted.`, this.id, '.asset.votes'));\r\n            }\r\n        });\r\n        const upvotes = this.asset.votes\r\n            .filter(vote => vote.charAt(0) === PREFIX_UPVOTE)\r\n            .map(vote => vote.substring(1));\r\n        const unvotes = this.asset.votes\r\n            .filter(vote => vote.charAt(0) === PREFIX_UNVOTE)\r\n            .map(vote => vote.substring(1));\r\n        const originalVotes = sender.votedDelegatesPublicKeys || [];\r\n        const votedDelegatesPublicKeys = [\r\n            ...originalVotes,\r\n            ...upvotes,\r\n        ].filter(vote => !unvotes.includes(vote));\r\n        if (votedDelegatesPublicKeys.length > MAX_VOTE_PER_ACCOUNT) {\r\n            errors.push(new errors_1.TransactionError(`Vote cannot exceed ${MAX_VOTE_PER_ACCOUNT} but has ${votedDelegatesPublicKeys.length}.`, this.id, '.asset.votes', votedDelegatesPublicKeys.length.toString(), MAX_VOTE_PER_ACCOUNT));\r\n        }\r\n        const updatedSender = Object.assign({}, sender, { balance: updatedSenderBalance.toString(), votedDelegatesPublicKeys });\r\n        store.account.set(updatedSender.address, updatedSender);\r\n        return errors;\r\n    }\r\n    undoAsset(store) {\r\n        const errors = [];\r\n        const sender = store.account.get(this.senderId);\r\n        const updatedSenderBalance = new BigNum(sender.balance).add(this.amount);\r\n        if (updatedSenderBalance.gt(constants_1.MAX_TRANSACTION_AMOUNT)) {\r\n            errors.push(new errors_1.TransactionError('Invalid amount', this.id, '.amount', this.amount.toString()));\r\n        }\r\n        const upvotes = this.asset.votes\r\n            .filter(vote => vote.charAt(0) === PREFIX_UPVOTE)\r\n            .map(vote => vote.substring(1));\r\n        const unvotes = this.asset.votes\r\n            .filter(vote => vote.charAt(0) === PREFIX_UNVOTE)\r\n            .map(vote => vote.substring(1));\r\n        const originalVotes = sender.votedDelegatesPublicKeys || [];\r\n        const votedDelegatesPublicKeys = [\r\n            ...originalVotes,\r\n            ...unvotes,\r\n        ].filter(vote => !upvotes.includes(vote));\r\n        if (votedDelegatesPublicKeys.length > MAX_VOTE_PER_ACCOUNT) {\r\n            errors.push(new errors_1.TransactionError(`Vote cannot exceed ${MAX_VOTE_PER_ACCOUNT} but has ${votedDelegatesPublicKeys.length}.`, this.id, '.asset.votes', votedDelegatesPublicKeys.length.toString(), MAX_VOTE_PER_ACCOUNT));\r\n        }\r\n        const updatedSender = Object.assign({}, sender, { balance: updatedSenderBalance.toString(), votedDelegatesPublicKeys });\r\n        store.account.set(updatedSender.address, updatedSender);\r\n        return errors;\r\n    }\r\n    assetFromSync(raw) {\r\n        if (!raw.v_votes) {\r\n            return undefined;\r\n        }\r\n        const votes = raw.v_votes.split(',');\r\n        return { votes };\r\n    }\r\n}\r\nVoteTransaction.TYPE = 3;\r\nVoteTransaction.FEE = constants_1.VOTE_FEE.toString();\r\nexports.VoteTransaction = VoteTransaction;\r\n//# sourceMappingURL=3_vote_transaction.js.map"]},"metadata":{},"sourceType":"script"}