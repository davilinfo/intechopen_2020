{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BigNum = require(\"@liskhq/bignum\");\n\nconst base_transaction_1 = require(\"../base_transaction\");\n\nconst errors_1 = require(\"../errors\");\n\nconst format_1 = require(\"../utils/format\");\n\nconst sign_and_validate_1 = require(\"./sign_and_validate\");\n\nexports.verifySenderPublicKey = (id, sender, publicKey) => sender.publicKey && sender.publicKey !== publicKey ? new errors_1.TransactionError('Invalid sender publicKey', id, '.senderPublicKey', publicKey, sender.publicKey) : undefined;\n\nexports.verifySenderId = (id, sender, address) => sender.address.toUpperCase() !== address.toUpperCase() ? new errors_1.TransactionError('Invalid sender address', id, '.senderId', address.toUpperCase(), sender.address.toUpperCase()) : undefined;\n\nexports.verifyBalance = (id, account, amount) => new BigNum(account.balance).lt(new BigNum(amount)) ? new errors_1.TransactionError(`Account does not have enough LSK: ${account.address}, balance: ${format_1.convertBeddowsToLSK(account.balance.toString())}`, id, '.balance') : undefined;\n\nexports.verifyAmountBalance = (id, account, amount, fee) => {\n  const balance = new BigNum(account.balance);\n\n  if (balance.gte(0) && balance.lt(new BigNum(amount))) {\n    return new errors_1.TransactionError(`Account does not have enough LSK: ${account.address}, balance: ${format_1.convertBeddowsToLSK(balance.plus(fee).toString())}`, id, '.balance');\n  }\n\n  return undefined;\n};\n\nexports.verifySecondSignature = (id, sender, signSignature, transactionBytes) => {\n  if (!sender.secondPublicKey && signSignature) {\n    return new errors_1.TransactionError('Sender does not have a secondPublicKey', id, '.signSignature');\n  }\n\n  if (!sender.secondPublicKey) {\n    return undefined;\n  }\n\n  if (!signSignature) {\n    return new errors_1.TransactionError('Missing signSignature', id, '.signSignature');\n  }\n\n  const {\n    valid,\n    error\n  } = sign_and_validate_1.validateSignature(sender.secondPublicKey, signSignature, transactionBytes, id);\n\n  if (valid) {\n    return undefined;\n  }\n\n  return error;\n};\n\nconst isMultisignatureAccount = account => !!(account.membersPublicKeys && account.membersPublicKeys.length > 0 && account.multiMin);\n\nexports.verifyMultiSignatures = (id, sender, signatures, transactionBytes) => {\n  if (!isMultisignatureAccount(sender) && signatures.length > 0) {\n    return {\n      status: base_transaction_1.MultisignatureStatus.FAIL,\n      errors: [new errors_1.TransactionError('Sender is not a multisignature account', id, '.signatures')]\n    };\n  }\n\n  if (!isMultisignatureAccount(sender)) {\n    return {\n      status: base_transaction_1.MultisignatureStatus.NONMULTISIGNATURE,\n      errors: []\n    };\n  }\n\n  const {\n    valid,\n    errors\n  } = sign_and_validate_1.validateMultisignatures(sender.membersPublicKeys, signatures, sender.multiMin, transactionBytes, id);\n\n  if (valid) {\n    return {\n      status: base_transaction_1.MultisignatureStatus.READY,\n      errors: []\n    };\n  }\n\n  if (errors && errors.length === 1 && errors[0] instanceof errors_1.TransactionPendingError) {\n    return {\n      status: base_transaction_1.MultisignatureStatus.PENDING,\n      errors\n    };\n  }\n\n  return {\n    status: base_transaction_1.MultisignatureStatus.FAIL,\n    errors: errors || []\n  };\n};","map":{"version":3,"sources":["../../src/utils/verify.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BigNum = require(\"@liskhq/bignum\");\r\nconst base_transaction_1 = require(\"../base_transaction\");\r\nconst errors_1 = require(\"../errors\");\r\nconst format_1 = require(\"../utils/format\");\r\nconst sign_and_validate_1 = require(\"./sign_and_validate\");\r\nexports.verifySenderPublicKey = (id, sender, publicKey) => sender.publicKey && sender.publicKey !== publicKey\r\n    ? new errors_1.TransactionError('Invalid sender publicKey', id, '.senderPublicKey', publicKey, sender.publicKey)\r\n    : undefined;\r\nexports.verifySenderId = (id, sender, address) => sender.address.toUpperCase() !== address.toUpperCase()\r\n    ? new errors_1.TransactionError('Invalid sender address', id, '.senderId', address.toUpperCase(), sender.address.toUpperCase())\r\n    : undefined;\r\nexports.verifyBalance = (id, account, amount) => new BigNum(account.balance).lt(new BigNum(amount))\r\n    ? new errors_1.TransactionError(`Account does not have enough LSK: ${account.address}, balance: ${format_1.convertBeddowsToLSK(account.balance.toString())}`, id, '.balance')\r\n    : undefined;\r\nexports.verifyAmountBalance = (id, account, amount, fee) => {\r\n    const balance = new BigNum(account.balance);\r\n    if (balance.gte(0) && balance.lt(new BigNum(amount))) {\r\n        return new errors_1.TransactionError(`Account does not have enough LSK: ${account.address}, balance: ${format_1.convertBeddowsToLSK(balance.plus(fee).toString())}`, id, '.balance');\r\n    }\r\n    return undefined;\r\n};\r\nexports.verifySecondSignature = (id, sender, signSignature, transactionBytes) => {\r\n    if (!sender.secondPublicKey && signSignature) {\r\n        return new errors_1.TransactionError('Sender does not have a secondPublicKey', id, '.signSignature');\r\n    }\r\n    if (!sender.secondPublicKey) {\r\n        return undefined;\r\n    }\r\n    if (!signSignature) {\r\n        return new errors_1.TransactionError('Missing signSignature', id, '.signSignature');\r\n    }\r\n    const { valid, error } = sign_and_validate_1.validateSignature(sender.secondPublicKey, signSignature, transactionBytes, id);\r\n    if (valid) {\r\n        return undefined;\r\n    }\r\n    return error;\r\n};\r\nconst isMultisignatureAccount = (account) => !!(account.membersPublicKeys &&\r\n    account.membersPublicKeys.length > 0 &&\r\n    account.multiMin);\r\nexports.verifyMultiSignatures = (id, sender, signatures, transactionBytes) => {\r\n    if (!isMultisignatureAccount(sender) && signatures.length > 0) {\r\n        return {\r\n            status: base_transaction_1.MultisignatureStatus.FAIL,\r\n            errors: [\r\n                new errors_1.TransactionError('Sender is not a multisignature account', id, '.signatures'),\r\n            ],\r\n        };\r\n    }\r\n    if (!isMultisignatureAccount(sender)) {\r\n        return {\r\n            status: base_transaction_1.MultisignatureStatus.NONMULTISIGNATURE,\r\n            errors: [],\r\n        };\r\n    }\r\n    const { valid, errors } = sign_and_validate_1.validateMultisignatures(sender.membersPublicKeys, signatures, sender.multiMin, transactionBytes, id);\r\n    if (valid) {\r\n        return {\r\n            status: base_transaction_1.MultisignatureStatus.READY,\r\n            errors: [],\r\n        };\r\n    }\r\n    if (errors &&\r\n        errors.length === 1 &&\r\n        errors[0] instanceof errors_1.TransactionPendingError) {\r\n        return {\r\n            status: base_transaction_1.MultisignatureStatus.PENDING,\r\n            errors,\r\n        };\r\n    }\r\n    return {\r\n        status: base_transaction_1.MultisignatureStatus.FAIL,\r\n        errors: errors || [],\r\n    };\r\n};\r\n//# sourceMappingURL=verify.js.map"]},"metadata":{},"sourceType":"script"}