{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst cryptography = require(\"@liskhq/lisk-cryptography\");\n\nconst errors_1 = require(\"../errors\");\n\nexports.validateSignature = (publicKey, signature, transactionBytes, id) => {\n  const transactionHash = cryptography.hash(transactionBytes);\n  const valid = cryptography.verifyData(transactionHash, signature, publicKey);\n  return {\n    valid,\n    error: !valid ? new errors_1.TransactionError(`Failed to validate signature ${signature}`, id, '.signature') : undefined\n  };\n};\n\nexports.signaturesAreUnique = signatures => {\n  const uniqueSignatures = [...new Set(signatures)];\n\n  if (uniqueSignatures.length !== signatures.length) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.checkPublicKeySignatureUniqueness = (publicKeys, signatures, transactionBytes, id) => {\n  const checkedPublicKeys = new Set();\n  const validSignatures = new Set();\n  publicKeys.forEach(publicKey => {\n    signatures.forEach(signature => {\n      if (checkedPublicKeys.has(publicKey) || validSignatures.has(signature)) {\n        return;\n      }\n\n      const {\n        valid: signatureValid\n      } = exports.validateSignature(publicKey, signature, transactionBytes, id);\n\n      if (signatureValid) {\n        checkedPublicKeys.add(publicKey);\n        validSignatures.add(signature);\n      }\n    });\n  });\n  return validSignatures;\n};\n\nexports.validateMultisignatures = (publicKeys, signatures, minimumValidations, transactionBytes, id) => {\n  if (!exports.signaturesAreUnique(signatures)) {\n    return {\n      valid: false,\n      errors: [new errors_1.TransactionError('Encountered duplicate signature in transaction', id, '.signatures')]\n    };\n  }\n\n  const validSignatures = exports.checkPublicKeySignatureUniqueness(publicKeys, signatures, transactionBytes, id);\n  const invalidTransactionSignatures = signatures.filter(signature => !validSignatures.has(signature));\n\n  if (signatures.length < minimumValidations) {\n    return {\n      valid: false,\n      errors: [new errors_1.TransactionPendingError(`Missing signatures`, id, '.signatures')]\n    };\n  }\n\n  return {\n    valid: validSignatures.size >= minimumValidations && invalidTransactionSignatures.length === 0,\n    errors: invalidTransactionSignatures.length > 0 ? invalidTransactionSignatures.map(signature => new errors_1.TransactionError(`Failed to validate signature ${signature}`, id, '.signatures')) : []\n  };\n};","map":{"version":3,"sources":["../../src/utils/sign_and_validate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cryptography = require(\"@liskhq/lisk-cryptography\");\r\nconst errors_1 = require(\"../errors\");\r\nexports.validateSignature = (publicKey, signature, transactionBytes, id) => {\r\n    const transactionHash = cryptography.hash(transactionBytes);\r\n    const valid = cryptography.verifyData(transactionHash, signature, publicKey);\r\n    return {\r\n        valid,\r\n        error: !valid\r\n            ? new errors_1.TransactionError(`Failed to validate signature ${signature}`, id, '.signature')\r\n            : undefined,\r\n    };\r\n};\r\nexports.signaturesAreUnique = (signatures) => {\r\n    const uniqueSignatures = [...new Set(signatures)];\r\n    if (uniqueSignatures.length !== signatures.length) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\nexports.checkPublicKeySignatureUniqueness = (publicKeys, signatures, transactionBytes, id) => {\r\n    const checkedPublicKeys = new Set();\r\n    const validSignatures = new Set();\r\n    publicKeys.forEach(publicKey => {\r\n        signatures.forEach((signature) => {\r\n            if (checkedPublicKeys.has(publicKey) || validSignatures.has(signature)) {\r\n                return;\r\n            }\r\n            const { valid: signatureValid } = exports.validateSignature(publicKey, signature, transactionBytes, id);\r\n            if (signatureValid) {\r\n                checkedPublicKeys.add(publicKey);\r\n                validSignatures.add(signature);\r\n            }\r\n        });\r\n    });\r\n    return validSignatures;\r\n};\r\nexports.validateMultisignatures = (publicKeys, signatures, minimumValidations, transactionBytes, id) => {\r\n    if (!exports.signaturesAreUnique(signatures)) {\r\n        return {\r\n            valid: false,\r\n            errors: [\r\n                new errors_1.TransactionError('Encountered duplicate signature in transaction', id, '.signatures'),\r\n            ],\r\n        };\r\n    }\r\n    const validSignatures = exports.checkPublicKeySignatureUniqueness(publicKeys, signatures, transactionBytes, id);\r\n    const invalidTransactionSignatures = signatures.filter(signature => !validSignatures.has(signature));\r\n    if (signatures.length < minimumValidations) {\r\n        return {\r\n            valid: false,\r\n            errors: [\r\n                new errors_1.TransactionPendingError(`Missing signatures`, id, '.signatures'),\r\n            ],\r\n        };\r\n    }\r\n    return {\r\n        valid: validSignatures.size >= minimumValidations &&\r\n            invalidTransactionSignatures.length === 0,\r\n        errors: invalidTransactionSignatures.length > 0\r\n            ? invalidTransactionSignatures.map(signature => new errors_1.TransactionError(`Failed to validate signature ${signature}`, id, '.signatures'))\r\n            : [],\r\n    };\r\n};\r\n//# sourceMappingURL=sign_and_validate.js.map"]},"metadata":{},"sourceType":"script"}