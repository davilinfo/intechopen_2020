{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar varuint_bitcoin_1 = require(\"varuint-bitcoin\");\n\nvar buffer_1 = require(\"./buffer\");\n\nvar constants_1 = require(\"./constants\");\n\nvar hash_1 = require(\"./hash\");\n\nvar keys_1 = require(\"./keys\");\n\nvar nacl_1 = require(\"./nacl\");\n\nvar createHeader = function createHeader(text) {\n  return \"-----\".concat(text, \"-----\");\n};\n\nvar signedMessageHeader = createHeader('BEGIN LISK SIGNED MESSAGE');\nvar messageHeader = createHeader('MESSAGE');\nvar publicKeyHeader = createHeader('PUBLIC KEY');\nvar secondPublicKeyHeader = createHeader('SECOND PUBLIC KEY');\nvar signatureHeader = createHeader('SIGNATURE');\nvar secondSignatureHeader = createHeader('SECOND SIGNATURE');\nvar signatureFooter = createHeader('END LISK SIGNED MESSAGE');\nvar SIGNED_MESSAGE_PREFIX_BYTES = Buffer.from(constants_1.SIGNED_MESSAGE_PREFIX, 'utf8');\nvar SIGNED_MESSAGE_PREFIX_LENGTH = varuint_bitcoin_1.encode(constants_1.SIGNED_MESSAGE_PREFIX.length);\n\nexports.digestMessage = function (message) {\n  var msgBytes = Buffer.from(message, 'utf8');\n  var msgLenBytes = varuint_bitcoin_1.encode(message.length);\n  var dataBytes = Buffer.concat([SIGNED_MESSAGE_PREFIX_LENGTH, SIGNED_MESSAGE_PREFIX_BYTES, msgLenBytes, msgBytes]);\n  return hash_1.hash(hash_1.hash(dataBytes));\n};\n\nexports.signMessageWithPassphrase = function (message, passphrase) {\n  var msgBytes = exports.digestMessage(message);\n\n  var _keys_1$getPrivateAnd = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase),\n      privateKeyBytes = _keys_1$getPrivateAnd.privateKeyBytes,\n      publicKeyBytes = _keys_1$getPrivateAnd.publicKeyBytes;\n\n  var signature = nacl_1.signDetached(msgBytes, privateKeyBytes);\n  return {\n    message: message,\n    publicKey: buffer_1.bufferToHex(publicKeyBytes),\n    signature: buffer_1.bufferToHex(signature)\n  };\n};\n\nexports.verifyMessageWithPublicKey = function (_ref) {\n  var message = _ref.message,\n      publicKey = _ref.publicKey,\n      signature = _ref.signature;\n  var msgBytes = exports.digestMessage(message);\n  var signatureBytes = buffer_1.hexToBuffer(signature);\n  var publicKeyBytes = buffer_1.hexToBuffer(publicKey);\n\n  if (publicKeyBytes.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\n    throw new Error(\"Invalid publicKey, expected \".concat(nacl_1.NACL_SIGN_PUBLICKEY_LENGTH, \"-byte publicKey\"));\n  }\n\n  if (signatureBytes.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\n    throw new Error(\"Invalid signature length, expected \".concat(nacl_1.NACL_SIGN_SIGNATURE_LENGTH, \"-byte signature\"));\n  }\n\n  return nacl_1.verifyDetached(msgBytes, signatureBytes, publicKeyBytes);\n};\n\nexports.signMessageWithTwoPassphrases = function (message, passphrase, secondPassphrase) {\n  var msgBytes = exports.digestMessage(message);\n  var keypairBytes = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\n  var secondKeypairBytes = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(secondPassphrase);\n  var signature = nacl_1.signDetached(msgBytes, keypairBytes.privateKeyBytes);\n  var secondSignature = nacl_1.signDetached(msgBytes, secondKeypairBytes.privateKeyBytes);\n  return {\n    message: message,\n    publicKey: buffer_1.bufferToHex(keypairBytes.publicKeyBytes),\n    secondPublicKey: buffer_1.bufferToHex(secondKeypairBytes.publicKeyBytes),\n    signature: buffer_1.bufferToHex(signature),\n    secondSignature: buffer_1.bufferToHex(secondSignature)\n  };\n};\n\nexports.verifyMessageWithTwoPublicKeys = function (_ref2) {\n  var message = _ref2.message,\n      signature = _ref2.signature,\n      secondSignature = _ref2.secondSignature,\n      publicKey = _ref2.publicKey,\n      secondPublicKey = _ref2.secondPublicKey;\n  var messageBytes = exports.digestMessage(message);\n  var signatureBytes = buffer_1.hexToBuffer(signature);\n  var secondSignatureBytes = buffer_1.hexToBuffer(secondSignature);\n  var publicKeyBytes = buffer_1.hexToBuffer(publicKey);\n  var secondPublicKeyBytes = buffer_1.hexToBuffer(secondPublicKey);\n\n  if (signatureBytes.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\n    throw new Error(\"Invalid first signature length, expected \".concat(nacl_1.NACL_SIGN_SIGNATURE_LENGTH, \"-byte signature\"));\n  }\n\n  if (secondSignatureBytes.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\n    throw new Error(\"Invalid second signature length, expected \".concat(nacl_1.NACL_SIGN_SIGNATURE_LENGTH, \"-byte signature\"));\n  }\n\n  if (publicKeyBytes.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\n    throw new Error(\"Invalid first publicKey, expected \".concat(nacl_1.NACL_SIGN_PUBLICKEY_LENGTH, \"-byte publicKey\"));\n  }\n\n  if (secondPublicKeyBytes.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\n    throw new Error(\"Invalid second publicKey, expected \".concat(nacl_1.NACL_SIGN_PUBLICKEY_LENGTH, \"-byte publicKey\"));\n  }\n\n  var verifyFirstSignature = function verifyFirstSignature() {\n    return nacl_1.verifyDetached(messageBytes, signatureBytes, publicKeyBytes);\n  };\n\n  var verifySecondSignature = function verifySecondSignature() {\n    return nacl_1.verifyDetached(messageBytes, secondSignatureBytes, secondPublicKeyBytes);\n  };\n\n  return verifyFirstSignature() && verifySecondSignature();\n};\n\nexports.printSignedMessage = function (_ref3) {\n  var message = _ref3.message,\n      signature = _ref3.signature,\n      publicKey = _ref3.publicKey,\n      secondSignature = _ref3.secondSignature,\n      secondPublicKey = _ref3.secondPublicKey;\n  return [signedMessageHeader, messageHeader, message, publicKeyHeader, publicKey, secondPublicKey ? secondPublicKeyHeader : undefined, secondPublicKey, signatureHeader, signature, secondSignature ? secondSignatureHeader : undefined, secondSignature, signatureFooter].filter(Boolean).join('\\n');\n};\n\nexports.signAndPrintMessage = function (message, passphrase, secondPassphrase) {\n  var signedMessage = secondPassphrase ? exports.signMessageWithTwoPassphrases(message, passphrase, secondPassphrase) : exports.signMessageWithPassphrase(message, passphrase);\n  return exports.printSignedMessage(signedMessage);\n};\n\nexports.signDataWithPrivateKey = function (data, privateKey) {\n  var signature = nacl_1.signDetached(data, privateKey);\n  return buffer_1.bufferToHex(signature);\n};\n\nexports.signDataWithPassphrase = function (data, passphrase) {\n  var _keys_1$getPrivateAnd2 = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase),\n      privateKeyBytes = _keys_1$getPrivateAnd2.privateKeyBytes;\n\n  return exports.signDataWithPrivateKey(data, privateKeyBytes);\n};\n\nexports.signData = exports.signDataWithPassphrase;\n\nexports.verifyData = function (data, signature, publicKey) {\n  return nacl_1.verifyDetached(data, buffer_1.hexToBuffer(signature), buffer_1.hexToBuffer(publicKey));\n};","map":{"version":3,"sources":["../src/sign.ts"],"names":[],"mappings":";;;;;;AAcA,IAAA,iBAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAOA,IAAM,YAAY,GAAG,SAAf,YAAe,CAAC,IAAD;AAAA,wBAAkC,IAAlC;AAAA,CAArB;;AACA,IAAM,mBAAmB,GAAG,YAAY,CAAC,2BAAD,CAAxC;AACA,IAAM,aAAa,GAAG,YAAY,CAAC,SAAD,CAAlC;AACA,IAAM,eAAe,GAAG,YAAY,CAAC,YAAD,CAApC;AACA,IAAM,qBAAqB,GAAG,YAAY,CAAC,mBAAD,CAA1C;AACA,IAAM,eAAe,GAAG,YAAY,CAAC,WAAD,CAApC;AACA,IAAM,qBAAqB,GAAG,YAAY,CAAC,kBAAD,CAA1C;AACA,IAAM,eAAe,GAAG,YAAY,CAAC,yBAAD,CAApC;AAEA,IAAM,2BAA2B,GAAG,MAAM,CAAC,IAAP,CAAY,WAAA,CAAA,qBAAZ,EAAmC,MAAnC,CAApC;AACA,IAAM,4BAA4B,GAAG,iBAAA,CAAA,MAAA,CAAa,WAAA,CAAA,qBAAA,CAAsB,MAAnC,CAArC;;AAOa,OAAA,CAAA,aAAA,GAAgB,UAAC,OAAD,EAA4B;AACxD,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,MAArB,CAAjB;AACA,MAAM,WAAW,GAAG,iBAAA,CAAA,MAAA,CAAa,OAAO,CAAC,MAArB,CAApB;AACA,MAAM,SAAS,GAAG,MAAM,CAAC,MAAP,CAAc,CAC/B,4BAD+B,EAE/B,2BAF+B,EAG/B,WAH+B,EAI/B,QAJ+B,CAAd,CAAlB;AAOA,SAAO,MAAA,CAAA,IAAA,CAAK,MAAA,CAAA,IAAA,CAAK,SAAL,CAAL,CAAP;AACA,CAXY;;AAaA,OAAA,CAAA,yBAAA,GAA4B,UACxC,OADwC,EAExC,UAFwC,EAGL;AACnC,MAAM,QAAQ,GAAG,OAAA,CAAA,aAAA,CAAc,OAAd,CAAjB;;AADmC,8BAK/B,MAAA,CAAA,yCAAA,CAA0C,UAA1C,CAL+B;AAAA,MAGlC,eAHkC,yBAGlC,eAHkC;AAAA,MAIlC,cAJkC,yBAIlC,cAJkC;;AAMnC,MAAM,SAAS,GAAG,MAAA,CAAA,YAAA,CAAa,QAAb,EAAuB,eAAvB,CAAlB;AAEA,SAAO;AACN,IAAA,OAAO,EAAP,OADM;AAEN,IAAA,SAAS,EAAE,QAAA,CAAA,WAAA,CAAY,cAAZ,CAFL;AAGN,IAAA,SAAS,EAAE,QAAA,CAAA,WAAA,CAAY,SAAZ;AAHL,GAAP;AAKA,CAhBY;;AAkBA,OAAA,CAAA,0BAAA,GAA6B,gBAII;AAAA,MAH7C,OAG6C,QAH7C,OAG6C;AAAA,MAF7C,SAE6C,QAF7C,SAE6C;AAAA,MAD7C,SAC6C,QAD7C,SAC6C;AAC7C,MAAM,QAAQ,GAAG,OAAA,CAAA,aAAA,CAAc,OAAd,CAAjB;AACA,MAAM,cAAc,GAAG,QAAA,CAAA,WAAA,CAAY,SAAZ,CAAvB;AACA,MAAM,cAAc,GAAG,QAAA,CAAA,WAAA,CAAY,SAAZ,CAAvB;;AAEA,MAAI,cAAc,CAAC,MAAf,KAA0B,MAAA,CAAA,0BAA9B,EAA0D;AACzD,UAAM,IAAI,KAAJ,uCAC0B,MAAA,CAAA,0BAD1B,qBAAN;AAGA;;AAED,MAAI,cAAc,CAAC,MAAf,KAA0B,MAAA,CAAA,0BAA9B,EAA0D;AACzD,UAAM,IAAI,KAAJ,8CACiC,MAAA,CAAA,0BADjC,qBAAN;AAGA;;AAED,SAAO,MAAA,CAAA,cAAA,CAAe,QAAf,EAAyB,cAAzB,EAAyC,cAAzC,CAAP;AACA,CAtBY;;AAgCA,OAAA,CAAA,6BAAA,GAAgC,UAC5C,OAD4C,EAE5C,UAF4C,EAG5C,gBAH4C,EAIR;AACpC,MAAM,QAAQ,GAAG,OAAA,CAAA,aAAA,CAAc,OAAd,CAAjB;AACA,MAAM,YAAY,GAAG,MAAA,CAAA,yCAAA,CAA0C,UAA1C,CAArB;AACA,MAAM,kBAAkB,GAAG,MAAA,CAAA,yCAAA,CAC1B,gBAD0B,CAA3B;AAIA,MAAM,SAAS,GAAG,MAAA,CAAA,YAAA,CAAa,QAAb,EAAuB,YAAY,CAAC,eAApC,CAAlB;AACA,MAAM,eAAe,GAAG,MAAA,CAAA,YAAA,CACvB,QADuB,EAEvB,kBAAkB,CAAC,eAFI,CAAxB;AAKA,SAAO;AACN,IAAA,OAAO,EAAP,OADM;AAEN,IAAA,SAAS,EAAE,QAAA,CAAA,WAAA,CAAY,YAAY,CAAC,cAAzB,CAFL;AAGN,IAAA,eAAe,EAAE,QAAA,CAAA,WAAA,CAAY,kBAAkB,CAAC,cAA/B,CAHX;AAIN,IAAA,SAAS,EAAE,QAAA,CAAA,WAAA,CAAY,SAAZ,CAJL;AAKN,IAAA,eAAe,EAAE,QAAA,CAAA,WAAA,CAAY,eAAZ;AALX,GAAP;AAOA,CAxBY;;AA0BA,OAAA,CAAA,8BAAA,GAAiC,iBAMR;AAAA,MALrC,OAKqC,SALrC,OAKqC;AAAA,MAJrC,SAIqC,SAJrC,SAIqC;AAAA,MAHrC,eAGqC,SAHrC,eAGqC;AAAA,MAFrC,SAEqC,SAFrC,SAEqC;AAAA,MADrC,eACqC,SADrC,eACqC;AACrC,MAAM,YAAY,GAAG,OAAA,CAAA,aAAA,CAAc,OAAd,CAArB;AACA,MAAM,cAAc,GAAG,QAAA,CAAA,WAAA,CAAY,SAAZ,CAAvB;AACA,MAAM,oBAAoB,GAAG,QAAA,CAAA,WAAA,CAAY,eAAZ,CAA7B;AACA,MAAM,cAAc,GAAG,QAAA,CAAA,WAAA,CAAY,SAAZ,CAAvB;AACA,MAAM,oBAAoB,GAAG,QAAA,CAAA,WAAA,CAAY,eAAZ,CAA7B;;AAEA,MAAI,cAAc,CAAC,MAAf,KAA0B,MAAA,CAAA,0BAA9B,EAA0D;AACzD,UAAM,IAAI,KAAJ,oDACuC,MAAA,CAAA,0BADvC,qBAAN;AAGA;;AAED,MAAI,oBAAoB,CAAC,MAArB,KAAgC,MAAA,CAAA,0BAApC,EAAgE;AAC/D,UAAM,IAAI,KAAJ,qDACwC,MAAA,CAAA,0BADxC,qBAAN;AAGA;;AAED,MAAI,cAAc,CAAC,MAAf,KAA0B,MAAA,CAAA,0BAA9B,EAA0D;AACzD,UAAM,IAAI,KAAJ,6CACgC,MAAA,CAAA,0BADhC,qBAAN;AAGA;;AAED,MAAI,oBAAoB,CAAC,MAArB,KAAgC,MAAA,CAAA,0BAApC,EAAgE;AAC/D,UAAM,IAAI,KAAJ,8CACiC,MAAA,CAAA,0BADjC,qBAAN;AAGA;;AAED,MAAM,oBAAoB,GAAG,SAAvB,oBAAuB;AAAA,WAC5B,MAAA,CAAA,cAAA,CAAe,YAAf,EAA6B,cAA7B,EAA6C,cAA7C,CAD4B;AAAA,GAA7B;;AAEA,MAAM,qBAAqB,GAAG,SAAxB,qBAAwB;AAAA,WAC7B,MAAA,CAAA,cAAA,CAAe,YAAf,EAA6B,oBAA7B,EAAmD,oBAAnD,CAD6B;AAAA,GAA9B;;AAGA,SAAO,oBAAoB,MAAM,qBAAqB,EAAtD;AACA,CA3CY;;AAqDA,OAAA,CAAA,kBAAA,GAAqB;AAAA,MACjC,OADiC,SACjC,OADiC;AAAA,MAEjC,SAFiC,SAEjC,SAFiC;AAAA,MAGjC,SAHiC,SAGjC,SAHiC;AAAA,MAIjC,eAJiC,SAIjC,eAJiC;AAAA,MAKjC,eALiC,SAKjC,eALiC;AAAA,SAOjC,CACC,mBADD,EAEC,aAFD,EAGC,OAHD,EAIC,eAJD,EAKC,SALD,EAMC,eAAe,GAAG,qBAAH,GAA2B,SAN3C,EAOC,eAPD,EAQC,eARD,EASC,SATD,EAUC,eAAe,GAAG,qBAAH,GAA2B,SAV3C,EAWC,eAXD,EAYC,eAZD,EAcE,MAdF,CAcS,OAdT,EAeE,IAfF,CAeO,IAfP,CAPiC;AAAA,CAArB;;AAwBA,OAAA,CAAA,mBAAA,GAAsB,UAClC,OADkC,EAElC,UAFkC,EAGlC,gBAHkC,EAIvB;AACX,MAAM,aAAa,GAEkB,gBAAgB,GAClD,OAAA,CAAA,6BAAA,CAA8B,OAA9B,EAAuC,UAAvC,EAAmD,gBAAnD,CADkD,GAElD,OAAA,CAAA,yBAAA,CAA0B,OAA1B,EAAmC,UAAnC,CAJH;AAMA,SAAO,OAAA,CAAA,kBAAA,CAAmB,aAAnB,CAAP;AACA,CAZY;;AAcA,OAAA,CAAA,sBAAA,GAAyB,UACrC,IADqC,EAErC,UAFqC,EAG1B;AACX,MAAM,SAAS,GAAG,MAAA,CAAA,YAAA,CAAa,IAAb,EAAmB,UAAnB,CAAlB;AAEA,SAAO,QAAA,CAAA,WAAA,CAAY,SAAZ,CAAP;AACA,CAPY;;AASA,OAAA,CAAA,sBAAA,GAAyB,UACrC,IADqC,EAErC,UAFqC,EAG1B;AAAA,+BACiB,MAAA,CAAA,yCAAA,CAC3B,UAD2B,CADjB;AAAA,MACH,eADG,0BACH,eADG;;AAKX,SAAO,OAAA,CAAA,sBAAA,CAAuB,IAAvB,EAA6B,eAA7B,CAAP;AACA,CATY;;AAWA,OAAA,CAAA,QAAA,GAAW,OAAA,CAAA,sBAAX;;AAEA,OAAA,CAAA,UAAA,GAAa,UACzB,IADyB,EAEzB,SAFyB,EAGzB,SAHyB;AAAA,SAKzB,MAAA,CAAA,cAAA,CAAe,IAAf,EAAqB,QAAA,CAAA,WAAA,CAAY,SAAZ,CAArB,EAA6C,QAAA,CAAA,WAAA,CAAY,SAAZ,CAA7C,CALyB;AAAA,CAAb","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst varuint_bitcoin_1 = require(\"varuint-bitcoin\");\r\nconst buffer_1 = require(\"./buffer\");\r\nconst constants_1 = require(\"./constants\");\r\nconst hash_1 = require(\"./hash\");\r\nconst keys_1 = require(\"./keys\");\r\nconst nacl_1 = require(\"./nacl\");\r\nconst createHeader = (text) => `-----${text}-----`;\r\nconst signedMessageHeader = createHeader('BEGIN LISK SIGNED MESSAGE');\r\nconst messageHeader = createHeader('MESSAGE');\r\nconst publicKeyHeader = createHeader('PUBLIC KEY');\r\nconst secondPublicKeyHeader = createHeader('SECOND PUBLIC KEY');\r\nconst signatureHeader = createHeader('SIGNATURE');\r\nconst secondSignatureHeader = createHeader('SECOND SIGNATURE');\r\nconst signatureFooter = createHeader('END LISK SIGNED MESSAGE');\r\nconst SIGNED_MESSAGE_PREFIX_BYTES = Buffer.from(constants_1.SIGNED_MESSAGE_PREFIX, 'utf8');\r\nconst SIGNED_MESSAGE_PREFIX_LENGTH = varuint_bitcoin_1.encode(constants_1.SIGNED_MESSAGE_PREFIX.length);\r\nexports.digestMessage = (message) => {\r\n    const msgBytes = Buffer.from(message, 'utf8');\r\n    const msgLenBytes = varuint_bitcoin_1.encode(message.length);\r\n    const dataBytes = Buffer.concat([\r\n        SIGNED_MESSAGE_PREFIX_LENGTH,\r\n        SIGNED_MESSAGE_PREFIX_BYTES,\r\n        msgLenBytes,\r\n        msgBytes,\r\n    ]);\r\n    return hash_1.hash(hash_1.hash(dataBytes));\r\n};\r\nexports.signMessageWithPassphrase = (message, passphrase) => {\r\n    const msgBytes = exports.digestMessage(message);\r\n    const { privateKeyBytes, publicKeyBytes, } = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\r\n    const signature = nacl_1.signDetached(msgBytes, privateKeyBytes);\r\n    return {\r\n        message,\r\n        publicKey: buffer_1.bufferToHex(publicKeyBytes),\r\n        signature: buffer_1.bufferToHex(signature),\r\n    };\r\n};\r\nexports.verifyMessageWithPublicKey = ({ message, publicKey, signature, }) => {\r\n    const msgBytes = exports.digestMessage(message);\r\n    const signatureBytes = buffer_1.hexToBuffer(signature);\r\n    const publicKeyBytes = buffer_1.hexToBuffer(publicKey);\r\n    if (publicKeyBytes.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\r\n        throw new Error(`Invalid publicKey, expected ${nacl_1.NACL_SIGN_PUBLICKEY_LENGTH}-byte publicKey`);\r\n    }\r\n    if (signatureBytes.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\r\n        throw new Error(`Invalid signature length, expected ${nacl_1.NACL_SIGN_SIGNATURE_LENGTH}-byte signature`);\r\n    }\r\n    return nacl_1.verifyDetached(msgBytes, signatureBytes, publicKeyBytes);\r\n};\r\nexports.signMessageWithTwoPassphrases = (message, passphrase, secondPassphrase) => {\r\n    const msgBytes = exports.digestMessage(message);\r\n    const keypairBytes = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\r\n    const secondKeypairBytes = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(secondPassphrase);\r\n    const signature = nacl_1.signDetached(msgBytes, keypairBytes.privateKeyBytes);\r\n    const secondSignature = nacl_1.signDetached(msgBytes, secondKeypairBytes.privateKeyBytes);\r\n    return {\r\n        message,\r\n        publicKey: buffer_1.bufferToHex(keypairBytes.publicKeyBytes),\r\n        secondPublicKey: buffer_1.bufferToHex(secondKeypairBytes.publicKeyBytes),\r\n        signature: buffer_1.bufferToHex(signature),\r\n        secondSignature: buffer_1.bufferToHex(secondSignature),\r\n    };\r\n};\r\nexports.verifyMessageWithTwoPublicKeys = ({ message, signature, secondSignature, publicKey, secondPublicKey, }) => {\r\n    const messageBytes = exports.digestMessage(message);\r\n    const signatureBytes = buffer_1.hexToBuffer(signature);\r\n    const secondSignatureBytes = buffer_1.hexToBuffer(secondSignature);\r\n    const publicKeyBytes = buffer_1.hexToBuffer(publicKey);\r\n    const secondPublicKeyBytes = buffer_1.hexToBuffer(secondPublicKey);\r\n    if (signatureBytes.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\r\n        throw new Error(`Invalid first signature length, expected ${nacl_1.NACL_SIGN_SIGNATURE_LENGTH}-byte signature`);\r\n    }\r\n    if (secondSignatureBytes.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\r\n        throw new Error(`Invalid second signature length, expected ${nacl_1.NACL_SIGN_SIGNATURE_LENGTH}-byte signature`);\r\n    }\r\n    if (publicKeyBytes.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\r\n        throw new Error(`Invalid first publicKey, expected ${nacl_1.NACL_SIGN_PUBLICKEY_LENGTH}-byte publicKey`);\r\n    }\r\n    if (secondPublicKeyBytes.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\r\n        throw new Error(`Invalid second publicKey, expected ${nacl_1.NACL_SIGN_PUBLICKEY_LENGTH}-byte publicKey`);\r\n    }\r\n    const verifyFirstSignature = () => nacl_1.verifyDetached(messageBytes, signatureBytes, publicKeyBytes);\r\n    const verifySecondSignature = () => nacl_1.verifyDetached(messageBytes, secondSignatureBytes, secondPublicKeyBytes);\r\n    return verifyFirstSignature() && verifySecondSignature();\r\n};\r\nexports.printSignedMessage = ({ message, signature, publicKey, secondSignature, secondPublicKey, }) => [\r\n    signedMessageHeader,\r\n    messageHeader,\r\n    message,\r\n    publicKeyHeader,\r\n    publicKey,\r\n    secondPublicKey ? secondPublicKeyHeader : undefined,\r\n    secondPublicKey,\r\n    signatureHeader,\r\n    signature,\r\n    secondSignature ? secondSignatureHeader : undefined,\r\n    secondSignature,\r\n    signatureFooter,\r\n]\r\n    .filter(Boolean)\r\n    .join('\\n');\r\nexports.signAndPrintMessage = (message, passphrase, secondPassphrase) => {\r\n    const signedMessage = secondPassphrase\r\n        ? exports.signMessageWithTwoPassphrases(message, passphrase, secondPassphrase)\r\n        : exports.signMessageWithPassphrase(message, passphrase);\r\n    return exports.printSignedMessage(signedMessage);\r\n};\r\nexports.signDataWithPrivateKey = (data, privateKey) => {\r\n    const signature = nacl_1.signDetached(data, privateKey);\r\n    return buffer_1.bufferToHex(signature);\r\n};\r\nexports.signDataWithPassphrase = (data, passphrase) => {\r\n    const { privateKeyBytes } = keys_1.getPrivateAndPublicKeyBytesFromPassphrase(passphrase);\r\n    return exports.signDataWithPrivateKey(data, privateKeyBytes);\r\n};\r\nexports.signData = exports.signDataWithPassphrase;\r\nexports.verifyData = (data, signature, publicKey) => nacl_1.verifyDetached(data, buffer_1.hexToBuffer(signature), buffer_1.hexToBuffer(publicKey));\r\n//# sourceMappingURL=sign.js.map"]},"metadata":{},"sourceType":"script"}