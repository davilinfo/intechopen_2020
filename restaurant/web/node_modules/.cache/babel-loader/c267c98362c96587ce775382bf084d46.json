{"ast":null,"code":"\"use strict\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst cryptography = require(\"@liskhq/lisk-cryptography\");\n\nconst errors_1 = require(\"../errors\");\n\nconst get_transaction_hash_1 = require(\"./get_transaction_hash\");\n\nexports.multiSignTransaction = (transaction, passphrase) => {\n  const {\n    signature,\n    signSignature\n  } = transaction,\n        transactionToSign = __rest(transaction, [\"signature\", \"signSignature\"]);\n\n  const transactionHash = get_transaction_hash_1.getTransactionHash(transactionToSign);\n  return cryptography.signData(transactionHash, passphrase);\n};\n\nexports.validateSignature = (publicKey, signature, transactionBytes, id) => {\n  const transactionHash = cryptography.hash(transactionBytes);\n  const valid = cryptography.verifyData(transactionHash, signature, publicKey);\n  return {\n    valid,\n    error: !valid ? new errors_1.TransactionError(`Failed to validate signature ${signature}`, id, '.signature') : undefined\n  };\n};\n\nexports.signaturesAreUnique = signatures => {\n  const uniqueSignatures = [...new Set(signatures)];\n\n  if (uniqueSignatures.length !== signatures.length) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.checkPublicKeySignatureUniqueness = (publicKeys, signatures, transactionBytes, id) => {\n  const checkedPublicKeys = new Set();\n  const validSignatures = new Set();\n  publicKeys.forEach(publicKey => {\n    signatures.forEach(signature => {\n      if (checkedPublicKeys.has(publicKey) || validSignatures.has(signature)) {\n        return;\n      }\n\n      const {\n        valid: signatureValid\n      } = exports.validateSignature(publicKey, signature, transactionBytes, id);\n\n      if (signatureValid) {\n        checkedPublicKeys.add(publicKey);\n        validSignatures.add(signature);\n      }\n    });\n  });\n  return validSignatures;\n};\n\nexports.validateMultisignatures = (publicKeys, signatures, minimumValidations, transactionBytes, id) => {\n  if (!exports.signaturesAreUnique(signatures)) {\n    return {\n      valid: false,\n      errors: [new errors_1.TransactionError('Encountered duplicate signature in transaction', id, '.signatures')]\n    };\n  }\n\n  const validSignatures = exports.checkPublicKeySignatureUniqueness(publicKeys, signatures, transactionBytes, id);\n  const invalidTransactionSignatures = signatures.filter(signature => !validSignatures.has(signature));\n\n  if (signatures.length < minimumValidations) {\n    return {\n      valid: false,\n      errors: [new errors_1.TransactionPendingError(`Missing signatures`, id, '.signatures')]\n    };\n  }\n\n  return {\n    valid: validSignatures.size >= minimumValidations && invalidTransactionSignatures.length === 0,\n    errors: invalidTransactionSignatures.length > 0 ? invalidTransactionSignatures.map(signature => new errors_1.TransactionError(`Failed to validate signature ${signature}`, id, '.signatures')) : []\n  };\n};\n\nexports.signTransaction = (transaction, passphrase) => {\n  const transactionHash = get_transaction_hash_1.getTransactionHash(transaction);\n  return cryptography.signData(transactionHash, passphrase);\n};\n\nexports.secondSignTransaction = (transaction, secondPassphrase) => Object.assign({}, transaction, {\n  signSignature: exports.signTransaction(transaction, secondPassphrase)\n});\n\nexports.verifyTransaction = (transaction, secondPublicKey) => {\n  if (!transaction.signature) {\n    throw new Error('Cannot verify transaction without signature.');\n  }\n\n  if (!!transaction.signSignature && !secondPublicKey) {\n    throw new Error('Cannot verify signSignature without secondPublicKey.');\n  }\n\n  const {\n    signature,\n    signSignature\n  } = transaction,\n        transactionWithoutSignatures = __rest(transaction, [\"signature\", \"signSignature\"]);\n\n  const transactionWithoutSignature = !!transaction.signSignature ? Object.assign({}, transactionWithoutSignatures, {\n    signature\n  }) : transactionWithoutSignatures;\n  const transactionHash = get_transaction_hash_1.getTransactionHash(transactionWithoutSignature);\n  const publicKey = !!transaction.signSignature && secondPublicKey ? secondPublicKey : transaction.senderPublicKey;\n  const lastSignature = transaction.signSignature ? transaction.signSignature : transaction.signature;\n  const verified = cryptography.verifyData(transactionHash, lastSignature, publicKey);\n  return !!transaction.signSignature ? verified && exports.verifyTransaction(transactionWithoutSignature) : verified;\n};","map":{"version":3,"sources":["../../src/utils/sign_and_validate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cryptography = require(\"@liskhq/lisk-cryptography\");\r\nconst errors_1 = require(\"../errors\");\r\nconst get_transaction_hash_1 = require(\"./get_transaction_hash\");\r\nexports.multiSignTransaction = (transaction, passphrase) => {\r\n    const { signature, signSignature } = transaction, transactionToSign = __rest(transaction, [\"signature\", \"signSignature\"]);\r\n    const transactionHash = get_transaction_hash_1.getTransactionHash(transactionToSign);\r\n    return cryptography.signData(transactionHash, passphrase);\r\n};\r\nexports.validateSignature = (publicKey, signature, transactionBytes, id) => {\r\n    const transactionHash = cryptography.hash(transactionBytes);\r\n    const valid = cryptography.verifyData(transactionHash, signature, publicKey);\r\n    return {\r\n        valid,\r\n        error: !valid\r\n            ? new errors_1.TransactionError(`Failed to validate signature ${signature}`, id, '.signature')\r\n            : undefined,\r\n    };\r\n};\r\nexports.signaturesAreUnique = (signatures) => {\r\n    const uniqueSignatures = [...new Set(signatures)];\r\n    if (uniqueSignatures.length !== signatures.length) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\nexports.checkPublicKeySignatureUniqueness = (publicKeys, signatures, transactionBytes, id) => {\r\n    const checkedPublicKeys = new Set();\r\n    const validSignatures = new Set();\r\n    publicKeys.forEach(publicKey => {\r\n        signatures.forEach((signature) => {\r\n            if (checkedPublicKeys.has(publicKey) || validSignatures.has(signature)) {\r\n                return;\r\n            }\r\n            const { valid: signatureValid } = exports.validateSignature(publicKey, signature, transactionBytes, id);\r\n            if (signatureValid) {\r\n                checkedPublicKeys.add(publicKey);\r\n                validSignatures.add(signature);\r\n            }\r\n        });\r\n    });\r\n    return validSignatures;\r\n};\r\nexports.validateMultisignatures = (publicKeys, signatures, minimumValidations, transactionBytes, id) => {\r\n    if (!exports.signaturesAreUnique(signatures)) {\r\n        return {\r\n            valid: false,\r\n            errors: [\r\n                new errors_1.TransactionError('Encountered duplicate signature in transaction', id, '.signatures'),\r\n            ],\r\n        };\r\n    }\r\n    const validSignatures = exports.checkPublicKeySignatureUniqueness(publicKeys, signatures, transactionBytes, id);\r\n    const invalidTransactionSignatures = signatures.filter(signature => !validSignatures.has(signature));\r\n    if (signatures.length < minimumValidations) {\r\n        return {\r\n            valid: false,\r\n            errors: [\r\n                new errors_1.TransactionPendingError(`Missing signatures`, id, '.signatures'),\r\n            ],\r\n        };\r\n    }\r\n    return {\r\n        valid: validSignatures.size >= minimumValidations &&\r\n            invalidTransactionSignatures.length === 0,\r\n        errors: invalidTransactionSignatures.length > 0\r\n            ? invalidTransactionSignatures.map(signature => new errors_1.TransactionError(`Failed to validate signature ${signature}`, id, '.signatures'))\r\n            : [],\r\n    };\r\n};\r\nexports.signTransaction = (transaction, passphrase) => {\r\n    const transactionHash = get_transaction_hash_1.getTransactionHash(transaction);\r\n    return cryptography.signData(transactionHash, passphrase);\r\n};\r\nexports.secondSignTransaction = (transaction, secondPassphrase) => (Object.assign({}, transaction, { signSignature: exports.signTransaction(transaction, secondPassphrase) }));\r\nexports.verifyTransaction = (transaction, secondPublicKey) => {\r\n    if (!transaction.signature) {\r\n        throw new Error('Cannot verify transaction without signature.');\r\n    }\r\n    if (!!transaction.signSignature && !secondPublicKey) {\r\n        throw new Error('Cannot verify signSignature without secondPublicKey.');\r\n    }\r\n    const { signature, signSignature } = transaction, transactionWithoutSignatures = __rest(transaction, [\"signature\", \"signSignature\"]);\r\n    const transactionWithoutSignature = !!transaction.signSignature\r\n        ? Object.assign({}, transactionWithoutSignatures, { signature }) : transactionWithoutSignatures;\r\n    const transactionHash = get_transaction_hash_1.getTransactionHash(transactionWithoutSignature);\r\n    const publicKey = !!transaction.signSignature && secondPublicKey\r\n        ? secondPublicKey\r\n        : transaction.senderPublicKey;\r\n    const lastSignature = transaction.signSignature\r\n        ? transaction.signSignature\r\n        : transaction.signature;\r\n    const verified = cryptography.verifyData(transactionHash, lastSignature, publicKey);\r\n    return !!transaction.signSignature\r\n        ? verified && exports.verifyTransaction(transactionWithoutSignature)\r\n        : verified;\r\n};\r\n//# sourceMappingURL=sign_and_validate.js.map"]},"metadata":{},"sourceType":"script"}