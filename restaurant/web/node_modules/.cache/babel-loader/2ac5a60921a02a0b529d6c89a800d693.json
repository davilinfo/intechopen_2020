{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\davin.DESKTOP-83VQBDE\\\\Documents\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\davin.DESKTOP-83VQBDE\\\\Documents\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\davin.DESKTOP-83VQBDE\\\\Documents\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\davin.DESKTOP-83VQBDE\\\\Documents\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\davin.DESKTOP-83VQBDE\\\\Documents\\\\restaurant_sidechain\\\\web\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BigNum = require(\"@liskhq/bignum\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar constants_1 = require(\"./constants\");\n\nvar errors_1 = require(\"./errors\");\n\nvar response_1 = require(\"./response\");\n\nvar utils_1 = require(\"./utils\");\n\nvar schemas = require(\"./utils/validation/schema\");\n\nvar MultisignatureStatus;\n\n(function (MultisignatureStatus) {\n  MultisignatureStatus[MultisignatureStatus[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  MultisignatureStatus[MultisignatureStatus[\"NONMULTISIGNATURE\"] = 1] = \"NONMULTISIGNATURE\";\n  MultisignatureStatus[MultisignatureStatus[\"PENDING\"] = 2] = \"PENDING\";\n  MultisignatureStatus[MultisignatureStatus[\"READY\"] = 3] = \"READY\";\n  MultisignatureStatus[MultisignatureStatus[\"FAIL\"] = 4] = \"FAIL\";\n})(MultisignatureStatus = exports.MultisignatureStatus || (exports.MultisignatureStatus = {}));\n\nexports.ENTITY_ACCOUNT = 'account';\nexports.ENTITY_TRANSACTION = 'transaction';\n\nvar BaseTransaction = /*#__PURE__*/function () {\n  function BaseTransaction(rawTransaction) {\n    _classCallCheck(this, BaseTransaction);\n\n    this._multisignatureStatus = MultisignatureStatus.UNKNOWN;\n    var tx = typeof rawTransaction === 'object' && rawTransaction !== null ? rawTransaction : {};\n    this.amount = new BigNum(utils_1.isValidNumber(tx.amount) ? tx.amount : '0');\n    this.fee = new BigNum(utils_1.isValidNumber(tx.fee) ? tx.fee : this.constructor.FEE);\n    this.type = typeof tx.type === 'number' ? tx.type : this.constructor.TYPE;\n    this._id = tx.id;\n    this.recipientId = tx.recipientId || '';\n    this.recipientPublicKey = tx.recipientPublicKey || undefined;\n    this._senderPublicKey = tx.senderPublicKey || '';\n\n    try {\n      this._senderId = tx.senderId ? tx.senderId : lisk_cryptography_1.getAddressFromPublicKey(this.senderPublicKey);\n    } catch (error) {\n      this._senderId = '';\n    }\n\n    this._signature = tx.signature;\n    this.signatures = tx.signatures || [];\n    this._signSignature = tx.signSignature;\n    this.timestamp = typeof tx.timestamp === 'number' ? tx.timestamp : 0;\n    this.confirmations = tx.confirmations;\n    this.blockId = tx.blockId;\n    this.height = tx.height;\n    this.receivedAt = tx.receivedAt ? new Date(tx.receivedAt) : undefined;\n    this.relays = typeof tx.relays === 'number' ? tx.relays : undefined;\n    this.asset = tx.asset || {};\n  }\n\n  _createClass(BaseTransaction, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      var transaction = {\n        id: this.id,\n        blockId: this.blockId,\n        height: this.height,\n        relays: this.relays,\n        confirmations: this.confirmations,\n        amount: this.amount.toString(),\n        type: this.type,\n        timestamp: this.timestamp,\n        senderPublicKey: this.senderPublicKey,\n        senderId: this.senderId,\n        recipientId: this.recipientId,\n        recipientPublicKey: this.recipientPublicKey,\n        fee: this.fee.toString(),\n        signature: this.signature,\n        signSignature: this.signSignature ? this.signSignature : undefined,\n        signatures: this.signatures,\n        asset: this.assetToJSON(),\n        receivedAt: this.receivedAt ? this.receivedAt.toISOString() : undefined\n      };\n      return transaction;\n    }\n  }, {\n    key: \"stringify\",\n    value: function stringify() {\n      return JSON.stringify(this.toJSON());\n    }\n  }, {\n    key: \"isReady\",\n    value: function isReady() {\n      return this._multisignatureStatus === MultisignatureStatus.READY || this._multisignatureStatus === MultisignatureStatus.NONMULTISIGNATURE;\n    }\n  }, {\n    key: \"getBytes\",\n    value: function getBytes() {\n      var transactionBytes = Buffer.concat([this.getBasicBytes(), this._signature ? lisk_cryptography_1.hexToBuffer(this._signature) : Buffer.alloc(0), this._signSignature ? lisk_cryptography_1.hexToBuffer(this._signSignature) : Buffer.alloc(0)]);\n      return transactionBytes;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      var errors = [].concat(_toConsumableArray(this._validateSchema()), _toConsumableArray(this.validateAsset()));\n\n      if (errors.length > 0) {\n        return response_1.createResponse(this.id, errors);\n      }\n\n      var transactionBytes = this.getBasicBytes();\n\n      var _utils_1$validateSign = utils_1.validateSignature(this.senderPublicKey, this.signature, transactionBytes, this.id),\n          signatureValid = _utils_1$validateSign.valid,\n          verificationError = _utils_1$validateSign.error;\n\n      if (!signatureValid && verificationError) {\n        errors.push(verificationError);\n      }\n\n      var idError = utils_1.validateTransactionId(this.id, this.getBytes());\n\n      if (idError) {\n        errors.push(idError);\n      }\n\n      if (this.type !== this.constructor.TYPE) {\n        errors.push(new errors_1.TransactionError(\"Invalid type\", this.id, '.type', this.type, this.constructor.TYPE));\n      }\n\n      var feeError = this.validateFee();\n\n      if (feeError) {\n        errors.push(feeError);\n      }\n\n      return response_1.createResponse(this.id, errors);\n    }\n  }, {\n    key: \"validateFee\",\n    value: function validateFee() {\n      return !this.fee.eq(this.constructor.FEE) ? new errors_1.TransactionError(\"Invalid fee\", this.id, '.fee', this.fee.toString(), this.constructor.FEE.toString()) : undefined;\n    }\n  }, {\n    key: \"verifyAgainstOtherTransactions\",\n    value: function verifyAgainstOtherTransactions(transactions) {\n      var errors = this.verifyAgainstTransactions(transactions);\n      return response_1.createResponse(this.id, errors);\n    }\n  }, {\n    key: \"apply\",\n    value: function apply(store) {\n      var sender = store.account.getOrDefault(this.senderId);\n\n      var errors = this._verify(sender);\n\n      var _this$processMultisig = this.processMultisignatures(store),\n          multiSigError = _this$processMultisig.errors;\n\n      if (multiSigError) {\n        errors.push.apply(errors, _toConsumableArray(multiSigError));\n      }\n\n      var updatedBalance = new BigNum(sender.balance).sub(this.fee);\n      var updatedSender = Object.assign({}, sender, {\n        balance: updatedBalance.toString(),\n        publicKey: sender.publicKey || this.senderPublicKey\n      });\n      store.account.set(updatedSender.address, updatedSender);\n      var assetErrors = this.applyAsset(store);\n      errors.push.apply(errors, _toConsumableArray(assetErrors));\n\n      if (this._multisignatureStatus === MultisignatureStatus.PENDING && errors.length === 1 && errors[0] instanceof errors_1.TransactionPendingError) {\n        return {\n          id: this.id,\n          status: response_1.Status.PENDING,\n          errors: errors\n        };\n      }\n\n      return response_1.createResponse(this.id, errors);\n    }\n  }, {\n    key: \"undo\",\n    value: function undo(store) {\n      var sender = store.account.getOrDefault(this.senderId);\n      var updatedBalance = new BigNum(sender.balance).add(this.fee);\n      var updatedAccount = Object.assign({}, sender, {\n        balance: updatedBalance.toString(),\n        publicKey: sender.publicKey || this.senderPublicKey\n      });\n      var errors = updatedBalance.lte(constants_1.MAX_TRANSACTION_AMOUNT) ? [] : [new errors_1.TransactionError('Invalid balance amount', this.id, '.balance', sender.balance, updatedBalance.toString())];\n      store.account.set(updatedAccount.address, updatedAccount);\n      var assetErrors = this.undoAsset(store);\n      errors.push.apply(errors, _toConsumableArray(assetErrors));\n      return response_1.createResponse(this.id, errors);\n    }\n  }, {\n    key: \"prepare\",\n    value: function () {\n      var _prepare = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(store) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return store.account.cache([{\n                  address: this.senderId\n                }]);\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function prepare(_x) {\n        return _prepare.apply(this, arguments);\n      }\n\n      return prepare;\n    }()\n  }, {\n    key: \"addMultisignature\",\n    value: function addMultisignature(store, signatureObject) {\n      var account = store.account.get(this.senderId);\n\n      if (account.membersPublicKeys && !account.membersPublicKeys.includes(signatureObject.publicKey)) {\n        return response_1.createResponse(this.id, [new errors_1.TransactionError(\"Public Key '\".concat(signatureObject.publicKey, \"' is not a member for account '\").concat(account.address, \"'.\"), this.id)]);\n      }\n\n      if (this.signatures.includes(signatureObject.signature)) {\n        return response_1.createResponse(this.id, [new errors_1.TransactionError(\"Signature '\".concat(signatureObject.signature, \"' already present in transaction.\"), this.id)]);\n      }\n\n      var _utils_1$validateSign2 = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, this.getBasicBytes(), this.id),\n          valid = _utils_1$validateSign2.valid;\n\n      if (valid) {\n        this.signatures.push(signatureObject.signature);\n        return this.processMultisignatures(store);\n      }\n\n      var errors = valid ? [] : [new errors_1.TransactionError(\"Failed to add signature '\".concat(signatureObject.signature, \"'.\"), this.id, '.signatures')];\n      return response_1.createResponse(this.id, errors);\n    }\n  }, {\n    key: \"addVerifiedMultisignature\",\n    value: function addVerifiedMultisignature(signature) {\n      if (!this.signatures.includes(signature)) {\n        this.signatures.push(signature);\n        return response_1.createResponse(this.id, []);\n      }\n\n      return response_1.createResponse(this.id, [new errors_1.TransactionError('Failed to add signature.', this.id, '.signatures')]);\n    }\n  }, {\n    key: \"processMultisignatures\",\n    value: function processMultisignatures(store) {\n      var sender = store.account.get(this.senderId);\n      var transactionBytes = this.getBasicBytes();\n\n      var _utils_1$verifyMultiS = utils_1.verifyMultiSignatures(this.id, sender, this.signatures, transactionBytes),\n          status = _utils_1$verifyMultiS.status,\n          errors = _utils_1$verifyMultiS.errors;\n\n      this._multisignatureStatus = status;\n\n      if (this._multisignatureStatus === MultisignatureStatus.PENDING) {\n        return {\n          id: this.id,\n          status: response_1.Status.PENDING,\n          errors: errors\n        };\n      }\n\n      return response_1.createResponse(this.id, errors);\n    }\n  }, {\n    key: \"isExpired\",\n    value: function isExpired() {\n      var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n\n      if (!this.receivedAt) {\n        this.receivedAt = new Date();\n      }\n\n      var timeNow = Math.floor(date.getTime() / 1000);\n      var timeOut = this._multisignatureStatus === MultisignatureStatus.PENDING || this._multisignatureStatus === MultisignatureStatus.READY ? constants_1.UNCONFIRMED_MULTISIG_TRANSACTION_TIMEOUT : constants_1.UNCONFIRMED_TRANSACTION_TIMEOUT;\n      var timeElapsed = timeNow - Math.floor(this.receivedAt.getTime() / 1000);\n      return timeElapsed > timeOut;\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(passphrase, secondPassphrase) {\n      var _lisk_cryptography_1$ = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase),\n          address = _lisk_cryptography_1$.address,\n          publicKey = _lisk_cryptography_1$.publicKey;\n\n      if (this._senderId !== '' && this._senderId !== address) {\n        throw new Error('Transaction senderId does not match address from passphrase');\n      }\n\n      if (this._senderPublicKey !== '' && this._senderPublicKey !== publicKey) {\n        throw new Error('Transaction senderPublicKey does not match public key from passphrase');\n      }\n\n      this._senderId = address;\n      this._senderPublicKey = publicKey;\n      this._signature = undefined;\n      this._signSignature = undefined;\n      this._signature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(this.getBytes()), passphrase);\n\n      if (secondPassphrase) {\n        this._signSignature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(this.getBytes()), secondPassphrase);\n      }\n\n      this._id = utils_1.getId(this.getBytes());\n    }\n  }, {\n    key: \"fromSync\",\n    value: function fromSync(raw) {\n      var transactionJSON = {\n        id: raw.t_id,\n        height: raw.b_height,\n        blockId: raw.b_id || raw.t_blockId,\n        type: parseInt(raw.t_type, 10),\n        timestamp: parseInt(raw.t_timestamp, 10),\n        senderPublicKey: raw.t_senderPublicKey,\n        requesterPublicKey: raw.t_requesterPublicKey,\n        senderId: raw.t_senderId,\n        recipientId: raw.t_recipientId,\n        recipientPublicKey: raw.m_recipientPublicKey || null,\n        amount: raw.t_amount,\n        fee: raw.t_fee,\n        signature: raw.t_signature,\n        signSignature: raw.t_signSignature,\n        signatures: raw.t_signatures ? raw.t_signatures.split(',') : [],\n        confirmations: parseInt(raw.confirmations || 0, 10),\n        asset: {}\n      };\n      var transaction = Object.assign({}, transactionJSON, {\n        asset: this.assetFromSync(raw) || {}\n      });\n      return transaction;\n    }\n  }, {\n    key: \"getBasicBytes\",\n    value: function getBasicBytes() {\n      var transactionType = Buffer.alloc(constants_1.BYTESIZES.TYPE, this.type);\n      var transactionTimestamp = Buffer.alloc(constants_1.BYTESIZES.TIMESTAMP);\n      transactionTimestamp.writeIntLE(this.timestamp, 0, constants_1.BYTESIZES.TIMESTAMP);\n      var transactionSenderPublicKey = lisk_cryptography_1.hexToBuffer(this.senderPublicKey);\n      var transactionRecipientID = this.recipientId ? lisk_cryptography_1.intToBuffer(this.recipientId.slice(0, -1), constants_1.BYTESIZES.RECIPIENT_ID).slice(0, constants_1.BYTESIZES.RECIPIENT_ID) : Buffer.alloc(constants_1.BYTESIZES.RECIPIENT_ID);\n      var transactionAmount = this.amount.toBuffer({\n        endian: 'little',\n        size: constants_1.BYTESIZES.AMOUNT\n      });\n      return Buffer.concat([transactionType, transactionTimestamp, transactionSenderPublicKey, transactionRecipientID, transactionAmount, this.assetToBytes()]);\n    }\n  }, {\n    key: \"assetToJSON\",\n    value: function assetToJSON() {\n      return this.asset;\n    }\n  }, {\n    key: \"assetToBytes\",\n    value: function assetToBytes() {\n      return Buffer.from(JSON.stringify(this.asset), 'utf-8');\n    }\n  }, {\n    key: \"_verify\",\n    value: function _verify(sender) {\n      var secondSignatureTxBytes = Buffer.concat([this.getBasicBytes(), lisk_cryptography_1.hexToBuffer(this.signature)]);\n      return [utils_1.verifySenderPublicKey(this.id, sender, this.senderPublicKey), utils_1.verifySenderId(this.id, sender, this.senderId), utils_1.verifyBalance(this.id, sender, this.fee), utils_1.verifySecondSignature(this.id, sender, this.signSignature, secondSignatureTxBytes)].filter(Boolean);\n    }\n  }, {\n    key: \"_validateSchema\",\n    value: function _validateSchema() {\n      var transaction = this.toJSON();\n      utils_1.validator.validate(schemas.baseTransaction, transaction);\n      var errors = errors_1.convertToTransactionError(this.id, utils_1.validator.errors);\n\n      if (!errors.find(function (err) {\n        return err.dataPath === '.senderPublicKey';\n      })) {\n        var senderIdError = utils_1.validateSenderIdAndPublicKey(this.id, this.senderId, this.senderPublicKey);\n\n        if (senderIdError) {\n          errors.push(senderIdError);\n        }\n      }\n\n      return errors;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      if (!this._id) {\n        throw new Error('id is required to be set before use');\n      }\n\n      return this._id;\n    }\n  }, {\n    key: \"senderId\",\n    get: function get() {\n      if (!this._senderId) {\n        throw new Error('senderId is required to be set before use');\n      }\n\n      return this._senderId;\n    }\n  }, {\n    key: \"senderPublicKey\",\n    get: function get() {\n      if (!this._senderPublicKey) {\n        throw new Error('senderPublicKey is required to be set before use');\n      }\n\n      return this._senderPublicKey;\n    }\n  }, {\n    key: \"signature\",\n    get: function get() {\n      if (!this._signature) {\n        throw new Error('signature is required to be set before use');\n      }\n\n      return this._signature;\n    }\n  }, {\n    key: \"signSignature\",\n    get: function get() {\n      return this._signSignature;\n    }\n  }]);\n\n  return BaseTransaction;\n}();\n\nBaseTransaction.FEE = '0';\nexports.BaseTransaction = BaseTransaction;","map":{"version":3,"sources":["../src/base_transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BigNum = require(\"@liskhq/bignum\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst constants_1 = require(\"./constants\");\nconst errors_1 = require(\"./errors\");\nconst response_1 = require(\"./response\");\nconst utils_1 = require(\"./utils\");\nconst schemas = require(\"./utils/validation/schema\");\nvar MultisignatureStatus;\n(function (MultisignatureStatus) {\n    MultisignatureStatus[MultisignatureStatus[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    MultisignatureStatus[MultisignatureStatus[\"NONMULTISIGNATURE\"] = 1] = \"NONMULTISIGNATURE\";\n    MultisignatureStatus[MultisignatureStatus[\"PENDING\"] = 2] = \"PENDING\";\n    MultisignatureStatus[MultisignatureStatus[\"READY\"] = 3] = \"READY\";\n    MultisignatureStatus[MultisignatureStatus[\"FAIL\"] = 4] = \"FAIL\";\n})(MultisignatureStatus = exports.MultisignatureStatus || (exports.MultisignatureStatus = {}));\nexports.ENTITY_ACCOUNT = 'account';\nexports.ENTITY_TRANSACTION = 'transaction';\nclass BaseTransaction {\n    constructor(rawTransaction) {\n        this._multisignatureStatus = MultisignatureStatus.UNKNOWN;\n        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null\n            ? rawTransaction\n            : {});\n        this.amount = new BigNum(utils_1.isValidNumber(tx.amount) ? tx.amount : '0');\n        this.fee = new BigNum(utils_1.isValidNumber(tx.fee)\n            ? tx.fee\n            : this.constructor.FEE);\n        this.type =\n            typeof tx.type === 'number'\n                ? tx.type\n                : this.constructor.TYPE;\n        this._id = tx.id;\n        this.recipientId = tx.recipientId || '';\n        this.recipientPublicKey = tx.recipientPublicKey || undefined;\n        this._senderPublicKey = tx.senderPublicKey || '';\n        try {\n            this._senderId = tx.senderId\n                ? tx.senderId\n                : lisk_cryptography_1.getAddressFromPublicKey(this.senderPublicKey);\n        }\n        catch (error) {\n            this._senderId = '';\n        }\n        this._signature = tx.signature;\n        this.signatures = tx.signatures || [];\n        this._signSignature = tx.signSignature;\n        this.timestamp = typeof tx.timestamp === 'number' ? tx.timestamp : 0;\n        this.confirmations = tx.confirmations;\n        this.blockId = tx.blockId;\n        this.height = tx.height;\n        this.receivedAt = tx.receivedAt ? new Date(tx.receivedAt) : undefined;\n        this.relays = typeof tx.relays === 'number' ? tx.relays : undefined;\n        this.asset = tx.asset || {};\n    }\n    get id() {\n        if (!this._id) {\n            throw new Error('id is required to be set before use');\n        }\n        return this._id;\n    }\n    get senderId() {\n        if (!this._senderId) {\n            throw new Error('senderId is required to be set before use');\n        }\n        return this._senderId;\n    }\n    get senderPublicKey() {\n        if (!this._senderPublicKey) {\n            throw new Error('senderPublicKey is required to be set before use');\n        }\n        return this._senderPublicKey;\n    }\n    get signature() {\n        if (!this._signature) {\n            throw new Error('signature is required to be set before use');\n        }\n        return this._signature;\n    }\n    get signSignature() {\n        return this._signSignature;\n    }\n    toJSON() {\n        const transaction = {\n            id: this.id,\n            blockId: this.blockId,\n            height: this.height,\n            relays: this.relays,\n            confirmations: this.confirmations,\n            amount: this.amount.toString(),\n            type: this.type,\n            timestamp: this.timestamp,\n            senderPublicKey: this.senderPublicKey,\n            senderId: this.senderId,\n            recipientId: this.recipientId,\n            recipientPublicKey: this.recipientPublicKey,\n            fee: this.fee.toString(),\n            signature: this.signature,\n            signSignature: this.signSignature ? this.signSignature : undefined,\n            signatures: this.signatures,\n            asset: this.assetToJSON(),\n            receivedAt: this.receivedAt ? this.receivedAt.toISOString() : undefined,\n        };\n        return transaction;\n    }\n    stringify() {\n        return JSON.stringify(this.toJSON());\n    }\n    isReady() {\n        return (this._multisignatureStatus === MultisignatureStatus.READY ||\n            this._multisignatureStatus === MultisignatureStatus.NONMULTISIGNATURE);\n    }\n    getBytes() {\n        const transactionBytes = Buffer.concat([\n            this.getBasicBytes(),\n            this._signature ? lisk_cryptography_1.hexToBuffer(this._signature) : Buffer.alloc(0),\n            this._signSignature ? lisk_cryptography_1.hexToBuffer(this._signSignature) : Buffer.alloc(0),\n        ]);\n        return transactionBytes;\n    }\n    validate() {\n        const errors = [...this._validateSchema(), ...this.validateAsset()];\n        if (errors.length > 0) {\n            return response_1.createResponse(this.id, errors);\n        }\n        const transactionBytes = this.getBasicBytes();\n        const { valid: signatureValid, error: verificationError, } = utils_1.validateSignature(this.senderPublicKey, this.signature, transactionBytes, this.id);\n        if (!signatureValid && verificationError) {\n            errors.push(verificationError);\n        }\n        const idError = utils_1.validateTransactionId(this.id, this.getBytes());\n        if (idError) {\n            errors.push(idError);\n        }\n        if (this.type !== this.constructor.TYPE) {\n            errors.push(new errors_1.TransactionError(`Invalid type`, this.id, '.type', this.type, this.constructor.TYPE));\n        }\n        const feeError = this.validateFee();\n        if (feeError) {\n            errors.push(feeError);\n        }\n        return response_1.createResponse(this.id, errors);\n    }\n    validateFee() {\n        return !this.fee.eq(this.constructor.FEE)\n            ? new errors_1.TransactionError(`Invalid fee`, this.id, '.fee', this.fee.toString(), this.constructor.FEE.toString())\n            : undefined;\n    }\n    verifyAgainstOtherTransactions(transactions) {\n        const errors = this.verifyAgainstTransactions(transactions);\n        return response_1.createResponse(this.id, errors);\n    }\n    apply(store) {\n        const sender = store.account.getOrDefault(this.senderId);\n        const errors = this._verify(sender);\n        const { errors: multiSigError } = this.processMultisignatures(store);\n        if (multiSigError) {\n            errors.push(...multiSigError);\n        }\n        const updatedBalance = new BigNum(sender.balance).sub(this.fee);\n        const updatedSender = Object.assign({}, sender, { balance: updatedBalance.toString(), publicKey: sender.publicKey || this.senderPublicKey });\n        store.account.set(updatedSender.address, updatedSender);\n        const assetErrors = this.applyAsset(store);\n        errors.push(...assetErrors);\n        if (this._multisignatureStatus === MultisignatureStatus.PENDING &&\n            errors.length === 1 &&\n            errors[0] instanceof errors_1.TransactionPendingError) {\n            return {\n                id: this.id,\n                status: response_1.Status.PENDING,\n                errors,\n            };\n        }\n        return response_1.createResponse(this.id, errors);\n    }\n    undo(store) {\n        const sender = store.account.getOrDefault(this.senderId);\n        const updatedBalance = new BigNum(sender.balance).add(this.fee);\n        const updatedAccount = Object.assign({}, sender, { balance: updatedBalance.toString(), publicKey: sender.publicKey || this.senderPublicKey });\n        const errors = updatedBalance.lte(constants_1.MAX_TRANSACTION_AMOUNT)\n            ? []\n            : [\n                new errors_1.TransactionError('Invalid balance amount', this.id, '.balance', sender.balance, updatedBalance.toString()),\n            ];\n        store.account.set(updatedAccount.address, updatedAccount);\n        const assetErrors = this.undoAsset(store);\n        errors.push(...assetErrors);\n        return response_1.createResponse(this.id, errors);\n    }\n    async prepare(store) {\n        await store.account.cache([\n            {\n                address: this.senderId,\n            },\n        ]);\n    }\n    addMultisignature(store, signatureObject) {\n        const account = store.account.get(this.senderId);\n        if (account.membersPublicKeys &&\n            !account.membersPublicKeys.includes(signatureObject.publicKey)) {\n            return response_1.createResponse(this.id, [\n                new errors_1.TransactionError(`Public Key '${signatureObject.publicKey}' is not a member for account '${account.address}'.`, this.id),\n            ]);\n        }\n        if (this.signatures.includes(signatureObject.signature)) {\n            return response_1.createResponse(this.id, [\n                new errors_1.TransactionError(`Signature '${signatureObject.signature}' already present in transaction.`, this.id),\n            ]);\n        }\n        const { valid } = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, this.getBasicBytes(), this.id);\n        if (valid) {\n            this.signatures.push(signatureObject.signature);\n            return this.processMultisignatures(store);\n        }\n        const errors = valid\n            ? []\n            : [\n                new errors_1.TransactionError(`Failed to add signature '${signatureObject.signature}'.`, this.id, '.signatures'),\n            ];\n        return response_1.createResponse(this.id, errors);\n    }\n    addVerifiedMultisignature(signature) {\n        if (!this.signatures.includes(signature)) {\n            this.signatures.push(signature);\n            return response_1.createResponse(this.id, []);\n        }\n        return response_1.createResponse(this.id, [\n            new errors_1.TransactionError('Failed to add signature.', this.id, '.signatures'),\n        ]);\n    }\n    processMultisignatures(store) {\n        const sender = store.account.get(this.senderId);\n        const transactionBytes = this.getBasicBytes();\n        const { status, errors } = utils_1.verifyMultiSignatures(this.id, sender, this.signatures, transactionBytes);\n        this._multisignatureStatus = status;\n        if (this._multisignatureStatus === MultisignatureStatus.PENDING) {\n            return {\n                id: this.id,\n                status: response_1.Status.PENDING,\n                errors,\n            };\n        }\n        return response_1.createResponse(this.id, errors);\n    }\n    isExpired(date = new Date()) {\n        if (!this.receivedAt) {\n            this.receivedAt = new Date();\n        }\n        const timeNow = Math.floor(date.getTime() / 1000);\n        const timeOut = this._multisignatureStatus === MultisignatureStatus.PENDING ||\n            this._multisignatureStatus === MultisignatureStatus.READY\n            ? constants_1.UNCONFIRMED_MULTISIG_TRANSACTION_TIMEOUT\n            : constants_1.UNCONFIRMED_TRANSACTION_TIMEOUT;\n        const timeElapsed = timeNow - Math.floor(this.receivedAt.getTime() / 1000);\n        return timeElapsed > timeOut;\n    }\n    sign(passphrase, secondPassphrase) {\n        const { address, publicKey } = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase);\n        if (this._senderId !== '' && this._senderId !== address) {\n            throw new Error('Transaction senderId does not match address from passphrase');\n        }\n        if (this._senderPublicKey !== '' && this._senderPublicKey !== publicKey) {\n            throw new Error('Transaction senderPublicKey does not match public key from passphrase');\n        }\n        this._senderId = address;\n        this._senderPublicKey = publicKey;\n        this._signature = undefined;\n        this._signSignature = undefined;\n        this._signature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(this.getBytes()), passphrase);\n        if (secondPassphrase) {\n            this._signSignature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(this.getBytes()), secondPassphrase);\n        }\n        this._id = utils_1.getId(this.getBytes());\n    }\n    fromSync(raw) {\n        const transactionJSON = {\n            id: raw.t_id,\n            height: raw.b_height,\n            blockId: raw.b_id || raw.t_blockId,\n            type: parseInt(raw.t_type, 10),\n            timestamp: parseInt(raw.t_timestamp, 10),\n            senderPublicKey: raw.t_senderPublicKey,\n            requesterPublicKey: raw.t_requesterPublicKey,\n            senderId: raw.t_senderId,\n            recipientId: raw.t_recipientId,\n            recipientPublicKey: raw.m_recipientPublicKey || null,\n            amount: raw.t_amount,\n            fee: raw.t_fee,\n            signature: raw.t_signature,\n            signSignature: raw.t_signSignature,\n            signatures: raw.t_signatures ? raw.t_signatures.split(',') : [],\n            confirmations: parseInt(raw.confirmations || 0, 10),\n            asset: {},\n        };\n        const transaction = Object.assign({}, transactionJSON, { asset: this.assetFromSync(raw) || {} });\n        return transaction;\n    }\n    getBasicBytes() {\n        const transactionType = Buffer.alloc(constants_1.BYTESIZES.TYPE, this.type);\n        const transactionTimestamp = Buffer.alloc(constants_1.BYTESIZES.TIMESTAMP);\n        transactionTimestamp.writeIntLE(this.timestamp, 0, constants_1.BYTESIZES.TIMESTAMP);\n        const transactionSenderPublicKey = lisk_cryptography_1.hexToBuffer(this.senderPublicKey);\n        const transactionRecipientID = this.recipientId\n            ? lisk_cryptography_1.intToBuffer(this.recipientId.slice(0, -1), constants_1.BYTESIZES.RECIPIENT_ID).slice(0, constants_1.BYTESIZES.RECIPIENT_ID)\n            : Buffer.alloc(constants_1.BYTESIZES.RECIPIENT_ID);\n        const transactionAmount = this.amount.toBuffer({\n            endian: 'little',\n            size: constants_1.BYTESIZES.AMOUNT,\n        });\n        return Buffer.concat([\n            transactionType,\n            transactionTimestamp,\n            transactionSenderPublicKey,\n            transactionRecipientID,\n            transactionAmount,\n            this.assetToBytes(),\n        ]);\n    }\n    assetToJSON() {\n        return this.asset;\n    }\n    assetToBytes() {\n        return Buffer.from(JSON.stringify(this.asset), 'utf-8');\n    }\n    _verify(sender) {\n        const secondSignatureTxBytes = Buffer.concat([\n            this.getBasicBytes(),\n            lisk_cryptography_1.hexToBuffer(this.signature),\n        ]);\n        return [\n            utils_1.verifySenderPublicKey(this.id, sender, this.senderPublicKey),\n            utils_1.verifySenderId(this.id, sender, this.senderId),\n            utils_1.verifyBalance(this.id, sender, this.fee),\n            utils_1.verifySecondSignature(this.id, sender, this.signSignature, secondSignatureTxBytes),\n        ].filter(Boolean);\n    }\n    _validateSchema() {\n        const transaction = this.toJSON();\n        utils_1.validator.validate(schemas.baseTransaction, transaction);\n        const errors = errors_1.convertToTransactionError(this.id, utils_1.validator.errors);\n        if (!errors.find((err) => err.dataPath === '.senderPublicKey')) {\n            const senderIdError = utils_1.validateSenderIdAndPublicKey(this.id, this.senderId, this.senderPublicKey);\n            if (senderIdError) {\n                errors.push(senderIdError);\n            }\n        }\n        return errors;\n    }\n}\nBaseTransaction.FEE = '0';\nexports.BaseTransaction = BaseTransaction;\n//# sourceMappingURL=base_transaction.js.map"]},"metadata":{},"sourceType":"script"}