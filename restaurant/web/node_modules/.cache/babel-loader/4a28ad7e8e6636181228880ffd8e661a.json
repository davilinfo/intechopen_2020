{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst reverse = require(\"buffer-reverse\");\n\nconst ed2curve = require(\"ed2curve\");\n\nconst querystring = require(\"querystring\");\n\nconst buffer_1 = require(\"./buffer\");\n\nconst hash_1 = require(\"./hash\");\n\nexports.getFirstEightBytesReversed = input => {\n  const BUFFER_SIZE = 8;\n\n  if (typeof input === 'string') {\n    return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\n  }\n\n  return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\n};\n\nexports.toAddress = buffer => {\n  const BUFFER_SIZE = 8;\n\n  if (!Buffer.from(buffer).slice(0, BUFFER_SIZE).equals(buffer)) {\n    throw new Error('The buffer for Lisk addresses must not have more than 8 bytes');\n  }\n\n  return `${buffer_1.bufferToIntAsString(buffer)}L`;\n};\n\nexports.getAddressFromPublicKey = publicKey => {\n  const publicKeyHash = hash_1.hash(publicKey, 'hex');\n  const publicKeyTransform = exports.getFirstEightBytesReversed(publicKeyHash);\n  const address = exports.toAddress(publicKeyTransform);\n  return address;\n};\n\nexports.convertPublicKeyEd2Curve = ed2curve.convertPublicKey;\nexports.convertPrivateKeyEd2Curve = ed2curve.convertSecretKey;\n\nexports.stringifyEncryptedPassphrase = encryptedPassphrase => {\n  if (typeof encryptedPassphrase !== 'object' || encryptedPassphrase === null) {\n    throw new Error('Encrypted passphrase to stringify must be an object.');\n  }\n\n  const objectToStringify = encryptedPassphrase.iterations ? encryptedPassphrase : {\n    salt: encryptedPassphrase.salt,\n    cipherText: encryptedPassphrase.cipherText,\n    iv: encryptedPassphrase.iv,\n    tag: encryptedPassphrase.tag,\n    version: encryptedPassphrase.version\n  };\n  return querystring.stringify(objectToStringify);\n};\n\nconst parseIterations = iterationsString => {\n  const iterations = iterationsString === undefined ? undefined : parseInt(iterationsString, 10);\n\n  if (typeof iterations !== 'undefined' && Number.isNaN(iterations)) {\n    throw new Error('Could not parse iterations.');\n  }\n\n  return iterations;\n};\n\nexports.parseEncryptedPassphrase = encryptedPassphrase => {\n  if (typeof encryptedPassphrase !== 'string') {\n    throw new Error('Encrypted passphrase to parse must be a string.');\n  }\n\n  const keyValuePairs = querystring.parse(encryptedPassphrase);\n  const {\n    iterations,\n    salt,\n    cipherText,\n    iv,\n    tag,\n    version\n  } = keyValuePairs;\n\n  if (typeof iterations !== 'string' && typeof iterations !== 'undefined' || typeof salt !== 'string' || typeof cipherText !== 'string' || typeof iv !== 'string' || typeof tag !== 'string' || typeof version !== 'string') {\n    throw new Error('Encrypted passphrase to parse must have only one value per key.');\n  }\n\n  return {\n    iterations: parseIterations(iterations),\n    salt,\n    cipherText,\n    iv,\n    tag,\n    version\n  };\n};","map":{"version":3,"sources":["../src/convert.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst reverse = require(\"buffer-reverse\");\nconst ed2curve = require(\"ed2curve\");\nconst querystring = require(\"querystring\");\nconst buffer_1 = require(\"./buffer\");\nconst hash_1 = require(\"./hash\");\nexports.getFirstEightBytesReversed = (input) => {\n    const BUFFER_SIZE = 8;\n    if (typeof input === 'string') {\n        return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\n    }\n    return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\n};\nexports.toAddress = (buffer) => {\n    const BUFFER_SIZE = 8;\n    if (!Buffer.from(buffer)\n        .slice(0, BUFFER_SIZE)\n        .equals(buffer)) {\n        throw new Error('The buffer for Lisk addresses must not have more than 8 bytes');\n    }\n    return `${buffer_1.bufferToIntAsString(buffer)}L`;\n};\nexports.getAddressFromPublicKey = (publicKey) => {\n    const publicKeyHash = hash_1.hash(publicKey, 'hex');\n    const publicKeyTransform = exports.getFirstEightBytesReversed(publicKeyHash);\n    const address = exports.toAddress(publicKeyTransform);\n    return address;\n};\nexports.convertPublicKeyEd2Curve = ed2curve.convertPublicKey;\nexports.convertPrivateKeyEd2Curve = ed2curve.convertSecretKey;\nexports.stringifyEncryptedPassphrase = (encryptedPassphrase) => {\n    if (typeof encryptedPassphrase !== 'object' || encryptedPassphrase === null) {\n        throw new Error('Encrypted passphrase to stringify must be an object.');\n    }\n    const objectToStringify = encryptedPassphrase.iterations\n        ? encryptedPassphrase\n        : {\n            salt: encryptedPassphrase.salt,\n            cipherText: encryptedPassphrase.cipherText,\n            iv: encryptedPassphrase.iv,\n            tag: encryptedPassphrase.tag,\n            version: encryptedPassphrase.version,\n        };\n    return querystring.stringify(objectToStringify);\n};\nconst parseIterations = (iterationsString) => {\n    const iterations = iterationsString === undefined ? undefined : parseInt(iterationsString, 10);\n    if (typeof iterations !== 'undefined' && Number.isNaN(iterations)) {\n        throw new Error('Could not parse iterations.');\n    }\n    return iterations;\n};\nexports.parseEncryptedPassphrase = (encryptedPassphrase) => {\n    if (typeof encryptedPassphrase !== 'string') {\n        throw new Error('Encrypted passphrase to parse must be a string.');\n    }\n    const keyValuePairs = querystring.parse(encryptedPassphrase);\n    const { iterations, salt, cipherText, iv, tag, version } = keyValuePairs;\n    if ((typeof iterations !== 'string' && typeof iterations !== 'undefined') ||\n        typeof salt !== 'string' ||\n        typeof cipherText !== 'string' ||\n        typeof iv !== 'string' ||\n        typeof tag !== 'string' ||\n        typeof version !== 'string') {\n        throw new Error('Encrypted passphrase to parse must have only one value per key.');\n    }\n    return {\n        iterations: parseIterations(iterations),\n        salt,\n        cipherText,\n        iv,\n        tag,\n        version,\n    };\n};\n//# sourceMappingURL=convert.js.map"]},"metadata":{},"sourceType":"script"}